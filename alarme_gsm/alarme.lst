CCS PCH C Compiler, Version 5.008, 5967               12-mars-16 21:00

               Filename:   C:\Users\macbook\Desktop\alarme_gsm\alarme.lst

               ROM used:   19672 bytes (60%)
                           Largest free fragment is 13096
               RAM used:   1100 (54%) at main() level
                           1165 (57%) worst case
               Stack used: 15 locations (6 in main + 9 for interrupts)
               Stack size: 31

*
0000:  GOTO   3AE4
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.5
004A:  GOTO   0054
004E:  BTFSC  F9E.5
0050:  GOTO   104C
0054:  BTFSS  FA0.5
0056:  GOTO   0060
005A:  BTFSC  FA1.5
005C:  GOTO   0F34
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVF   04,W
0098:  MOVFF  06,FE0
009C:  MOVFF  05,FD8
00A0:  RETFIE 0
....................  
.................... #include <18F2550.h> 
.................... //////// Standard Header file for the PIC18F2550 device //////////////// 
.................... #device PIC18F2550 
00A2:  MOVFF  FF2,0D
00A6:  BCF    FF2.7
00A8:  CLRF   FF7
00AA:  ADDLW  BC
00AC:  MOVWF  FF6
00AE:  MOVLW  00
00B0:  ADDWFC FF7,F
00B2:  TBLRD*+
00B4:  MOVF   FF5,W
00B6:  BTFSC  0D.7
00B8:  BSF    FF2.7
00BA:  RETURN 0
00BC:  DATA 50,53
00BE:  DATA 52,46
00C0:  DATA 31,30
00C2:  DATA 33,2C
00C4:  DATA 30,30
00C6:  DATA 2C,30
00C8:  DATA 30,2C
00CA:  DATA 30,30
00CC:  DATA 2C,30
00CE:  DATA 31,00
00D0:  MOVFF  FF2,0D
00D4:  BCF    FF2.7
00D6:  CLRF   FF7
00D8:  ADDLW  EA
00DA:  MOVWF  FF6
00DC:  MOVLW  00
00DE:  ADDWFC FF7,F
00E0:  TBLRD*+
00E2:  MOVF   FF5,W
00E4:  BTFSC  0D.7
00E6:  BSF    FF2.7
00E8:  RETURN 0
00EA:  DATA 50,53
00EC:  DATA 52,46
00EE:  DATA 31,30
00F0:  DATA 33,2C
00F2:  DATA 30,30
00F4:  DATA 2C,30
00F6:  DATA 31,2C
00F8:  DATA 30,30
00FA:  DATA 2C,30
00FC:  DATA 31,00
00FE:  MOVFF  FF2,0D
0102:  BCF    FF2.7
0104:  CLRF   FF7
0106:  ADDLW  18
0108:  MOVWF  FF6
010A:  MOVLW  01
010C:  ADDWFC FF7,F
010E:  TBLRD*+
0110:  MOVF   FF5,W
0112:  BTFSC  0D.7
0114:  BSF    FF2.7
0116:  RETURN 0
0118:  DATA 24,47
011A:  DATA 50,47
011C:  DATA 47,41
011E:  DATA 00,00
0120:  CLRF   FF7
0122:  ADDLW  30
0124:  MOVWF  FF6
0126:  MOVLW  01
0128:  ADDWFC FF7,F
012A:  TBLRD*+
012C:  MOVF   FF5,W
012E:  RETURN 0
0130:  DATA 00,02
0132:  DATA FF,FF
0134:  DATA FF,FF
0136:  DATA FF,FF
0138:  DATA FF,FF
013A:  DATA FF,FF
013C:  DATA FF,FF
013E:  DATA FF,FF
0140:  BTFSS  07.7
0142:  BRA    014A
0144:  MOVFF  FF2,0D
0148:  BCF    FF2.7
014A:  CLRF   FF7
014C:  ADDLW  62
014E:  MOVWF  FF6
0150:  MOVLW  01
0152:  ADDWFC FF7,F
0154:  TBLRD*+
0156:  MOVF   FF5,W
0158:  BTFSS  07.7
015A:  BRA    0160
015C:  BTFSC  0D.7
015E:  BSF    FF2.7
0160:  RETURN 0
0162:  DATA 40,00
0164:  DATA 20,00
0166:  DATA 00,00
0168:  DATA 00,00
016A:  DATA 00,00
016C:  DATA 00,00
016E:  DATA 00,00
0170:  DATA 00,00
0172:  DATA 00,00
0174:  DATA 00,00
0176:  DATA 00,00
0178:  DATA 00,00
017A:  DATA 00,00
017C:  DATA 00,00
017E:  DATA 00,00
0180:  DATA 00,00
0182:  CLRF   FF7
0184:  ADDLW  92
0186:  MOVWF  FF6
0188:  MOVLW  01
018A:  ADDWFC FF7,F
018C:  TBLRD*+
018E:  MOVF   FF5,W
0190:  RETURN 0
0192:  DATA 09,02
0194:  DATA 20,00
0196:  DATA 01,01
0198:  DATA 00,C0
019A:  DATA 32,09
019C:  DATA 04,00
019E:  DATA 00,02
01A0:  DATA FF,FF
01A2:  DATA FF,00
01A4:  DATA 07,05
01A6:  DATA 81,02
01A8:  DATA 20,00
01AA:  DATA 01,07
01AC:  DATA 05,01
01AE:  DATA 02,20
01B0:  DATA 00,01
01B2:  CLRF   FF7
01B4:  ADDLW  C2
01B6:  MOVWF  FF6
01B8:  MOVLW  01
01BA:  ADDWFC FF7,F
01BC:  TBLRD*+
01BE:  MOVF   FF5,W
01C0:  RETURN 0
01C2:  DATA 01,00
01C4:  CLRF   FF7
01C6:  ADDLW  D4
01C8:  MOVWF  FF6
01CA:  MOVLW  01
01CC:  ADDWFC FF7,F
01CE:  TBLRD*+
01D0:  MOVF   FF5,W
01D2:  RETURN 0
01D4:  DATA 12,01
01D6:  DATA 10,01
01D8:  DATA 00,00
01DA:  DATA 00,40
01DC:  DATA 77,07
01DE:  DATA 84,50
01E0:  DATA 02,00
01E2:  DATA 01,02
01E4:  DATA 00,01
01E6:  CLRF   FF7
01E8:  ADDLW  F6
01EA:  MOVWF  FF6
01EC:  MOVLW  01
01EE:  ADDWFC FF7,F
01F0:  TBLRD*+
01F2:  MOVF   FF5,W
01F4:  RETURN 0
01F6:  DATA 00,04
01F8:  DATA 0E,00
01FA:  CLRF   FF7
01FC:  ADDLW  0A
01FE:  MOVWF  FF6
0200:  MOVLW  02
0202:  ADDWFC FF7,F
0204:  TBLRD*+
0206:  MOVF   FF5,W
0208:  RETURN 0
020A:  DATA 04,03
020C:  DATA 09,04
020E:  DATA 0A,03
0210:  DATA 45,00
0212:  DATA 4D,00
0214:  DATA 4E,00
0216:  DATA 54,00
0218:  DATA 28,03
021A:  DATA 45,00
021C:  DATA 4D,00
021E:  DATA 4E,00
0220:  DATA 54,00
0222:  DATA 20,00
0224:  DATA 47,00
0226:  DATA 50,00
0228:  DATA 53,00
022A:  DATA 2F,00
022C:  DATA 47,00
022E:  DATA 53,00
0230:  DATA 4D,00
0232:  DATA 20,00
0234:  DATA 53,00
0236:  DATA 79,00
0238:  DATA 73,00
023A:  DATA 74,00
023C:  DATA 65,00
023E:  DATA 6D,00
0240:  DATA 41,54
0242:  DATA 0D,0A
0244:  DATA 00,00
0246:  DATA 41,54
0248:  DATA 20,50
024A:  DATA 49,43
024C:  DATA 2D,3E
024E:  DATA 53,49
0250:  DATA 4D,0D
0252:  DATA 0A,00
0254:  DATA 41,54
0256:  DATA 20,4F
0258:  DATA 4B,0D
025A:  DATA 0A,00
025C:  DATA 41,54
025E:  DATA 2B,49
0260:  DATA 50,52
0262:  DATA 3D,39
0264:  DATA 36,30
0266:  DATA 30,0D
0268:  DATA 0A,00
026A:  DATA 41,54
026C:  DATA 2B,43
026E:  DATA 50,42
0270:  DATA 53,3D
0272:  DATA 22,53
0274:  DATA 4D,22
0276:  DATA 0A,0D
0278:  DATA 00,00
027A:  DATA 41,54
027C:  DATA 2B,43
027E:  DATA 4D,47
0280:  DATA 46,3D
0282:  DATA 31,0D
0284:  DATA 0A,00
0286:  DATA 41,54
0288:  DATA 2B,43
028A:  DATA 4D,47
028C:  DATA 44,3D
028E:  DATA 31,0D
0290:  DATA 0A,00
0292:  DATA 41,54
0294:  DATA 2B,43
0296:  DATA 4E,4D
0298:  DATA 49,3D
029A:  DATA 33,2C
029C:  DATA 31,0D
029E:  DATA 0A,00
02A0:  DATA 41,54
02A2:  DATA 45,30
02A4:  DATA 0D,0A
02A6:  DATA 00,00
02A8:  DATA 41,54
02AA:  DATA 2B,43
02AC:  DATA 4C,49
02AE:  DATA 50,3D
02B0:  DATA 31,0D
02B2:  DATA 0A,00
02B4:  DATA 41,54
02B6:  DATA 2B,43
02B8:  DATA 4D,47
02BA:  DATA 53,3D
02BC:  DATA 25,69
02BE:  DATA 0D,0A
02C0:  DATA 00,00
02C2:  DATA 30,37
02C4:  DATA 39,31
02C6:  DATA 39,34
02C8:  DATA 37,31
02CA:  DATA 30,31
02CC:  DATA 36,37
02CE:  DATA 30,30
02D0:  DATA 30,30
02D2:  DATA 00,00
02D4:  DATA 31,31
02D6:  DATA 33,43
02D8:  DATA 00,00
02DA:  DATA 30,30
02DC:  DATA 30,30
02DE:  DATA 41,38
02E0:  DATA 00,00
02E2:  DATA 41,54
02E4:  DATA 2B,43
02E6:  DATA 4D,47
02E8:  DATA 46,3D
02EA:  DATA 31,0D
02EC:  DATA 0A,00
02EE:  DATA 41,54
02F0:  DATA 2B,43
02F2:  DATA 4D,47
02F4:  DATA 53,3D
02F6:  DATA 22,25
02F8:  DATA 73,22
02FA:  DATA 0D,0A
02FC:  DATA 00,00
02FE:  DATA 25,73
0300:  DATA 20,3A
0302:  DATA 20,00
0304:  DATA 25,63
0306:  DATA 20,3A
0308:  DATA 20,00
030A:  DATA 41,54
030C:  DATA 44,25
030E:  DATA 73,3B
0310:  DATA 0D,0A
0312:  DATA 00,00
0314:  DATA 4E,6F
0316:  DATA 20,6F
0318:  DATA 6B,0D
031A:  DATA 0A,00
031C:  DATA 62,75
031E:  DATA 66,66
0320:  DATA 65,72
0322:  DATA 3D,25
0324:  DATA 63,25
0326:  DATA 63,25
0328:  DATA 63,25
032A:  DATA 63,0D
032C:  DATA 0A,00
032E:  DATA 42,75
0330:  DATA 73,79
0332:  DATA 20,73
0334:  DATA 74,61
0336:  DATA 74,75
0338:  DATA 73,0D
033A:  DATA 0A,00
033C:  DATA 4E,6F
033E:  DATA 20,63
0340:  DATA 61,72
0342:  DATA 72,20
0344:  DATA 73,74
0346:  DATA 61,74
0348:  DATA 75,73
034A:  DATA 20,25
034C:  DATA 63,25
034E:  DATA 63,25
0350:  DATA 63,25
0352:  DATA 63,0D
0354:  DATA 0A,00
0356:  DATA 47,65
0358:  DATA 74,20
035A:  DATA 53,70
035C:  DATA 65,65
035E:  DATA 64,0D
0360:  DATA 0A,00
0362:  DATA 47,65
0364:  DATA 74,20
0366:  DATA 54,69
0368:  DATA 6D,65
036A:  DATA 0D,0A
036C:  DATA 00,00
036E:  DATA 6D,73
0370:  DATA 67,3D
0372:  DATA 25,73
0374:  DATA 0D,0A
0376:  DATA 00,00
0378:  DATA 47,65
037A:  DATA 74,20
037C:  DATA 50,6F
037E:  DATA 73,69
0380:  DATA 74,69
0382:  DATA 6F,6E
0384:  DATA 0D,0A
0386:  DATA 00,00
0388:  DATA 47,65
038A:  DATA 74,20
038C:  DATA 50,6F
038E:  DATA 73,69
0390:  DATA 74,69
0392:  DATA 6F,6E
0394:  DATA 0D,0A
0396:  DATA 00,00
0398:  DATA 6D,73
039A:  DATA 67,3D
039C:  DATA 25,73
039E:  DATA 0D,0A
03A0:  DATA 00,00
03A2:  DATA 41,54
03A4:  DATA 2B,43
03A6:  DATA 50,42
03A8:  DATA 52,3D
03AA:  DATA 25,64
03AC:  DATA 0D,0A
03AE:  DATA 00,00
03B0:  DATA 41,54
03B2:  DATA 2B,43
03B4:  DATA 4D,47
03B6:  DATA 52,3D
03B8:  DATA 31,0D
03BA:  DATA 0A,00
03BC:  DATA 41,54
03BE:  DATA 2B,43
03C0:  DATA 4D,47
03C2:  DATA 44,3D
03C4:  DATA 31,0D
03C6:  DATA 0A,00
03C8:  DATA 25,73
03CA:  DATA 0D,0A
03CC:  DATA 53,6F
03CE:  DATA 6C,64
03D0:  DATA 3D,20
03D2:  DATA 25,6C
03D4:  DATA 64,20
03D6:  DATA 44,41
03D8:  DATA 0D,0A
03DA:  DATA 00,00
03DC:  DATA 47,50
03DE:  DATA 53,20
03E0:  DATA 47,45
03E2:  DATA 54,20
03E4:  DATA 50,4F
03E6:  DATA 53,00
*
102C:  TBLRD*+
102E:  MOVF   FF5,F
1030:  BZ    104A
1032:  MOVFF  FF6,3AC
1036:  MOVFF  FF7,3AD
103A:  MOVFF  FF5,3AE
103E:  RCALL  0FDA
1040:  MOVFF  3AC,FF6
1044:  MOVFF  3AD,FF7
1048:  BRA    102C
104A:  RETURN 0
*
1264:  DATA 52,49
1266:  DATA 4E,47
1268:  DATA 0D,0A
126A:  DATA 00,00
126C:  DATA 45,4E
126E:  DATA 56,4F
1270:  DATA 59,45
1272:  DATA 52,20
1274:  DATA 4C,45
1276:  DATA 20,4D
1278:  DATA 45,53
127A:  DATA 53,41
127C:  DATA 47,45
127E:  DATA 20,61
1280:  DATA 75,20
1282:  DATA 4E,B0
1284:  DATA 3D,25
1286:  DATA 73,0D
1288:  DATA 0A,00
128A:  DATA 78,3D
128C:  DATA 25,73
128E:  DATA 20,3B
1290:  DATA 20,79
1292:  DATA 3D,25
1294:  DATA 73,20
1296:  DATA 0A,0D
1298:  DATA 00,00
129A:  DATA 41,54
129C:  DATA 2B,43
129E:  DATA 4D,47
12A0:  DATA 53,3D
12A2:  DATA 22,25
12A4:  DATA 73,22
12A6:  DATA 0D,0A
12A8:  DATA 00,00
12AA:  DATA 41,6C
12AC:  DATA 65,72
12AE:  DATA 74,65
12B0:  DATA 20,3A
12B2:  DATA 20,4F
12B4:  DATA 75,76
12B6:  DATA 65,72
12B8:  DATA 74,75
12BA:  DATA 72,65
12BC:  DATA 20,44
12BE:  DATA 65,73
12C0:  DATA 20,50
12C2:  DATA 6F,72
12C4:  DATA 74,65
12C6:  DATA 73,20
12C8:  DATA 64,75
12CA:  DATA 20,56
12CC:  DATA 65,68
12CE:  DATA 69,63
12D0:  DATA 75,6C
12D2:  DATA 65,20
12D4:  DATA E0,20
12D6:  DATA 6C,61
12D8:  DATA 20,50
12DA:  DATA 6F,73
12DC:  DATA 69,74
12DE:  DATA 69,6F
12E0:  DATA 6E,20
12E2:  DATA 3A,0D
12E4:  DATA 0A,00
12E6:  DATA 50,6F
12E8:  DATA 73,3D
12EA:  DATA 25,73
12EC:  DATA 20,25
12EE:  DATA 73,0D
12F0:  DATA 0A,00
12F2:  DATA 56,6F
12F4:  DATA 75,73
12F6:  DATA 20,50
12F8:  DATA 6F,75
12FA:  DATA 76,65
12FC:  DATA 7A,20
12FE:  DATA 4C,6F
1300:  DATA 63,61
1302:  DATA 6C,69
1304:  DATA 73,65
1306:  DATA 72,20
1308:  DATA 56,6F
130A:  DATA 74,72
130C:  DATA 65,20
130E:  DATA 56,65
1310:  DATA 68,69
1312:  DATA 63,75
1314:  DATA 6C,65
1316:  DATA 20,56
1318:  DATA 69,61
131A:  DATA 20,68
131C:  DATA 74,74
131E:  DATA 70,3A
1320:  DATA 2F,2F
1322:  DATA 6D,61
1324:  DATA 70,73
1326:  DATA 2E,67
1328:  DATA 6F,6F
132A:  DATA 67,6C
132C:  DATA 65,2E
132E:  DATA 63,6F
1330:  DATA 6D,0D
1332:  DATA 0A,00
1334:  DATA 41,6C
1336:  DATA 65,72
1338:  DATA 74,65
133A:  DATA 20,3A
133C:  DATA 20,4F
133E:  DATA 75,76
1340:  DATA 65,72
1342:  DATA 74,75
1344:  DATA 72,65
1346:  DATA 20,44
1348:  DATA 75,20
134A:  DATA 43,61
134C:  DATA 70,6F
134E:  DATA 74,20
1350:  DATA 64,75
1352:  DATA 20,56
1354:  DATA 65,68
1356:  DATA 69,63
1358:  DATA 75,6C
135A:  DATA 65,20
135C:  DATA E0,20
135E:  DATA 6C,61
1360:  DATA 20,50
1362:  DATA 6F,73
1364:  DATA 69,74
1366:  DATA 69,6F
1368:  DATA 6E,20
136A:  DATA 3A,0D
136C:  DATA 0A,00
136E:  DATA 50,6F
1370:  DATA 73,3D
1372:  DATA 25,73
1374:  DATA 20,25
1376:  DATA 73,0D
1378:  DATA 0A,00
137A:  DATA 56,6F
137C:  DATA 75,73
137E:  DATA 20,50
1380:  DATA 6F,75
1382:  DATA 76,65
1384:  DATA 7A,20
1386:  DATA 4C,6F
1388:  DATA 63,61
138A:  DATA 6C,69
138C:  DATA 73,65
138E:  DATA 72,20
1390:  DATA 56,6F
1392:  DATA 74,72
1394:  DATA 65,20
1396:  DATA 56,65
1398:  DATA 68,69
139A:  DATA 63,75
139C:  DATA 6C,65
139E:  DATA 20,56
13A0:  DATA 69,61
13A2:  DATA 20,68
13A4:  DATA 74,74
13A6:  DATA 70,3A
13A8:  DATA 2F,2F
13AA:  DATA 6D,61
13AC:  DATA 70,73
13AE:  DATA 2E,67
13B0:  DATA 6F,6F
13B2:  DATA 67,6C
13B4:  DATA 65,2E
13B6:  DATA 63,6F
13B8:  DATA 6D,0D
13BA:  DATA 0A,00
13BC:  DATA 41,6C
13BE:  DATA 65,72
13C0:  DATA 74,65
13C2:  DATA 20,3A
13C4:  DATA 20,56
13C6:  DATA 6F,74
13C8:  DATA 72,65
13CA:  DATA 20,56
13CC:  DATA 65,68
13CE:  DATA 69,63
13D0:  DATA 75,6C
13D2:  DATA 65,20
13D4:  DATA E0,20
13D6:  DATA E9,74
13D8:  DATA E9,20
13DA:  DATA 54,6F
13DC:  DATA 75,63
13DE:  DATA 68,65
13E0:  DATA 72,20
13E2:  DATA E0,20
13E4:  DATA 6C,61
13E6:  DATA 20,50
13E8:  DATA 6F,73
13EA:  DATA 69,74
13EC:  DATA 69,6F
13EE:  DATA 6E,20
13F0:  DATA 3A,0D
13F2:  DATA 0A,00
13F4:  DATA 50,6F
13F6:  DATA 73,3D
13F8:  DATA 25,73
13FA:  DATA 20,25
13FC:  DATA 73,0D
13FE:  DATA 0A,00
1400:  DATA 56,6F
1402:  DATA 75,73
1404:  DATA 20,50
1406:  DATA 6F,75
1408:  DATA 76,65
140A:  DATA 7A,20
140C:  DATA 4C,6F
140E:  DATA 63,61
1410:  DATA 6C,69
1412:  DATA 73,65
1414:  DATA 72,20
1416:  DATA 56,6F
1418:  DATA 74,72
141A:  DATA 65,20
141C:  DATA 56,65
141E:  DATA 68,69
1420:  DATA 63,75
1422:  DATA 6C,65
1424:  DATA 20,56
1426:  DATA 69,61
1428:  DATA 20,68
142A:  DATA 74,74
142C:  DATA 70,3A
142E:  DATA 2F,2F
1430:  DATA 6D,61
1432:  DATA 70,73
1434:  DATA 2E,67
1436:  DATA 6F,6F
1438:  DATA 67,6C
143A:  DATA 65,2E
143C:  DATA 63,6F
143E:  DATA 6D,0D
1440:  DATA 0A,00
1442:  DATA 41,6C
1444:  DATA 65,72
1446:  DATA 74,65
1448:  DATA 20,3A
144A:  DATA 20,41
144C:  DATA 72,72
144E:  DATA 65,74
1450:  DATA 20,64
1452:  DATA 75,20
1454:  DATA 56,65
1456:  DATA 68,69
1458:  DATA 63,75
145A:  DATA 6C,65
145C:  DATA 20,63
145E:  DATA 6F,6D
1460:  DATA 6D,61
1462:  DATA 6E,64
1464:  DATA 65,72
1466:  DATA 20,70
1468:  DATA 61,72
146A:  DATA 20,73
146C:  DATA 6D,73
146E:  DATA 20,E0
1470:  DATA 20,6C
1472:  DATA 61,20
1474:  DATA 50,6F
1476:  DATA 73,69
1478:  DATA 74,69
147A:  DATA 6F,6E
147C:  DATA 20,3A
147E:  DATA 0D,0A
1480:  DATA 00,00
1482:  DATA 50,6F
1484:  DATA 73,3D
1486:  DATA 25,73
1488:  DATA 20,25
148A:  DATA 73,0D
148C:  DATA 0A,00
148E:  DATA 56,6F
1490:  DATA 75,73
1492:  DATA 20,50
1494:  DATA 6F,75
1496:  DATA 76,65
1498:  DATA 7A,20
149A:  DATA 4C,6F
149C:  DATA 63,61
149E:  DATA 6C,69
14A0:  DATA 73,65
14A2:  DATA 72,20
14A4:  DATA 56,6F
14A6:  DATA 74,72
14A8:  DATA 65,20
14AA:  DATA 56,65
14AC:  DATA 68,69
14AE:  DATA 63,75
14B0:  DATA 6C,65
14B2:  DATA 20,56
14B4:  DATA 69,61
14B6:  DATA 20,68
14B8:  DATA 74,74
14BA:  DATA 70,3A
14BC:  DATA 2F,2F
14BE:  DATA 6D,61
14C0:  DATA 70,73
14C2:  DATA 2E,67
14C4:  DATA 6F,6F
14C6:  DATA 67,6C
14C8:  DATA 65,2E
14CA:  DATA 63,6F
14CC:  DATA 6D,0D
14CE:  DATA 0A,00
14D0:  DATA 41,6C
14D2:  DATA 65,72
14D4:  DATA 74,65
14D6:  DATA 20,3A
14D8:  DATA 20,4C
14DA:  DATA 65,20
14DC:  DATA 53,6F
14DE:  DATA 6C,64
14E0:  DATA 65,20
14E2:  DATA 64,65
14E4:  DATA 20,56
14E6:  DATA 6F,74
14E8:  DATA 72,65
14EA:  DATA 20,50
14EC:  DATA 75,63
14EE:  DATA 65,20
14F0:  DATA 64,27
14F2:  DATA 41,6C
14F4:  DATA 61,72
14F6:  DATA 6D,65
14F8:  DATA 20,65
14FA:  DATA 73,74
14FC:  DATA 20,65
14FE:  DATA 6E,20
1500:  DATA 64,65
1502:  DATA 73,73
1504:  DATA 6F,75
1506:  DATA 73,20
1508:  DATA 64,75
150A:  DATA 20,53
150C:  DATA 6F,6C
150E:  DATA 64,65
1510:  DATA 20,4D
1512:  DATA 69,6E
1514:  DATA 69,6D
1516:  DATA 75,6D
1518:  DATA 20,3A
151A:  DATA 00,00
151C:  DATA 50,61
151E:  DATA 73,20
1520:  DATA 44,27
1522:  DATA 61,6C
1524:  DATA 65,72
1526:  DATA 74,65
1528:  DATA 20,3A
152A:  DATA 56,65
152C:  DATA 68,69
152E:  DATA 63,75
1530:  DATA 6C,65
1532:  DATA 20,E0
1534:  DATA 20,6C
1536:  DATA 61,20
1538:  DATA 50,6F
153A:  DATA 73,69
153C:  DATA 74,69
153E:  DATA 6F,6E
1540:  DATA 20,3A
1542:  DATA 0D,0A
1544:  DATA 00,00
1546:  DATA 50,6F
1548:  DATA 73,3D
154A:  DATA 25,73
154C:  DATA 20,25
154E:  DATA 73,0D
1550:  DATA 0A,00
1552:  DATA 56,6F
1554:  DATA 75,73
1556:  DATA 20,50
1558:  DATA 6F,75
155A:  DATA 76,65
155C:  DATA 7A,20
155E:  DATA 4C,6F
1560:  DATA 63,61
1562:  DATA 6C,69
1564:  DATA 73,65
1566:  DATA 72,20
1568:  DATA 56,6F
156A:  DATA 74,72
156C:  DATA 65,20
156E:  DATA 56,65
1570:  DATA 68,69
1572:  DATA 63,75
1574:  DATA 6C,65
1576:  DATA 20,56
1578:  DATA 69,61
157A:  DATA 20,68
157C:  DATA 74,74
157E:  DATA 70,3A
1580:  DATA 2F,2F
1582:  DATA 6D,61
1584:  DATA 70,73
1586:  DATA 2E,67
1588:  DATA 6F,6F
158A:  DATA 67,6C
158C:  DATA 65,2E
158E:  DATA 63,6F
1590:  DATA 6D,0D
1592:  DATA 0A,00
1594:  DATA 42,49
1596:  DATA 50,20
1598:  DATA 61,75
159A:  DATA 20,4E
159C:  DATA B0,3D
159E:  DATA 25,73
15A0:  DATA 0D,0A
15A2:  DATA 00,00
15A4:  DATA 20,6C
15A6:  DATA 65,20
15A8:  DATA 4E,B0
15AA:  DATA 3D,25
15AC:  DATA 73,20
15AE:  DATA 65,73
15B0:  DATA 74,20
15B2:  DATA 68,6F
15B4:  DATA 72,73
15B6:  DATA 20,63
15B8:  DATA 68,61
15BA:  DATA 6D,70
15BC:  DATA 0D,0A
15BE:  DATA 00,00
15C0:  DATA 45,4D
15C2:  DATA 4E,54
15C4:  DATA 20,47
15C6:  DATA 50,53
15C8:  DATA 20,73
15CA:  DATA 79,73
15CC:  DATA 74,65
15CE:  DATA 6D,0D
15D0:  DATA 0A,00
15D2:  DATA 57,68
15D4:  DATA 69,6C
15D6:  DATA 65,0D
15D8:  DATA 0A,00
15DA:  DATA 41,52
15DC:  DATA 4D,3D
15DE:  DATA 31,0D
15E0:  DATA 0A,00
15E2:  DATA 41,52
15E4:  DATA 4D,3D
15E6:  DATA 30,0D
15E8:  DATA 0A,00
15EA:  DATA 2D,61
15EC:  DATA 6C,30
15EE:  DATA 3D,25
15F0:  DATA 64,0D
15F2:  DATA 0A,00
15F4:  DATA 41,6C
15F6:  DATA 61,72
15F8:  DATA 6D,65
15FA:  DATA 20,6D
15FC:  DATA 65,73
15FE:  DATA 73,61
1600:  DATA 67,65
1602:  DATA 20,0D
1604:  DATA 0A,00
1606:  DATA 4E,65
1608:  DATA 77,20
160A:  DATA 53,6F
160C:  DATA 6C,64
160E:  DATA 0A,0D
1610:  DATA 00,00
1612:  DATA 41,54
1614:  DATA 2B,43
1616:  DATA 4D,47
1618:  DATA 53,3D
161A:  DATA 22,00
161C:  DATA 77,61
161E:  DATA 69,74
1620:  DATA 20,6F
1622:  DATA 6B,0A
1624:  DATA 0D,00
1626:  DATA 77,61
1628:  DATA 69,74
162A:  DATA 20,6E
162C:  DATA 6F,0A
162E:  DATA 0D,00
1630:  DATA 41,54
1632:  DATA 2B,43
1634:  DATA 4D,47
1636:  DATA 52,3D
1638:  DATA 31,0D
163A:  DATA 0A,00
163C:  DATA 4E,65
163E:  DATA 77,20
1640:  DATA 53,6D
1642:  DATA 73,0A
1644:  DATA 0D,00
1646:  DATA 53,4D
1648:  DATA 53,20
164A:  DATA 54,65
164C:  DATA 6C,20
164E:  DATA 4E,3D
1650:  DATA 25,73
1652:  DATA 0A,0D
1654:  DATA 00,00
1656:  DATA 53,4D
1658:  DATA 53,20
165A:  DATA 6D,73
165C:  DATA 67,3D
165E:  DATA 25,73
1660:  DATA 0A,0D
1662:  DATA 00,00
1664:  DATA 47,6F
1666:  DATA 6F,64
1668:  DATA 20,70
166A:  DATA 61,73
166C:  DATA 73,20
166E:  DATA 77,6F
1670:  DATA 72,64
1672:  DATA 0D,0A
1674:  DATA 00,00
1676:  DATA 41,72
1678:  DATA 72,65
167A:  DATA 74,20
167C:  DATA 64,65
167E:  DATA 20,6D
1680:  DATA 6F,74
1682:  DATA 65,75
1684:  DATA 72,20
1686:  DATA 61,76
1688:  DATA 65,63
168A:  DATA 20,6C
168C:  DATA 69,6D
168E:  DATA 69,74
1690:  DATA 61,74
1692:  DATA 69,6F
1694:  DATA 6E,20
1696:  DATA 64,65
1698:  DATA 20,76
169A:  DATA 69,74
169C:  DATA 65,73
169E:  DATA 73,65
16A0:  DATA 0D,0A
16A2:  DATA 00,00
16A4:  DATA 73,70
16A6:  DATA 65,65
16A8:  DATA 64,3D
16AA:  DATA 25,73
16AC:  DATA 0D,0A
16AE:  DATA 00,00
16B0:  DATA 41,72
16B2:  DATA 72,65
16B4:  DATA 74,20
16B6:  DATA 64,65
16B8:  DATA 20,6D
16BA:  DATA 6F,74
16BC:  DATA 65,75
16BE:  DATA 72,20
16C0:  DATA 73,61
16C2:  DATA 6E,73
16C4:  DATA 20,6C
16C6:  DATA 69,6D
16C8:  DATA 69,74
16CA:  DATA 61,74
16CC:  DATA 69,6F
16CE:  DATA 6E,20
16D0:  DATA 64,65
16D2:  DATA 20,76
16D4:  DATA 69,74
16D6:  DATA 65,73
16D8:  DATA 73,65
16DA:  DATA 0D,0A
16DC:  DATA 00,00
16DE:  DATA 43,68
16E0:  DATA 61,6E
16E2:  DATA 67,65
16E4:  DATA 72,20
16E6:  DATA 6C,65
16E8:  DATA 20,6D
16EA:  DATA 6F,74
16EC:  DATA 64,65
16EE:  DATA 20,70
16F0:  DATA 61,73
16F2:  DATA 73,0D
16F4:  DATA 0A,00
16F6:  DATA 4D,61
16F8:  DATA 72,63
16FA:  DATA 68,65
16FC:  DATA 20,64
16FE:  DATA 65,20
1700:  DATA 6D,6F
1702:  DATA 74,65
1704:  DATA 75,72
1706:  DATA 0D,0A
1708:  DATA 00,00
170A:  DATA 53,6F
170C:  DATA 6C,64
170E:  DATA 20,64
1710:  DATA 65,20
1712:  DATA 70,75
1714:  DATA 63,65
1716:  DATA 0D,0A
1718:  DATA 00,00
171A:  DATA 6D,65
171C:  DATA 73,5F
171E:  DATA 73,6F
1720:  DATA 6C,64
1722:  DATA 3D,25
1724:  DATA 73,0D
1726:  DATA 0A,00
1728:  DATA 41,54
172A:  DATA 44,25
172C:  DATA 73,3B
172E:  DATA 0D,0A
1730:  DATA 00,00
1732:  DATA 41,54
1734:  DATA 2B,43
1736:  DATA 4D,47
1738:  DATA 44,3D
173A:  DATA 31,0D
173C:  DATA 0A,00
173E:  DATA 41,54
1740:  DATA 48,0D
1742:  DATA 0A,00
1744:  DATA 54,45
1746:  DATA 4C,20
1748:  DATA 4E,3D
174A:  DATA 25,73
174C:  DATA 0D,0A
174E:  DATA 00,00
*
17CE:  MOVF   FEF,F
17D0:  BZ    17F0
17D2:  MOVFF  FEA,3AA
17D6:  MOVFF  FE9,3A9
17DA:  MOVFF  FEF,3AB
17DE:  RCALL  177A
17E0:  MOVFF  3AA,FEA
17E4:  MOVFF  3A9,FE9
17E8:  INCF   FE9,F
17EA:  BTFSC  FD8.2
17EC:  INCF   FEA,F
17EE:  BRA    17CE
17F0:  RETURN 0
17F2:  MOVLB  3
17F4:  BTFSC  xAA.7
17F6:  BRA    181A
17F8:  MOVLW  0F
17FA:  MOVWF  00
17FC:  SWAPF  xA9,W
17FE:  ANDWF  00,F
1800:  MOVLW  0A
1802:  SUBWF  00,W
1804:  BC    180C
1806:  MOVLW  30
1808:  ADDWF  00,F
180A:  BRA    1810
180C:  MOVF   xAA,W
180E:  ADDWF  00,F
1810:  MOVFF  00,3AB
1814:  MOVLB  0
1816:  RCALL  177A
1818:  MOVLB  3
181A:  MOVLW  0F
181C:  ANDWF  xA9,F
181E:  MOVLW  0A
1820:  SUBWF  xA9,W
1822:  BC    1828
1824:  MOVLW  30
1826:  BRA    182C
1828:  BCF    xAA.7
182A:  MOVF   xAA,W
182C:  ADDWF  xA9,F
182E:  MOVFF  3A9,3AB
1832:  MOVLB  0
1834:  RCALL  177A
1836:  RETURN 0
*
1A4E:  TBLRD*+
1A50:  MOVF   FF5,F
1A52:  BZ    1A6E
1A54:  MOVFF  FF6,37A
1A58:  MOVFF  FF7,37B
1A5C:  MOVF   FF5,W
1A5E:  BTFSS  F9E.4
1A60:  BRA    1A5E
1A62:  MOVWF  FAD
1A64:  MOVFF  37A,FF6
1A68:  MOVFF  37B,FF7
1A6C:  BRA    1A4E
1A6E:  RETURN 0
*
1B8A:  TBLRD*+
1B8C:  MOVFF  FF6,388
1B90:  MOVFF  FF7,389
1B94:  MOVF   FF5,W
1B96:  BTFSS  F9E.4
1B98:  BRA    1B96
1B9A:  MOVWF  FAD
1B9C:  MOVFF  388,FF6
1BA0:  MOVFF  389,FF7
1BA4:  MOVLB  3
1BA6:  DECFSZ x87,F
1BA8:  BRA    1BAC
1BAA:  BRA    1BB0
1BAC:  MOVLB  0
1BAE:  BRA    1B8A
1BB0:  MOVLB  0
1BB2:  RETURN 0
1BB4:  MOVLB  3
1BB6:  MOVF   x8B,W
1BB8:  CLRF   01
1BBA:  SUBWF  x8A,W
1BBC:  BC    1BC4
1BBE:  MOVFF  38A,00
1BC2:  BRA    1BDC
1BC4:  CLRF   00
1BC6:  MOVLW  08
1BC8:  MOVWF  x8C
1BCA:  RLCF   x8A,F
1BCC:  RLCF   00,F
1BCE:  MOVF   x8B,W
1BD0:  SUBWF  00,W
1BD2:  BTFSC  FD8.0
1BD4:  MOVWF  00
1BD6:  RLCF   01,F
1BD8:  DECFSZ x8C,F
1BDA:  BRA    1BCA
1BDC:  MOVLB  0
1BDE:  RETURN 0
1BE0:  MOVLW  20
1BE2:  MOVLB  3
1BE4:  BTFSS  x85.4
1BE6:  MOVLW  30
1BE8:  MOVWF  x86
1BEA:  MOVFF  384,00
1BEE:  BTFSS  x84.7
1BF0:  BRA    1C02
1BF2:  COMF   00,F
1BF4:  INCF   00,F
1BF6:  MOVFF  00,384
1BFA:  MOVLW  2D
1BFC:  MOVWF  x86
1BFE:  BSF    x85.7
1C00:  BSF    x85.0
1C02:  MOVF   01,W
1C04:  MOVFF  384,38A
1C08:  MOVLW  64
1C0A:  MOVWF  x8B
1C0C:  MOVLB  0
1C0E:  RCALL  1BB4
1C10:  MOVFF  00,384
1C14:  MOVLW  30
1C16:  ADDWF  01,W
1C18:  MOVLB  3
1C1A:  MOVWF  x87
1C1C:  MOVFF  384,38A
1C20:  MOVLW  0A
1C22:  MOVWF  x8B
1C24:  MOVLB  0
1C26:  RCALL  1BB4
1C28:  MOVLW  30
1C2A:  ADDWF  00,W
1C2C:  MOVLB  3
1C2E:  MOVWF  x89
1C30:  MOVLW  30
1C32:  ADDWF  01,W
1C34:  MOVWF  x88
1C36:  MOVFF  386,00
1C3A:  MOVLW  30
1C3C:  SUBWF  x87,W
1C3E:  BZ    1C48
1C40:  BSF    x85.1
1C42:  BTFSC  x85.7
1C44:  BSF    x85.2
1C46:  BRA    1C6C
1C48:  MOVFF  386,387
1C4C:  MOVLW  20
1C4E:  MOVWF  x86
1C50:  MOVLW  30
1C52:  SUBWF  x88,W
1C54:  BZ    1C5E
1C56:  BSF    x85.0
1C58:  BTFSC  x85.7
1C5A:  BSF    x85.1
1C5C:  BRA    1C6C
1C5E:  BTFSS  FD8.2
1C60:  BSF    x85.0
1C62:  BNZ   1C6C
1C64:  MOVFF  387,388
1C68:  MOVLW  20
1C6A:  MOVWF  x87
1C6C:  BTFSC  x85.2
1C6E:  BRA    1C7A
1C70:  BTFSC  x85.1
1C72:  BRA    1C82
1C74:  BTFSC  x85.0
1C76:  BRA    1C8A
1C78:  BRA    1C92
1C7A:  MOVF   x86,W
1C7C:  BTFSS  F9E.4
1C7E:  BRA    1C7C
1C80:  MOVWF  FAD
1C82:  MOVF   x87,W
1C84:  BTFSS  F9E.4
1C86:  BRA    1C84
1C88:  MOVWF  FAD
1C8A:  MOVF   x88,W
1C8C:  BTFSS  F9E.4
1C8E:  BRA    1C8C
1C90:  MOVWF  FAD
1C92:  MOVF   x89,W
1C94:  BTFSS  F9E.4
1C96:  BRA    1C94
1C98:  MOVWF  FAD
1C9A:  MOVLB  0
1C9C:  GOTO   1D2E (RETURN)
*
20AE:  MOVF   FEF,F
20B0:  BZ    20DE
20B2:  MOVFF  FEA,393
20B6:  MOVFF  FE9,392
20BA:  CLRF   16
20BC:  BTFSC  FF2.7
20BE:  BSF    16.7
20C0:  BCF    FF2.7
20C2:  MOVFF  FEF,3AE
20C6:  CALL   0FDA
20CA:  BTFSC  16.7
20CC:  BSF    FF2.7
20CE:  MOVFF  393,FEA
20D2:  MOVFF  392,FE9
20D6:  INCF   FE9,F
20D8:  BTFSC  FD8.2
20DA:  INCF   FEA,F
20DC:  BRA    20AE
20DE:  RETURN 0
*
21D4:  TBLRD*+
21D6:  MOVFF  FF6,388
21DA:  MOVFF  FF7,389
21DE:  CLRF   16
21E0:  BTFSC  FF2.7
21E2:  BSF    16.7
21E4:  BCF    FF2.7
21E6:  MOVFF  FF5,3AE
21EA:  CALL   0FDA
21EE:  BTFSC  16.7
21F0:  BSF    FF2.7
21F2:  MOVFF  388,FF6
21F6:  MOVFF  389,FF7
21FA:  MOVLB  3
21FC:  DECFSZ x87,F
21FE:  BRA    2202
2200:  BRA    2206
2202:  MOVLB  0
2204:  BRA    21D4
2206:  MOVLB  0
2208:  RETURN 0
220A:  MOVLW  20
220C:  MOVLB  3
220E:  BTFSS  x79.4
2210:  MOVLW  30
2212:  MOVWF  x7A
2214:  MOVFF  378,00
2218:  BTFSS  x78.7
221A:  BRA    222C
221C:  COMF   00,F
221E:  INCF   00,F
2220:  MOVFF  00,378
2224:  MOVLW  2D
2226:  MOVWF  x7A
2228:  BSF    x79.7
222A:  BSF    x79.0
222C:  MOVF   01,W
222E:  MOVFF  378,38A
2232:  MOVLW  64
2234:  MOVWF  x8B
2236:  MOVLB  0
2238:  RCALL  1BB4
223A:  MOVFF  00,378
223E:  MOVLW  30
2240:  ADDWF  01,W
2242:  MOVLB  3
2244:  MOVWF  x7B
2246:  MOVFF  378,38A
224A:  MOVLW  0A
224C:  MOVWF  x8B
224E:  MOVLB  0
2250:  RCALL  1BB4
2252:  MOVLW  30
2254:  ADDWF  00,W
2256:  MOVLB  3
2258:  MOVWF  x7D
225A:  MOVLW  30
225C:  ADDWF  01,W
225E:  MOVWF  x7C
2260:  MOVFF  37A,00
2264:  MOVLW  30
2266:  SUBWF  x7B,W
2268:  BZ    2272
226A:  BSF    x79.1
226C:  BTFSC  x79.7
226E:  BSF    x79.2
2270:  BRA    2296
2272:  MOVFF  37A,37B
2276:  MOVLW  20
2278:  MOVWF  x7A
227A:  MOVLW  30
227C:  SUBWF  x7C,W
227E:  BZ    2288
2280:  BSF    x79.0
2282:  BTFSC  x79.7
2284:  BSF    x79.1
2286:  BRA    2296
2288:  BTFSS  FD8.2
228A:  BSF    x79.0
228C:  BNZ   2296
228E:  MOVFF  37B,37C
2292:  MOVLW  20
2294:  MOVWF  x7B
2296:  BTFSC  x79.2
2298:  BRA    22A4
229A:  BTFSC  x79.1
229C:  BRA    22BC
229E:  BTFSC  x79.0
22A0:  BRA    22D4
22A2:  BRA    22EC
22A4:  CLRF   16
22A6:  BTFSC  FF2.7
22A8:  BSF    16.7
22AA:  BCF    FF2.7
22AC:  MOVFF  37A,3AE
22B0:  MOVLB  0
22B2:  CALL   0FDA
22B6:  BTFSC  16.7
22B8:  BSF    FF2.7
22BA:  MOVLB  3
22BC:  CLRF   16
22BE:  BTFSC  FF2.7
22C0:  BSF    16.7
22C2:  BCF    FF2.7
22C4:  MOVFF  37B,3AE
22C8:  MOVLB  0
22CA:  CALL   0FDA
22CE:  BTFSC  16.7
22D0:  BSF    FF2.7
22D2:  MOVLB  3
22D4:  CLRF   16
22D6:  BTFSC  FF2.7
22D8:  BSF    16.7
22DA:  BCF    FF2.7
22DC:  MOVFF  37C,3AE
22E0:  MOVLB  0
22E2:  CALL   0FDA
22E6:  BTFSC  16.7
22E8:  BSF    FF2.7
22EA:  MOVLB  3
22EC:  CLRF   16
22EE:  BTFSC  FF2.7
22F0:  BSF    16.7
22F2:  BCF    FF2.7
22F4:  MOVFF  37D,3AE
22F8:  MOVLB  0
22FA:  CALL   0FDA
22FE:  BTFSC  16.7
2300:  BSF    FF2.7
2302:  GOTO   442E (RETURN)
*
236C:  MOVF   FEF,F
236E:  BZ    2390
2370:  MOVFF  FEA,388
2374:  MOVFF  FE9,387
2378:  MOVF   FEF,W
237A:  BTFSS  F9E.4
237C:  BRA    237A
237E:  MOVWF  FAD
2380:  MOVFF  388,FEA
2384:  MOVFF  387,FE9
2388:  INCF   FE9,F
238A:  BTFSC  FD8.2
238C:  INCF   FEA,F
238E:  BRA    236C
2390:  RETURN 0
*
2728:  MOVLB  3
272A:  MOVF   x96,W
272C:  MULWF  x98
272E:  MOVFF  FF3,01
2732:  MOVFF  FF4,00
2736:  MULWF  x99
2738:  MOVF   FF3,W
273A:  ADDWF  00,F
273C:  MOVF   x97,W
273E:  MULWF  x98
2740:  MOVF   FF3,W
2742:  ADDWFC 00,W
2744:  MOVWF  02
2746:  MOVLB  0
2748:  RETURN 0
274A:  CLRF   01
274C:  CLRF   02
274E:  CLRF   00
2750:  CLRF   03
2752:  MOVLB  3
2754:  MOVF   x97,W
2756:  BNZ   275C
2758:  MOVF   x96,W
275A:  BZ    278C
275C:  MOVLW  10
275E:  MOVWF  x98
2760:  BCF    FD8.0
2762:  RLCF   x94,F
2764:  RLCF   x95,F
2766:  RLCF   00,F
2768:  RLCF   03,F
276A:  MOVF   x97,W
276C:  SUBWF  03,W
276E:  BNZ   2774
2770:  MOVF   x96,W
2772:  SUBWF  00,W
2774:  BNC   2784
2776:  MOVF   x96,W
2778:  SUBWF  00,F
277A:  BTFSS  FD8.0
277C:  DECF   03,F
277E:  MOVF   x97,W
2780:  SUBWF  03,F
2782:  BSF    FD8.0
2784:  RLCF   01,F
2786:  RLCF   02,F
2788:  DECFSZ x98,F
278A:  BRA    2760
278C:  MOVLB  0
278E:  RETURN 0
*
31F0:  MOVFF  FEA,382
31F4:  MOVFF  FE9,381
31F8:  MOVLB  3
31FA:  BTFSS  x7B.7
31FC:  BRA    320E
31FE:  BSF    x81.7
3200:  BTFSS  x81.4
3202:  INCF   x81,F
3204:  COMF   x7A,F
3206:  COMF   x7B,F
3208:  INCF   x7A,F
320A:  BTFSC  FD8.2
320C:  INCF   x7B,F
320E:  SWAPF  x7B,W
3210:  IORLW  F0
3212:  MOVWF  x7D
3214:  ADDWF  x7D,F
3216:  ADDLW  E2
3218:  MOVWF  x7E
321A:  ADDLW  32
321C:  MOVWF  x80
321E:  MOVF   x7B,W
3220:  ANDLW  0F
3222:  ADDWF  x7E,F
3224:  ADDWF  x7E,F
3226:  ADDWF  x80,F
3228:  ADDLW  E9
322A:  MOVWF  x7F
322C:  ADDWF  x7F,F
322E:  ADDWF  x7F,F
3230:  SWAPF  x7A,W
3232:  ANDLW  0F
3234:  ADDWF  x7F,F
3236:  ADDWF  x80,F
3238:  RLCF   x7F,F
323A:  RLCF   x80,F
323C:  COMF   x80,F
323E:  RLCF   x80,F
3240:  MOVF   x7A,W
3242:  ANDLW  0F
3244:  ADDWF  x80,F
3246:  RLCF   x7D,F
3248:  MOVLW  07
324A:  MOVWF  x7C
324C:  MOVLW  0A
324E:  DECF   x7F,F
3250:  ADDWF  x80,F
3252:  BNC   324E
3254:  DECF   x7E,F
3256:  ADDWF  x7F,F
3258:  BNC   3254
325A:  DECF   x7D,F
325C:  ADDWF  x7E,F
325E:  BNC   325A
3260:  DECF   x7C,F
3262:  ADDWF  x7D,F
3264:  BNC   3260
3266:  MOVLW  03
3268:  MOVWF  FEA
326A:  MOVLW  7C
326C:  MOVWF  FE9
326E:  MOVLW  07
3270:  ANDWF  x81,W
3272:  BCF    x81.6
3274:  DECF   FE9,F
3276:  ANDWF  x81,W
3278:  BNZ   3288
327A:  BTFSC  x81.4
327C:  INCF   FE9,F
327E:  BTFSC  x81.4
3280:  BRA    3288
3282:  MOVLW  20
3284:  MOVWF  00
3286:  BRA    32C0
3288:  ADDWF  FE9,F
328A:  MOVLW  80
328C:  SUBWF  FE9,W
328E:  BTFSC  FD8.2
3290:  BSF    x81.6
3292:  MOVF   FEF,W
3294:  MOVWF  00
3296:  BNZ   32A8
3298:  BTFSC  x81.6
329A:  BRA    32A8
329C:  BTFSC  x81.4
329E:  BRA    32E8
32A0:  BTFSC  x81.3
32A2:  BRA    32A8
32A4:  MOVLW  20
32A6:  BRA    32BE
32A8:  BTFSS  x81.7
32AA:  BRA    32B8
32AC:  MOVLW  2D
32AE:  MOVWF  00
32B0:  MOVF   FED,W
32B2:  BCF    x81.6
32B4:  BCF    x81.7
32B6:  BRA    32C0
32B8:  BSF    x81.3
32BA:  BCF    x81.4
32BC:  MOVLW  30
32BE:  ADDWF  00,F
32C0:  MOVFF  FEA,37B
32C4:  MOVFF  FE9,37A
32C8:  CLRF   16
32CA:  BTFSC  FF2.7
32CC:  BSF    16.7
32CE:  BCF    FF2.7
32D0:  MOVFF  00,3AE
32D4:  MOVLB  0
32D6:  CALL   0FDA
32DA:  BTFSC  16.7
32DC:  BSF    FF2.7
32DE:  MOVFF  37B,FEA
32E2:  MOVFF  37A,FE9
32E6:  MOVLB  3
32E8:  MOVF   FEE,W
32EA:  BTFSS  x81.6
32EC:  BRA    328A
32EE:  MOVLB  0
32F0:  GOTO   3440 (RETURN)
*
4C82:  MOVFF  FF2,0D
4C86:  BCF    FF2.7
4C88:  ADDWF  FE8,W
4C8A:  CLRF   FF7
4C8C:  RLCF   FF7,F
4C8E:  ADDLW  A7
4C90:  MOVWF  FF6
4C92:  MOVLW  4C
4C94:  ADDWFC FF7,F
4C96:  TBLRD*-
4C98:  MOVF   FF5,W
4C9A:  MOVWF  FFA
4C9C:  TBLRD*
4C9E:  MOVF   FF5,W
4CA0:  BTFSC  0D.7
4CA2:  BSF    FF2.7
4CA4:  MOVWF  FF9
4CA6:  DATA 54,3D
4CA8:  DATA EA,3D
4CAA:  DATA C6,3F
4CAC:  DATA 56,43
4CAE:  DATA 56,3E
4CB0:  DATA 08,40
4CB2:  DATA 2A,40
4CB4:  DATA 72,40
4CB6:  DATA 2C,42
4CB8:  DATA 9A,41
4CBA:  DATA D2,40
4CBC:  DATA 5C,42
4CBE:  DATA 36,41
4CC0:  DATA 4E,40
4CC2:  DATA 56,43
4CC4:  DATA 56,43
4CC6:  DATA 56,43
4CC8:  DATA 56,43
4CCA:  DATA 56,43
4CCC:  DATA 5C,3E
4CCE:  DATA B2,3E
4CD0:  DATA 0E,3F
4CD2:  DATA 6A,3F
4CD4:  DATA EC,42
4CD6:  DATA 28,43
....................  
.................... #list 
....................  
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV1,VREGEN,NOMCLR 
.................... #use delay(clock=48000000) 
*
1750:  MOVLW  03
1752:  MOVWF  FEA
1754:  MOVLW  8C
1756:  MOVWF  FE9
1758:  MOVF   FEF,W
175A:  BZ    1778
175C:  MOVLW  0F
175E:  MOVWF  01
1760:  CLRF   00
1762:  DECFSZ 00,F
1764:  BRA    1762
1766:  DECFSZ 01,F
1768:  BRA    1760
176A:  MOVLW  8F
176C:  MOVWF  00
176E:  DECFSZ 00,F
1770:  BRA    176E
1772:  NOP   
1774:  DECFSZ FEF,F
1776:  BRA    175C
1778:  RETURN 0
.................... //#define GPSTEST 
.................... #define ALARME 
.................... #define GPS0 
.................... #define DEBUG0 
.................... #define TLE_OLD 
.................... #ifdef ALARME 
.................... #USE RS232(BAUD=9600, XMIT=PIN_B0,INVERT,stream=DEBUG) 
*
0FDA:  BCF    F93.0
0FDC:  BSF    F8A.0
0FDE:  MOVLW  08
0FE0:  MOVWF  01
0FE2:  BRA    0FE4
0FE4:  NOP   
0FE6:  BSF    01.7
0FE8:  BRA    100A
0FEA:  BCF    01.7
0FEC:  MOVLB  3
0FEE:  RRCF   xAE,F
0FF0:  MOVLB  0
0FF2:  BTFSC  FD8.0
0FF4:  BCF    F8A.0
0FF6:  BTFSS  FD8.0
0FF8:  BSF    F8A.0
0FFA:  BSF    01.6
0FFC:  BRA    100A
0FFE:  BCF    01.6
1000:  DECFSZ 01,F
1002:  BRA    0FEC
1004:  BRA    1006
1006:  NOP   
1008:  BCF    F8A.0
100A:  MOVLW  01
100C:  MOVWF  00
100E:  CLRF   FE9
1010:  DECFSZ FE9,F
1012:  BRA    1010
1014:  DECFSZ 00,F
1016:  BRA    100E
1018:  MOVLW  99
101A:  MOVWF  FE9
101C:  DECFSZ FE9,F
101E:  BRA    101C
1020:  NOP   
1022:  BTFSC  01.7
1024:  BRA    0FEA
1026:  BTFSC  01.6
1028:  BRA    0FFE
102A:  RETURN 0
.................... #else 
.................... #USE RS232(BAUD=9600, XMIT=PIN_B4,INVERT,stream=DEBUG) 
.................... #endif 
.................... #include ".\include\alarme0.h" 
.................... BYTE  out,alarme_flag,alarme_flag1; 
.................... #ifdef ALARME 
.................... #define OUT_ENABLE  PIN_A5 
.................... #define OUT_CLOCK   PIN_B2 
.................... #define OUT_DO      PIN_B3 
.................... #bit LED=out.0 
.................... #bit VR_D=out.1 
.................... #bit VR_G=out.2 
.................... #bit LMR=out.3 
.................... #bit SRN=out.4 
.................... #bit RL_ARR=out.5 
.................... #bit PWR=out.6 
.................... #bit ALARM=alarme_flag.0 
.................... #bit TELE_LK_OLD=alarme_flag.1 
.................... #bit TELE_SN_OLD=alarme_flag.2 
.................... #bit TELE_N_LK_OLD=alarme_flag.3 
.................... #bit TELE_N_SN_OLD=alarme_flag.4 
.................... #bit ARM=alarme_flag.5 
.................... #bit SRN_EN=alarme_flag.6 
.................... #else 
....................    #define PWR PIN_C2 
....................    #define LED PIN_B5 
....................    #define RL_ARR PIN_A1 
.................... #endif 
.................... #bit msg_ok=alarme_flag.7 
.................... #bit arret_flag=alarme_flag1.0 
....................  
.................... #define  porte  PIN_C2 
.................... #define  choc   PIN_C0 
.................... #define  capot  PIN_C1 
.................... #define  reset  PIN_E3 
....................  
.................... #define TELE_LK   PIN_B7 
.................... #define TELE_SN   PIN_B6 
.................... #define TELE_N_SN   PIN_B5 
.................... #define TELE_N_LK   PIN_B4 
....................  
.................... #ifdef ALARME 
.................... void write_alarm_outputs(BYTE data)  
.................... { 
....................   BYTE i; 
....................  
....................   output_low(OUT_CLOCK); 
*
1950:  BCF    F93.2
1952:  BCF    F8A.2
....................   output_low(OUT_ENABLE); 
1954:  BCF    F92.5
1956:  BCF    F89.5
....................  
....................   for(i=0;i<8;i++)  
1958:  MOVLB  3
195A:  CLRF   x7B
195C:  MOVF   x7B,W
195E:  SUBLW  07
1960:  BNC   19BE
....................   {   
....................       if(bit_test(data,7-i)) output_high(OUT_DO); 
1962:  MOVLW  07
1964:  BSF    FD8.0
1966:  SUBFWB x7B,W
1968:  MOVWF  x7C
196A:  MOVFF  37A,00
196E:  MOVF   x7C,W
1970:  MOVWF  01
1972:  BZ    197C
1974:  BCF    FD8.0
1976:  RRCF   00,F
1978:  DECFSZ 01,F
197A:  BRA    1974
197C:  BTFSS  00.0
197E:  BRA    1986
1980:  BCF    F93.3
1982:  BSF    F8A.3
1984:  BRA    198A
....................       else output_low(OUT_DO); 
1986:  BCF    F93.3
1988:  BCF    F8A.3
....................       delay_ms(1); 
198A:  MOVLW  01
198C:  MOVWF  x8C
198E:  MOVLB  0
1990:  RCALL  1750
....................       shift_left(data,1,0); 
1992:  CLRF   FEA
1994:  MOVFF  37A,FE9
1998:  BCF    FD8.0
199A:  RLCF   FEF,F
....................       output_high(OUT_CLOCK); 
199C:  BCF    F93.2
199E:  BSF    F8A.2
....................       delay_ms(1); 
19A0:  MOVLW  01
19A2:  MOVLB  3
19A4:  MOVWF  x8C
19A6:  MOVLB  0
19A8:  RCALL  1750
....................       output_low(OUT_CLOCK); 
19AA:  BCF    F93.2
19AC:  BCF    F8A.2
....................       delay_ms(1); 
19AE:  MOVLW  01
19B0:  MOVLB  3
19B2:  MOVWF  x8C
19B4:  MOVLB  0
19B6:  RCALL  1750
19B8:  MOVLB  3
19BA:  INCF   x7B,F
19BC:  BRA    195C
....................   } 
....................   output_high(OUT_ENABLE); 
19BE:  BCF    F92.5
19C0:  BSF    F89.5
....................   delay_ms(1); 
19C2:  MOVLW  01
19C4:  MOVWF  x8C
19C6:  MOVLB  0
19C8:  RCALL  1750
....................   output_low(OUT_ENABLE); 
19CA:  BCF    F92.5
19CC:  BCF    F89.5
19CE:  RETURN 0
....................  
.................... } 
....................  
.................... int read_alarm_input() 
.................... { 
....................    if(!input(porte)) return(1);  
*
21A8:  BSF    F94.2
21AA:  BTFSC  F82.2
21AC:  BRA    21B4
21AE:  MOVLW  01
21B0:  MOVWF  01
21B2:  BRA    21D0
....................    if(!input(choc))  return(3);  
21B4:  BSF    F94.0
21B6:  BTFSC  F82.0
21B8:  BRA    21C0
21BA:  MOVLW  03
21BC:  MOVWF  01
21BE:  BRA    21D0
....................    if(!input(capot)) return(2);  
21C0:  BSF    F94.1
21C2:  BTFSC  F82.1
21C4:  BRA    21CC
21C6:  MOVLW  02
21C8:  MOVWF  01
21CA:  BRA    21D0
....................    //if(!input(reset)) return(4);  
....................    return(0); 
21CC:  MOVLW  00
21CE:  MOVWF  01
21D0:  GOTO   43F0 (RETURN)
....................     
.................... } 
....................  
.................... //*****************************************************************************/ 
.................... void ARM_action() 
.................... { 
....................    //fprintf(DEBUG,"ARM\n\r"); 
....................    LMR=1; 
*
20E0:  BSF    17.3
....................    SRN=1; 
20E2:  BSF    17.4
....................    VR_D=0; 
20E4:  BCF    17.1
....................    VR_G=1; 
20E6:  BSF    17.2
....................    write_alarm_outputs(out); 
20E8:  MOVFF  17,37A
20EC:  RCALL  1950
....................    delay_ms(200); 
20EE:  MOVLW  C8
20F0:  MOVLB  3
20F2:  MOVWF  x8C
20F4:  MOVLB  0
20F6:  CALL   1750
....................    LMR=0; 
20FA:  BCF    17.3
....................    SRN=0; 
20FC:  BCF    17.4
....................    write_alarm_outputs(out); 
20FE:  MOVFF  17,37A
2102:  RCALL  1950
....................    delay_ms(800); 
2104:  MOVLW  04
2106:  MOVLB  3
2108:  MOVWF  x78
210A:  MOVLW  C8
210C:  MOVWF  x8C
210E:  MOVLB  0
2110:  CALL   1750
2114:  MOVLB  3
2116:  DECFSZ x78,F
2118:  BRA    210A
....................    VR_D=0; 
211A:  BCF    17.1
....................    VR_G=0; 
211C:  BCF    17.2
....................    write_alarm_outputs(out); 
211E:  MOVFF  17,37A
2122:  MOVLB  0
2124:  RCALL  1950
2126:  GOTO   4372 (RETURN)
.................... } 
....................  
.................... void D_ARM_action() 
.................... { 
....................    //fprintf(DEBUG,"DEARM\n\r"); 
....................    LMR=1; 
212A:  BSF    17.3
....................    SRN=1; 
212C:  BSF    17.4
....................    VR_G=0; 
212E:  BCF    17.2
....................    VR_D=1; 
2130:  BSF    17.1
....................    LED=0; 
2132:  BCF    17.0
....................    write_alarm_outputs(out); 
2134:  MOVFF  17,37A
2138:  RCALL  1950
....................    delay_ms(200); 
213A:  MOVLW  C8
213C:  MOVLB  3
213E:  MOVWF  x8C
2140:  MOVLB  0
2142:  CALL   1750
....................    LMR=0; 
2146:  BCF    17.3
....................    SRN=0; 
2148:  BCF    17.4
....................    write_alarm_outputs(out); 
214A:  MOVFF  17,37A
214E:  RCALL  1950
....................    delay_ms(200); 
2150:  MOVLW  C8
2152:  MOVLB  3
2154:  MOVWF  x8C
2156:  MOVLB  0
2158:  CALL   1750
....................    LMR=1; 
215C:  BSF    17.3
....................    SRN=1; 
215E:  BSF    17.4
....................    write_alarm_outputs(out); 
2160:  MOVFF  17,37A
2164:  CALL   1950
....................    delay_ms(200); 
2168:  MOVLW  C8
216A:  MOVLB  3
216C:  MOVWF  x8C
216E:  MOVLB  0
2170:  CALL   1750
....................    LMR=0; 
2174:  BCF    17.3
....................    SRN=0; 
2176:  BCF    17.4
....................    write_alarm_outputs(out); 
2178:  MOVFF  17,37A
217C:  CALL   1950
....................    delay_ms(400); 
2180:  MOVLW  02
2182:  MOVLB  3
2184:  MOVWF  x78
2186:  MOVLW  C8
2188:  MOVWF  x8C
218A:  MOVLB  0
218C:  CALL   1750
2190:  MOVLB  3
2192:  DECFSZ x78,F
2194:  BRA    2186
....................    VR_D=0; 
2196:  BCF    17.1
....................    VR_G=0; 
2198:  BCF    17.2
....................    write_alarm_outputs(out); 
219A:  MOVFF  17,37A
219E:  MOVLB  0
21A0:  CALL   1950
21A4:  GOTO   43AC (RETURN)
.................... } 
....................  
.................... void alarme_action(char msg) 
.................... { 
....................    //TCCR0=0x04; 
....................    ALARM=1; 
....................    SRN=1; 
....................    LMR=1; 
....................   /* if(msg==0) return(0); 
....................    //Modem_On(); 
....................    if(msg==-1) uart_str("ATD050488224;\n",14); 
....................    if(msg==1) uart_str("AT+CMSS=1\n",10); 
....................    if(msg==2) uart_str("AT+CMSS=2\n",10); 
....................    if(msg==3) uart_str("AT+CMSS=3\n",10); 
....................    if(msg==4) uart_str("AT+CMSS=4\n",10);*/ 
....................  
....................  
....................  
.................... } 
....................  
.................... void Alarm_off() 
.................... { 
....................    ALARM=0; 
....................    SRN=0; 
....................    LMR=0; 
....................   // TCCR0=0x05; 
....................  
.................... } 
....................  
.................... void CAR_find() 
.................... { 
....................    //fprintf(DEBUG,"DEARM\n\r"); 
....................    LMR=1; 
....................    SRN=1; 
....................    LED=0; 
....................    write_alarm_outputs(out); 
....................    delay_ms(800); 
....................    LMR=0; 
....................    SRN=0; 
....................    write_alarm_outputs(out); 
....................    delay_ms(800); 
....................    LMR=1; 
....................    SRN=1; 
....................    write_alarm_outputs(out); 
....................    delay_ms(800); 
....................    LMR=0; 
....................    SRN=0; 
....................    write_alarm_outputs(out); 
....................    delay_ms(800); 
....................    LMR=1; 
....................    SRN=1; 
....................    write_alarm_outputs(out); 
....................    delay_ms(800); 
....................    LMR=0; 
....................    SRN=0; 
....................    write_alarm_outputs(out); 
....................    delay_ms(800); 
....................    LMR=1; 
....................    SRN=1; 
....................    write_alarm_outputs(out); 
....................    delay_ms(800); 
....................    LMR=0; 
....................    SRN=0; 
....................    write_alarm_outputs(out); 
.................... } 
....................  
.................... #endif 
....................  
.................... #include ".\include\sim508.h" 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
*
2692:  MOVLB  3
2694:  MOVF   x96,F
2696:  BNZ   269C
2698:  MOVF   x97,F
269A:  BZ    2720
....................       if (*s1 != *s2) 
269C:  MOVFF  392,FE9
26A0:  MOVFF  393,FEA
26A4:  MOVFF  FEF,398
26A8:  MOVFF  395,03
26AC:  MOVFF  394,FE9
26B0:  MOVFF  395,FEA
26B4:  MOVF   FEF,W
26B6:  SUBWF  x98,W
26B8:  BZ    26E8
....................          return((*s1 <*s2) ? -1: 1); 
26BA:  MOVFF  393,03
26BE:  MOVFF  392,FE9
26C2:  MOVFF  03,FEA
26C6:  MOVFF  FEF,398
26CA:  MOVFF  395,03
26CE:  MOVFF  394,FE9
26D2:  MOVFF  395,FEA
26D6:  MOVF   FEF,W
26D8:  SUBWF  x98,W
26DA:  BC    26E0
26DC:  MOVLW  FF
26DE:  BRA    26E2
26E0:  MOVLW  01
26E2:  MOVWF  01
26E4:  BRA    2724
26E6:  BRA    26FE
....................       else if (*s1 == '\0') 
26E8:  MOVFF  393,03
26EC:  MOVFF  392,FE9
26F0:  MOVFF  393,FEA
26F4:  MOVF   FEF,F
26F6:  BNZ   26FE
....................          return(0); 
26F8:  MOVLW  00
26FA:  MOVWF  01
26FC:  BRA    2724
26FE:  MOVFF  393,03
2702:  MOVF   x92,W
2704:  INCF   x92,F
2706:  BTFSC  FD8.2
2708:  INCF   x93,F
270A:  MOVFF  395,03
270E:  MOVF   x94,W
2710:  INCF   x94,F
2712:  BTFSC  FD8.2
2714:  INCF   x95,F
2716:  MOVF   x96,W
2718:  BTFSC  FD8.2
271A:  DECF   x97,F
271C:  DECF   x96,F
271E:  BRA    2694
....................    return(0); 
2720:  MOVLW  00
2722:  MOVWF  01
2724:  MOVLB  0
2726:  RETURN 0
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <input.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                             input.c                               //// 
.................... ////                                                                   //// 
.................... //// Routines for reading user input over an RS232 stream.  User input //// 
.................... //// is in ASCII form and converted to requested binary or float       //// 
.................... //// format.                                                           //// 
.................... ////                                                                   //// 
.................... //// If STREAM_SERIAL_INPUT is defined, these routines will read from  //// 
.................... //// that serial stream.  If not, uses the last #use rs232().          //// 
.................... ////                                                                   //// 
.................... //// Some of these routines are not available unless you #include      //// 
.................... //// string.h and stdlib.h                                             //// 
.................... ////                                                                   //// 
.................... ////  int8 gethex() - read 2 char hex value from serial                //// 
.................... ////                                                                   //// 
.................... ////  get_string(s, max) - read max chars from serial and save to s    //// 
.................... ////                                                                   //// 
.................... ////  get_stringEdit(s, max) - similar to get_string(), but first it   //// 
.................... ////     displays current string in s, allowing you to edit it.        //// 
.................... ////                                                                   //// 
.................... ////  int8 = get_Int8() -                                              //// 
.................... ////  int16 = get_Int16() -                                            //// 
.................... ////  int32 = get_Int32() -                                            //// 
.................... ////  float = get_float() -                                            //// 
.................... ////     Read value from serial.                                       //// 
.................... ////                                                                   //// 
.................... ////  int8 = get_Int8Edit(old) -                                       //// 
.................... ////  int16 = get_Int16Edit(old) -                                     //// 
.................... ////  int32 = get_Int32Edit(old) -                                     //// 
.................... ////  float = get_floatEdit(old) -                                     //// 
.................... ////     Similar to get_Int*() routines documented above, but first    //// 
.................... ////     it displays old value allowing you to edit it.                //// 
.................... ////                                                                   //// 
.................... ////  int = get_int() -                                                //// 
.................... ////  long = get_long() -                                              //// 
.................... ////     Simlar to get_Int*() documented above, but return 'int' and   //// 
.................... ////     'long' datatypes.  The size of these datatypes depends on     //// 
.................... ////     the PIC architecture and compiler configuration.              //// 
.................... ////                                                                   //// 
.................... ////  int = get_intEdit(old) -                                         //// 
.................... ////  long = get_longEdit(old) -                                       //// 
.................... ////     Similar to get_int() and get_long() documented above,         //// 
.................... ////     but first it displays old value allowing you to edit it.      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __INPUT_C__ 
.................... #define __INPUT_C__ 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if defined(STREAM_SERIAL_INPUT) 
....................    #define InputKbhit()    kbhit(STREAM_SERIAL_INPUT) 
....................    #define InputPutc(c)    fputc(c, STREAM_SERIAL_INPUT) 
....................    #define InputGetc()     fgetc(STREAM_SERIAL_INPUT) 
.................... #else 
....................    #define InputKbhit()    kbhit() 
....................    #define InputPutc(c)    putc(c) 
....................    #define InputGetc()     getc() 
.................... #endif 
....................  
.................... unsigned int8 gethex1() { 
....................    char digit; 
....................  
....................    digit = InputGetc(); 
....................  
....................    InputPutc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... unsigned int8 gethex() { 
....................    unsigned int8 lo,hi; 
....................  
....................    hi = gethex1(); 
....................    lo = gethex1(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    max-=2; 
....................    len=0; 
....................    do { 
....................      c=InputGetc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           InputPutc(c); 
....................           InputPutc(' '); 
....................           InputPutc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<=max) { 
....................          s[len++]=c; 
....................          InputPutc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
.................... #ifdef _STRING 
.................... void get_stringEdit(char* s, unsigned int8 max) { 
....................    unsigned int8 len; 
....................    char c; 
....................  
....................    len = strlen(s); 
....................  
....................    if (len) 
....................    { 
....................      #if defined(STREAM_SERIAL_INPUT) 
....................       fprintf(STREAM_SERIAL_INPUT, "%s", s); 
....................      #else 
....................       printf("%s", s); 
....................      #endif 
....................    } 
....................  
....................    max-=2; 
....................  
....................    do { 
....................      c=InputGetc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           InputPutc(c); 
....................           InputPutc(' '); 
....................           InputPutc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<=max) { 
....................          s[len++]=c; 
....................          InputPutc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
.................... #endif 
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
.................... signed int8 get_Int8(void) 
.................... { 
....................   char s[5]; 
....................   signed int8 i; 
....................  
....................   get_string(s, sizeof(s)); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... signed int8 get_Int8Edit(signed int8 old) 
.................... { 
....................   char s[5]; 
....................   signed int8 i; 
....................  
....................   sprintf(s, "%d", old); 
....................   get_stringEdit(s, sizeof(s)); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
.................... #endif 
....................  
.................... signed int16 get_Int16(void) 
.................... { 
....................   char s[7]; 
....................   signed int16 l; 
....................  
....................   get_string(s, sizeof(s)); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... signed int16 get_Int16Edit(signed int16 old) 
.................... { 
....................   char s[7]; 
....................   signed int16 l; 
....................  
....................   sprintf(s, "%ld", old); 
....................  
....................   get_stringEdit(s, sizeof(s)); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... signed int32 get_Int32(void) 
.................... { 
....................   char s[12]; 
....................   signed int32 l; 
....................  
....................   get_string(s, sizeof(s)); 
....................   l=atoi32(s); 
....................   return(l); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... signed int32 get_Int32Edit(signed int32 old) 
.................... { 
....................   char s[12]; 
....................   signed int32 l; 
....................  
....................   sprintf(s, "%ld", old); 
....................  
....................   get_stringEdit(s, sizeof(s)); 
....................   l=atoi32(s); 
....................   return(l); 
.................... } 
.................... #endif 
....................  
.................... float get_float() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #ifdef _STRING 
.................... float get_floatEdit(float old) { 
....................   char s[20]; 
....................   float f; 
....................  
....................   sprintf(s, "%f", old); 
....................  
....................   get_string(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................    #define get_int()       get_Int16() 
....................    #define get_intEdit()   get_Int16Edit() 
....................    #define get_long()      get_Int32() 
....................    #define get_longEdit()  get_Int32Edit() 
.................... #else 
....................    #define get_int()       get_Int8() 
....................    #define get_intEdit()   get_Int8Edit() 
....................    #define get_long()      get_Int16() 
....................    #define get_longEdit()  get_Int16Edit() 
.................... #endif 
....................  
.................... #endif   //_STDLIB 
....................  
.................... #endif   //__INPUT_C__ 
....................  
.................... #ifdef GPS0 
....................    #ifdef ALARME 
....................    #define SIM_PKEY     PIN_A1 
....................    #else 
....................    #define SIM_PKEY     PIN_C1 
....................    #endif 
.................... #else 
....................    #ifdef   ALARME 
....................    #define SIM_PKEY     PIN_A2 
....................    #else 
....................    #define SIM_PKEY     PIN_A3 
....................    #endif 
.................... #endif 
.................... #define POWER        PIN_C2 
....................  
.................... #ifdef GPS0 
....................    #define SIM_STATUS   PIN_A0 
.................... #else 
....................    #ifdef   ALARME  
....................    #define SIM_STATUS   PIN_A1 
....................    #else 
....................    #define SIM_STATUS   PIN_C0 
....................    #endif 
.................... #endif 
....................  
.................... #ifdef GPS0 
....................    #ifdef   ALARME 
....................    #define SIM_RING     PIN_B1   // Inp 
....................    #else 
....................    #define SIM_RING     PIN_C0   // Inp 
....................    #endif 
....................    #define GPS_MRST     PIN_A4 
....................    #define GPS_RX       PIN_A3 
....................    #define GPS_TX       PIN_A2 
....................    #USE RS232(BAUD=4800, XMIT=GPS_TX, RCV=GPS_RX,stream=GPS) 
*
3694:  BSF    F92.3
3696:  BTFSC  F80.3
3698:  BRA    3696
369A:  MOVLW  08
369C:  MOVWF  00
369E:  MOVLB  3
36A0:  CLRF   x7E
36A2:  BSF    00.7
36A4:  BRA    36C2
36A6:  BCF    00.7
36A8:  BRA    36C2
36AA:  BCF    FD8.0
36AC:  BTFSC  F80.3
36AE:  BSF    FD8.0
36B0:  RRCF   x7E,F
36B2:  BSF    00.6
36B4:  BRA    36C2
36B6:  BCF    00.6
36B8:  DECFSZ 00,F
36BA:  BRA    36AA
36BC:  MOVFF  37E,01
36C0:  BRA    36EE
36C2:  MOVLW  03
36C4:  MOVWF  FE9
36C6:  MOVLW  00
36C8:  BTFSC  00.7
36CA:  MOVLW  55
36CC:  MOVWF  01
36CE:  DECFSZ 01,F
36D0:  BRA    36CE
36D2:  DECFSZ FE9,F
36D4:  BRA    36C6
36D6:  MOVLW  34
36D8:  BTFSC  00.7
36DA:  MOVLW  0E
36DC:  MOVWF  01
36DE:  DECFSZ 01,F
36E0:  BRA    36DE
36E2:  BRA    36E4
36E4:  BTFSC  00.7
36E6:  BRA    36A6
36E8:  BTFSC  00.6
36EA:  BRA    36B6
36EC:  BRA    36AA
36EE:  MOVLB  0
36F0:  RETURN 0
.................... #else 
....................    #define SIM_RING     PIN_A4   // Inp 
.................... #endif 
....................  
.................... #define GSM_RX       PIN_C7 
.................... #define GSM_TX       PIN_C6 
.................... #define SIM_RX_BUFFER_SIZE 128 
....................  
.................... #USE RS232(BAUD=9600, XMIT=GSM_TX, RCV=GSM_RX,stream=GSM) 
*
2DBE:  BTFSS  F9E.4
2DC0:  BRA    2DBE
2DC2:  MOVWF  FAD
2DC4:  RETURN 0
.................... #ifdef GPS0 
.................... #USE RS232(BAUD=4800,XMIT=GPS_TX,RCV=GPS_RX,stream=GPS_COM) 
*
177A:  BCF    F92.2
177C:  BCF    F89.2
177E:  MOVLW  08
1780:  MOVWF  01
1782:  BRA    1784
1784:  NOP   
1786:  BSF    01.7
1788:  BRA    17AA
178A:  BCF    01.7
178C:  MOVLB  3
178E:  RRCF   xAB,F
1790:  MOVLB  0
1792:  BTFSC  FD8.0
1794:  BSF    F89.2
1796:  BTFSS  FD8.0
1798:  BCF    F89.2
179A:  BSF    01.6
179C:  BRA    17AA
179E:  BCF    01.6
17A0:  DECFSZ 01,F
17A2:  BRA    178C
17A4:  BRA    17A6
17A6:  NOP   
17A8:  BSF    F89.2
17AA:  MOVLW  03
17AC:  MOVWF  00
17AE:  CLRF   FE9
17B0:  DECFSZ FE9,F
17B2:  BRA    17B0
17B4:  DECFSZ 00,F
17B6:  BRA    17AE
17B8:  MOVLW  37
17BA:  MOVWF  FE9
17BC:  DECFSZ FE9,F
17BE:  BRA    17BC
17C0:  BRA    17C2
17C2:  NOP   
17C4:  BTFSC  01.7
17C6:  BRA    178A
17C8:  BTFSC  01.6
17CA:  BRA    179E
17CC:  RETURN 0
*
2634:  BSF    F92.3
2636:  BTFSC  F80.3
2638:  BRA    2636
263A:  MOVLW  08
263C:  MOVWF  00
263E:  MOVLB  3
2640:  CLRF   x92
2642:  BSF    00.7
2644:  BRA    2662
2646:  BCF    00.7
2648:  BRA    2662
264A:  BCF    FD8.0
264C:  BTFSC  F80.3
264E:  BSF    FD8.0
2650:  RRCF   x92,F
2652:  BSF    00.6
2654:  BRA    2662
2656:  BCF    00.6
2658:  DECFSZ 00,F
265A:  BRA    264A
265C:  MOVFF  392,01
2660:  BRA    268E
2662:  MOVLW  03
2664:  MOVWF  FE9
2666:  MOVLW  00
2668:  BTFSC  00.7
266A:  MOVLW  55
266C:  MOVWF  01
266E:  DECFSZ 01,F
2670:  BRA    266E
2672:  DECFSZ FE9,F
2674:  BRA    2666
2676:  MOVLW  34
2678:  BTFSC  00.7
267A:  MOVLW  0E
267C:  MOVWF  01
267E:  DECFSZ 01,F
2680:  BRA    267E
2682:  BRA    2684
2684:  BTFSC  00.7
2686:  BRA    2646
2688:  BTFSC  00.6
268A:  BRA    2656
268C:  BRA    264A
268E:  MOVLB  0
2690:  RETURN 0
.................... #endif 
....................  
.................... BYTE SIM_rx_buffer[SIM_RX_BUFFER_SIZE]; 
.................... BYTE SIM_next_in = 0; 
.................... BYTE SIM_next_out = 0; 
.................... BYTE SerialBuffer_pos=0; 
.................... BYTE flag,flag1; 
.................... char x[15],y[15],x0[15],y0[15]; 
.................... char msg_tx=0,sms_index=0,sms_buff_l,nl0,ring_count=0; 
.................... #define SerialBuffer SIM_rx_buffer  
....................  
.................... #rom int8 0xf00000={'0','0','0','0','0','0','0','0','0','0'} // n1 
.................... #rom int8 0xf0000A={'0','0','0','0','0','0','0','0','0','0'} // n2 
.................... #rom int8 0xf00014={'0','0','0','0','0','0','0','0','0','0'} // n3 
.................... #rom int8 0xf0001e={'0','0','0','0','0','0','0','0','0','0'} // n4 
.................... #rom int8 0xf00028={4,'0','0','0','0'}  
.................... #rom int8 0xf00032={5,'*','0','0','0','#'}  
.................... #bit RING_FLG=flag.0 
.................... #bit receive_flag=flag.1 
.................... #bit end_receive=flag.2 
.................... #bit OK=flag.3 
.................... #bit sms_ok=flag.4 
.................... #bit n_ok=flag.5 
.................... #bit halt_flag=flag.6 
.................... #bit sold=flag.7 
.................... #bit sold_ask=flag1.0 
.................... #bit suit_flag=flag1.1 
.................... #bit index_ok=flag1.2 
.................... #bit sms_ok2=flag1.3 
.................... #bit pass_ok=flag1.4 
.................... #bit sms_sold_ask=flag1.5 
.................... #bit start_ok=flag1.6 
.................... #bit c_sold=flag1.7 
.................... byte GSMStat; 
.................... #bit GSMBUSY=GSMStat.0 
.................... #bit GSMOK=GSMStat.1 
.................... #bit GSMERR=GSMStat.2 
.................... #bit GSMNOC=GSMStat.3 
.................... byte speed_limit=40; 
.................... //byte speed_add=50; 
.................... //byte sms_ok=0; 
.................... int32 timer1Tick; 
.................... char head[7],temp0[64],vergule_pos[20],vergule_n,txt_test[5],pass_word[16]; 
.................... char temp[100]; 
.................... char w = 0,no_ok,speed,sold_msg[5],rep_sold=0; 
.................... int j,i0 = 0; 
.................... char buffer[64],sms_buffer0[32],sms_buffer[64]; 
.................... char index_val[4],index_val0[4],index_l=0; 
.................... char token[20];  
.................... int16 t0=0,sold_val,sold_min=100; 
.................... int32 time_count=0; 
.................... int8 tel_n[11],tel_n1[11],pos,sold_msg_l; 
.................... const char pass_add=40,sold_add=50,speed_add=70; 
.................... char speed1[5],direction0[5],date[7],time[7]; 
.................... //*************************************************************** 
.................... //    test si il ya de caractere envoyer par SIM508 
.................... //    return:  
.................... //    0 si il n'ya pas de caractere 
.................... //    1 si il ya un caractere 
.................... //*************************************************************** 
....................  
.................... #define SIM_GSM_KbHit (SIM_next_in!=SIM_next_out) 
....................  
....................  
.................... //*************************************************************** 
.................... //    Attendre l'arriv d'un caractere de modem SIM508 
.................... // 
.................... //    Return:  
.................... //      le code ascii du caractere recevie 
.................... //*************************************************************** 
....................  
.................... BYTE SIM_GSM_Getc()  
.................... { 
....................   BYTE c; 
....................  
....................   while(!SIM_GSM_KbHit) ; 
....................   c=SIM_rx_buffer[SIM_next_out]; 
....................   SIM_next_out=(SIM_next_out+1) % SIM_RX_BUFFER_SIZE; 
....................   return(c); 
.................... } 
....................  
.................... //*************************************************************** 
.................... //    envoi d'un caractere au modem SIM508 
.................... //*************************************************************** 
....................  
.................... void SIM_GSM_Putc(BYTE c)  
.................... {  
....................    #USE RS232(BAUD=9600, XMIT=GSM_TX, RCV=GSM_RX) 
....................    putc(c);  
.................... } 
....................  
.................... //*************************************************************** 
.................... // chargement de buffer de reception de modem 
.................... //*************************************************************** 
....................  
.................... void SIM_FlushRxBuffer(void)  
.................... { 
....................   while(SIM_GSM_KbHit) SIM_GSM_getc(); 
.................... } 
....................  
.................... //*************************************************************** 
.................... //       gestion des interruptions 
.................... //*************************************************************** 
....................  
.................... //*************************************************************** 
.................... // interruption de fin de reception d'un caracter au USART 
.................... //*************************************************************** 
.................... /*#int_rda  
.................... void serial_isr()  
.................... { 
....................    int t; 
....................     
....................    SIM_rx_buffer[SIM_next_in]=fgetc(COM_GSM); 
....................    t=SIM_next_in; 
....................    SIM_next_in=(SIM_next_in+1) % SIM_RX_BUFFER_SIZE; 
....................    if(SIM_next_in==SIM_next_out) 
....................    SIM_next_in=t;           // Buffer pieno !! 
.................... } 
.................... */ 
.................... //*************************************************************** 
.................... // Timer 1 
.................... //*************************************************************** 
....................  
.................... /*#int_timer1 
.................... void wave_timer()  
.................... { 
....................    set_timer1(63036); 
....................    timer1Tick--; 
.................... } 
.................... */ 
....................  
.................... //*************************************************************** 
.................... // Start Timer 
.................... //*************************************************************** 
....................  
.................... void StartTimer(int32 ms)  
.................... { 
....................    set_timer1(63036); 
....................    timer1Tick=ms; 
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1); 
....................    enable_interrupts(int_timer1); 
.................... }    
....................  
.................... //*************************************************************** 
.................... // Stop Timer 
.................... //*************************************************************** 
....................  
.................... void StopTimer(void)  
.................... { 
....................   disable_interrupts(int_timer1); 
.................... }    
....................  
.................... //*************************************************************** 
.................... // Test Timer 
.................... //*************************************************************** 
....................  
.................... int CheckTimer(void)  
.................... { 
....................   if (timer1Tick<=0)  
....................   { 
....................      StopTimer(); 
....................      return 1; 
....................   }  
....................   else 
....................   { 
....................      return 0; 
....................   } 
.................... }    
....................  
.................... //*************************************************************** 
.................... // Reception des chaines de caractere de reponse de modem 
.................... //  
.................... // to timeout en  mS 
.................... // buffer Buffer de memorisation de reponse (256 car) 
.................... // 
.................... // Return 0 si il depasse timeout ou il depasse la capacit max(256 car) 
.................... // Return 1 si il recepte la reponse OK<CR><LF> 
.................... //*************************************************************** 
....................  
.................... int SIM_WaitResponse(int32 to)  
.................... { 
....................   int32 t1; 
....................   receive_flag=0; 
*
1CA0:  BCF    x9F.1
....................   t1=0; 
1CA2:  MOVLB  3
1CA4:  CLRF   x8B
1CA6:  CLRF   x8A
1CA8:  CLRF   x89
1CAA:  CLRF   x88
....................   for (;;)  
....................   { 
....................      if(end_receive) 
1CAC:  MOVLB  0
1CAE:  BTFSS  x9F.2
1CB0:  BRA    1CC0
....................      { 
....................        if(OK) return(1); 
1CB2:  BTFSS  x9F.3
1CB4:  BRA    1CBC
1CB6:  MOVLW  01
1CB8:  MOVWF  01
1CBA:  BRA    1D06
....................        end_receive=0; 
1CBC:  BCF    x9F.2
....................      } 
1CBE:  BRA    1D02
....................      else 
....................      { 
....................          delay_ms(1); 
1CC0:  MOVLW  01
1CC2:  MOVLB  3
1CC4:  MOVWF  x8C
1CC6:  MOVLB  0
1CC8:  RCALL  1750
....................          t1++; 
1CCA:  MOVLW  01
1CCC:  MOVLB  3
1CCE:  ADDWF  x88,F
1CD0:  BTFSC  FD8.0
1CD2:  INCF   x89,F
1CD4:  BTFSC  FD8.2
1CD6:  INCF   x8A,F
1CD8:  BTFSC  FD8.2
1CDA:  INCF   x8B,F
....................          if(t1>to) return(0); 
1CDC:  MOVF   x87,W
1CDE:  SUBWF  x8B,W
1CE0:  BNC   1D04
1CE2:  BNZ   1CFA
1CE4:  MOVF   x86,W
1CE6:  SUBWF  x8A,W
1CE8:  BNC   1D04
1CEA:  BNZ   1CFA
1CEC:  MOVF   x85,W
1CEE:  SUBWF  x89,W
1CF0:  BNC   1D04
1CF2:  BNZ   1CFA
1CF4:  MOVF   x88,W
1CF6:  SUBWF  x84,W
1CF8:  BC    1D04
1CFA:  MOVLW  00
1CFC:  MOVWF  01
1CFE:  MOVLB  0
1D00:  BRA    1D06
1D02:  MOVLB  3
....................      } 
1D04:  BRA    1CAC
1D06:  MOVLB  0
....................     }  
1D08:  GOTO   1D5A (RETURN)
.................... }  
....................  
.................... //*************************************************************** 
.................... // Alimentation de Modem SIM508 
.................... //*************************************************************** 
.................... /* 
.................... void SIM_SendONOFF(void)  
.................... { 
....................    output_high(POWER); 
....................    delay_ms(2000); 
....................    output_low(POWER); 
....................    output_float(SIM_PKEY); 
....................    delay_ms(1000); 
....................    output_low(SIM_PKEY); 
....................    delay_ms(5000); 
....................    output_float(SIM_PKEY); 
....................    delay_ms(1000); 
.................... } 
.................... */ 
.................... void SIM_SendONOFF(void)  
.................... { 
....................    #ifdef ALARME 
....................    PWR=1; 
*
19D0:  BSF    17.6
....................    write_alarm_outputs(out); 
19D2:  MOVFF  17,37A
19D6:  RCALL  1950
....................    #else  
....................    output_high(PWR); 
....................    #endif 
....................    //fprintf(DEBUG,"PWR=1\n\r"); 
....................    delay_ms(1000); 
19D8:  MOVLW  04
19DA:  MOVLB  3
19DC:  MOVWF  x7A
19DE:  MOVLW  FA
19E0:  MOVWF  x8C
19E2:  MOVLB  0
19E4:  RCALL  1750
19E6:  MOVLB  3
19E8:  DECFSZ x7A,F
19EA:  BRA    19DE
....................    #ifdef ALARME 
....................    PWR=0; 
19EC:  BCF    17.6
....................    write_alarm_outputs(out); 
19EE:  MOVFF  17,37A
19F2:  MOVLB  0
19F4:  RCALL  1950
....................    #else 
....................       output_low(PWR); 
....................    #endif 
....................    delay_ms(1000); 
19F6:  MOVLW  04
19F8:  MOVLB  3
19FA:  MOVWF  x7A
19FC:  MOVLW  FA
19FE:  MOVWF  x8C
1A00:  MOVLB  0
1A02:  RCALL  1750
1A04:  MOVLB  3
1A06:  DECFSZ x7A,F
1A08:  BRA    19FC
....................    output_float(SIM_PKEY); 
1A0A:  BSF    F92.1
....................    //fprintf(DEBUG,"PKEY=1\n\r"); 
....................    delay_ms(1000); 
1A0C:  MOVLW  04
1A0E:  MOVWF  x7A
1A10:  MOVLW  FA
1A12:  MOVWF  x8C
1A14:  MOVLB  0
1A16:  RCALL  1750
1A18:  MOVLB  3
1A1A:  DECFSZ x7A,F
1A1C:  BRA    1A10
....................    output_low(SIM_PKEY); 
1A1E:  BCF    F92.1
1A20:  BCF    F89.1
....................    //fprintf(DEBUG,"PKEY=0\n\r"); 
....................    delay_ms(2000); 
1A22:  MOVLW  08
1A24:  MOVWF  x7A
1A26:  MOVLW  FA
1A28:  MOVWF  x8C
1A2A:  MOVLB  0
1A2C:  RCALL  1750
1A2E:  MOVLB  3
1A30:  DECFSZ x7A,F
1A32:  BRA    1A26
....................    output_float(SIM_PKEY); 
1A34:  BSF    F92.1
....................    //fprintf(DEBUG,"PKEY=1\n\r"); 
....................    delay_ms(5000); 
1A36:  MOVLW  14
1A38:  MOVWF  x7A
1A3A:  MOVLW  FA
1A3C:  MOVWF  x8C
1A3E:  MOVLB  0
1A40:  RCALL  1750
1A42:  MOVLB  3
1A44:  DECFSZ x7A,F
1A46:  BRA    1A3A
1A48:  MOVLB  0
1A4A:  GOTO   1A82 (RETURN)
.................... } 
.................... //*************************************************************** 
.................... // Alimentation et initialisation de modem par AT commande 
.................... //*************************************************************** 
....................  
.................... int SIM_PowerOn(void)  
.................... { 
....................    int g1,g2;  
....................    OK=0; 
*
1A70:  BCF    x9F.3
....................    for (g1=0;g1<5;g1++)  
1A72:  MOVLB  3
1A74:  CLRF   x78
1A76:  MOVF   x78,W
1A78:  SUBLW  04
1A7A:  BTFSS  FD8.0
1A7C:  BRA    1B80
....................    { 
....................       SIM_sendONOFF(); 
1A7E:  MOVLB  0
1A80:  BRA    19D0
....................        for (g2=0;g2<5;g2++)  
1A82:  MOVLB  3
1A84:  CLRF   x79
1A86:  MOVF   x79,W
1A88:  SUBLW  04
1A8A:  BTFSS  FD8.0
1A8C:  BRA    1B7C
....................       { 
....................          fprintf(GSM,"AT\r\n"); 
1A8E:  MOVLW  40
1A90:  MOVWF  FF6
1A92:  MOVLW  02
1A94:  MOVWF  FF7
1A96:  MOVLB  0
1A98:  RCALL  1A4E
....................          #ifdef DEBUG0 
....................          fprintf(DEBUG,"AT PIC->SIM\r\n"); 
1A9A:  MOVLW  46
1A9C:  MOVWF  FF6
1A9E:  MOVLW  02
1AA0:  MOVWF  FF7
1AA2:  CLRF   16
1AA4:  BTFSC  FF2.7
1AA6:  BSF    16.7
1AA8:  BCF    FF2.7
1AAA:  CALL   102C
1AAE:  BTFSC  16.7
1AB0:  BSF    FF2.7
....................          #endif 
....................          delay_ms(1000); 
1AB2:  MOVLW  04
1AB4:  MOVLB  3
1AB6:  MOVWF  x7A
1AB8:  MOVLW  FA
1ABA:  MOVWF  x8C
1ABC:  MOVLB  0
1ABE:  RCALL  1750
1AC0:  MOVLB  3
1AC2:  DECFSZ x7A,F
1AC4:  BRA    1AB8
....................          if(OK)  
1AC6:  MOVLB  0
1AC8:  BTFSS  x9F.3
1ACA:  BRA    1B76
....................          { 
....................             #ifdef DEBUG0 
....................             fprintf(DEBUG,"AT OK\r\n"); 
1ACC:  MOVLW  54
1ACE:  MOVWF  FF6
1AD0:  MOVLW  02
1AD2:  MOVWF  FF7
1AD4:  CLRF   16
1AD6:  BTFSC  FF2.7
1AD8:  BSF    16.7
1ADA:  BCF    FF2.7
1ADC:  CALL   102C
1AE0:  BTFSC  16.7
1AE2:  BSF    FF2.7
....................             #endif  
....................             fprintf(GSM,"AT+IPR=9600\r\n"); 
1AE4:  MOVLW  5C
1AE6:  MOVWF  FF6
1AE8:  MOVLW  02
1AEA:  MOVWF  FF7
1AEC:  RCALL  1A4E
....................             delay_ms(200);   
1AEE:  MOVLW  C8
1AF0:  MOVLB  3
1AF2:  MOVWF  x8C
1AF4:  MOVLB  0
1AF6:  RCALL  1750
....................             fprintf(GSM,"AT+CPBS=\"SM\"\n\r"); 
1AF8:  MOVLW  6A
1AFA:  MOVWF  FF6
1AFC:  MOVLW  02
1AFE:  MOVWF  FF7
1B00:  RCALL  1A4E
....................             delay_ms(200); 
1B02:  MOVLW  C8
1B04:  MOVLB  3
1B06:  MOVWF  x8C
1B08:  MOVLB  0
1B0A:  RCALL  1750
....................             fprintf(GSM,"AT+CMGF=1\r\n"); 
1B0C:  MOVLW  7A
1B0E:  MOVWF  FF6
1B10:  MOVLW  02
1B12:  MOVWF  FF7
1B14:  RCALL  1A4E
....................             delay_ms(200); 
1B16:  MOVLW  C8
1B18:  MOVLB  3
1B1A:  MOVWF  x8C
1B1C:  MOVLB  0
1B1E:  RCALL  1750
....................             fprintf(GSM,"AT+CMGD=1\r\n"); 
1B20:  MOVLW  86
1B22:  MOVWF  FF6
1B24:  MOVLW  02
1B26:  MOVWF  FF7
1B28:  RCALL  1A4E
....................             delay_ms(200); 
1B2A:  MOVLW  C8
1B2C:  MOVLB  3
1B2E:  MOVWF  x8C
1B30:  MOVLB  0
1B32:  RCALL  1750
....................             fprintf(GSM,"AT+CNMI=3,1\r\n"); 
1B34:  MOVLW  92
1B36:  MOVWF  FF6
1B38:  MOVLW  02
1B3A:  MOVWF  FF7
1B3C:  RCALL  1A4E
....................             delay_ms(200); 
1B3E:  MOVLW  C8
1B40:  MOVLB  3
1B42:  MOVWF  x8C
1B44:  MOVLB  0
1B46:  RCALL  1750
....................             fprintf(GSM,"ATE0\r\n"); 
1B48:  MOVLW  A0
1B4A:  MOVWF  FF6
1B4C:  MOVLW  02
1B4E:  MOVWF  FF7
1B50:  RCALL  1A4E
....................             delay_ms(200); 
1B52:  MOVLW  C8
1B54:  MOVLB  3
1B56:  MOVWF  x8C
1B58:  MOVLB  0
1B5A:  RCALL  1750
....................             fprintf(GSM,"AT+CLIP=1\r\n"); 
1B5C:  MOVLW  A8
1B5E:  MOVWF  FF6
1B60:  MOVLW  02
1B62:  MOVWF  FF7
1B64:  RCALL  1A4E
....................             delay_ms(200); 
1B66:  MOVLW  C8
1B68:  MOVLB  3
1B6A:  MOVWF  x8C
1B6C:  MOVLB  0
1B6E:  RCALL  1750
....................             return(1); 
1B70:  MOVLW  01
1B72:  MOVWF  01
1B74:  BRA    1B84
....................          } 
1B76:  MOVLB  3
1B78:  INCF   x79,F
1B7A:  BRA    1A86
....................       } 
1B7C:  INCF   x78,F
1B7E:  BRA    1A76
....................    }  
....................    return(0); 
1B80:  MOVLW  00
1B82:  MOVWF  01
1B84:  MOVLB  0
1B86:  GOTO   3C66 (RETURN)
.................... } 
....................  
.................... //*************************************************************** 
.................... // Test si le modem est connect aux resaux GSM 
.................... // 
.................... // Return 0 si le modem n'est pas registre 
.................... // return 1 si le modem est registre 
.................... //*************************************************************** 
.................... /* 
.................... int SIM_NetworkChecking()  
.................... { 
....................     
....................  
....................    fprintf(GSM,"AT+CREG?\r"); 
....................        
....................    if (SIM_WaitResponse(500)>0)  
....................    { 
....................       //fprintf(GPS,"s=%s\n\r",temp); 
....................       sprintf(token,"+CREG: 0,1"); 
....................       if (strstr(temp,token)==0) return 1; 
....................       sprintf(token,"+CREG: 1,1"); 
....................       if (strstr(temp,token)==0) return 1; 
....................    }    
....................    else  
....................    { 
....................       //fprintf(GPS,"Timeout\n\r"); 
....................       return 0; 
....................    } 
.................... } 
.................... */ 
.................... //************************************************************************************************* 
.................... int read_tel_n(char n,char *tel_n3) 
.................... { 
....................    n=n*10; 
*
2306:  MOVLB  3
2308:  MOVF   x79,W
230A:  MULLW  0A
230C:  MOVFF  FF3,379
....................    for(i0=0;i0<10;i0++) 
2310:  MOVLB  1
2312:  CLRF   xC7
2314:  MOVF   xC7,W
2316:  SUBLW  09
2318:  BNC   2352
....................    { 
....................       tel_n3[i0]=read_eeprom(n+i0); 
231A:  CLRF   03
231C:  MOVF   xC7,W
231E:  MOVLB  3
2320:  ADDWF  x7A,W
2322:  MOVWF  FE9
2324:  MOVF   x7B,W
2326:  ADDWFC 03,W
2328:  MOVWF  FEA
232A:  MOVLB  1
232C:  MOVF   xC7,W
232E:  MOVLB  3
2330:  ADDWF  x79,W
2332:  MOVWF  x7E
2334:  MOVFF  FF2,37F
2338:  BCF    FF2.7
233A:  MOVFF  37E,FA9
233E:  BCF    FA6.6
2340:  BCF    FA6.7
2342:  BSF    FA6.0
2344:  MOVF   FA8,W
2346:  BTFSC  x7F.7
2348:  BSF    FF2.7
234A:  MOVWF  FEF
234C:  MOVLB  1
234E:  INCF   xC7,F
2350:  BRA    2314
....................    } 
....................    tel_n3[i0]=0; 
2352:  CLRF   03
2354:  MOVF   xC7,W
2356:  MOVLB  3
2358:  ADDWF  x7A,W
235A:  MOVWF  FE9
235C:  MOVF   x7B,W
235E:  ADDWFC 03,W
2360:  MOVWF  FEA
2362:  CLRF   FEF
....................    return 1; 
2364:  MOVLW  01
2366:  MOVWF  01
2368:  MOVLB  0
236A:  RETURN 0
.................... } 
.................... //************************************************************************************************* 
.................... int make_msg(int n,char *msg) 
.................... {   
....................     
....................    n=n*32; 
....................    for(i0=0;i0<32;i0++) 
....................    { 
....................       msg[i0]=read_eeprom(n+i0+40); 
....................       if(msg[i0]==0) break; 
....................    } 
....................   /* suit: 
....................    msg[++i0]=' '; 
....................    pos=0; 
....................    for(i0=0;i0<15;i0++) msg[pos+i0]=read_eeprom(168+i0);; 
....................    pos=pos+15; 
....................    for(i0=0;i0<15;i0++) msg[pos+i0]=read_eeprom(183+i0); 
....................    pos=pos+15; 
....................    for(i0=0;i0<8;i0++) msg[pos+i0]=read_eeprom(198+i0); 
....................    pos=pos+8; 
....................    for(i0=0;i0<6;i0++) msg[pos+i0]=read_eeprom(206+i0); 
....................    pos=pos+6; 
....................    for(i0=0;i0<6;i0++) msg[pos+i0]=read_eeprom(212+i0); 
....................    pos=pos+6; 
....................    for(i0=0;i0<6;i0++) msg[pos+i0]=read_eeprom(218+i0); 
....................    pos=pos+6; 
....................    for(i0=0;i0<6;i0++) msg[pos+i0]=read_eeprom(224+i0);*/ 
....................    /* 
....................    for(i0=0;i0<15;i0++) msg[pos+i0]='x'; 
....................    pos=pos+15; 
....................    for(i0=0;i0<15;i0++) msg[pos+i0]='y'; 
....................    pos=pos+15; 
....................    for(i0=0;i0<8;i0++) msg[pos+i0]='z'; 
....................    pos=pos+8; 
....................    for(i0=0;i0<6;i0++) msg[pos+i0]='t'; 
....................    pos=pos+6; 
....................    for(i0=0;i0<6;i0++) msg[pos+i0]='d'; 
....................    pos=pos+6; 
....................    for(i0=0;i0<6;i0++) msg[pos+i0]='c'; 
....................    pos=pos+6; 
....................    for(i0=0;i0<6;i0++) msg[pos+i0]='s';*/ 
....................     
....................    return 1; 
.................... } 
....................  
.................... int wait_rep(char test,int16 time ) 
.................... { 
....................    
....................    t0=0; 
....................    depart: 
....................    if(SerialBuffer_pos>0) 
....................    { 
....................       if((SerialBuffer[0]==test)&&(t0<time)) return(1); 
....................    } 
....................    else  
....................    {   
....................       if(t0==time) return (0); 
....................       t0++; 
....................       delay_ms(1); 
....................       goto depart; 
....................    }  
....................    //if(kbhit())  
....................    //{  c=getc(); 
....................    //printf("char=%c:%d\n\r",c,c); 
....................    //if(t0<time) return 1; 
....................    //else return 0; 
....................       //if((c!=test)&&(t0<(time-1))) goto depart; 
....................    //} 
....................    //else return 0; 
.................... } 
.................... //************************************************************************************************* 
.................... int wait_(int16 time ) 
.................... { 
....................    
....................     
....................    t0=0; 
*
2D76:  MOVLB  2
2D78:  CLRF   x86
2D7A:  CLRF   x85
....................    depart: 
....................    if(msg_tx==1)  
2D7C:  MOVLB  0
2D7E:  DECFSZ xDD,W
2D80:  BRA    2D8A
....................    { 
....................       return(1); 
2D82:  MOVLW  01
2D84:  MOVWF  01
2D86:  BRA    2DBC
....................    } 
2D88:  BRA    2DBC
....................    else  
....................    {   
....................       if(t0==time) return (0); 
2D8A:  MOVLB  3
2D8C:  MOVF   x79,W
2D8E:  MOVLB  2
2D90:  SUBWF  x85,W
2D92:  BNZ   2DA8
2D94:  MOVLB  3
2D96:  MOVF   x7A,W
2D98:  MOVLB  2
2D9A:  SUBWF  x86,W
2D9C:  BNZ   2DA8
2D9E:  MOVLW  00
2DA0:  MOVWF  01
2DA2:  MOVLB  0
2DA4:  BRA    2DBC
2DA6:  MOVLB  2
....................       t0++; 
2DA8:  INCF   x85,F
2DAA:  BTFSC  FD8.2
2DAC:  INCF   x86,F
....................       delay_ms(1); 
2DAE:  MOVLW  01
2DB0:  MOVLB  3
2DB2:  MOVWF  x8C
2DB4:  MOVLB  0
2DB6:  CALL   1750
....................       goto depart; 
2DBA:  BRA    2D7E
....................    }  
2DBC:  RETURN 0
....................    //if(kbhit())  
....................    //{  c=getc(); 
....................    //printf("char=%c:%d\n\r",c,c); 
....................    //if(t0<time) return 1; 
....................    //else return 0; 
....................       //if((c!=test)&&(t0<(time-1))) goto depart; 
....................    //} 
....................    //else return 0; 
.................... } 
.................... //************************************************************************************************* 
.................... int   send_sms(char *tel_n,char *msg,int mode) 
.................... { 
....................    unsigned char tmp1 = 0,tmp2 = 1,tmp3 = 0,tmp4 = 0,NewMsg[49]; 
....................    unsigned char NewNumber[16],shift = 0,rep; 
....................     
....................    if(mode==0)  //Message to PDU Format 
....................    { 
....................       while (Msg[tmp1] != 0) 
....................       { 
....................          NewMsg[tmp2] = (Msg[tmp1]&0x7F)>>shift; 
....................          if (shift != 0) 
....................          { 
....................             NewMsg[tmp2-1] |= (Msg[tmp1]&((1<<shift)-1))<<(8-shift); 
....................          } 
....................          shift++; 
....................          tmp1++; 
....................          if (shift == 8) 
....................          { 
....................             shift=0; 
....................          } 
....................          else 
....................          { 
....................             tmp2++; 
....................          } 
....................       } 
....................       NewMsg[0]= tmp1; 
....................     
....................       //Number to PDU Format 
....................       while (tel_n[tmp3] !=0) 
....................       { 
....................          tmp4 = tel_n[tmp3+1]; 
....................          NewNumber[tmp3+1] = tel_n[tmp3]; 
....................          if (tmp4 == 0) 
....................          { 
....................             NewNumber[tmp3] = 'F'; 
....................             tmp3=tmp3 + 2; 
....................             NewNumber[tmp3] = 0x0; 
....................             break; 
....................          } 
....................          NewNumber[tmp3] = tmp4; 
....................          tmp3=tmp3 + 2; 
....................          NewNumber[tmp3] = 0x0; 
....................       } 
....................     
....................       //Send SMS  
....................       printf("AT+CMGS=%i\r\n",(tmp2+(tmp3/2)+0x07)); 
....................       while(getc()!=' '); 
....................       //Adresse SMSC (optional) 
....................       printf("0791947101670000"); 
....................       //Header1 
....................       printf("113C"); 
....................       //Distination Number 
....................       if(NewNumber[tmp3-2] =='F') 
....................       { 
....................          tmp3--; 
....................       } 
....................       printf("%02X91",tmp3); 
....................       printf(NewNumber); 
....................       //Header2 
....................       printf("0000A8"); 
....................       //SendMessage String 
....................       for (tmp1 = 0;tmp1<tmp2;tmp1++) 
....................       { 
....................          printf("%02X", NewMsg[tmp1]); 
....................       } 
....................       printf("%c",0x1a); 
....................       gets(NewMsg); 
....................       gets(NewMsg); 
....................       if(NewMsg[0]=='+') 
....................       { 
....................          return (0); 
....................       }; 
....................       return (1); 
....................    } 
....................    else if(mode==1) 
....................    { 
....................       fprintf(GSM,"AT+CMGF=1\r\n"); 
....................       if (SIM_WaitResponse(20000))  
....................      { 
....................          printf("AT+CMGS=\"%s\"\r\n",tel_n); 
....................          rep=wait_rep('>',100); 
....................          if(rep==0) return (0); 
....................          printf("%s : ",msg); 
....................          rep=wait_rep('>',100); 
....................          if(rep==0) return (0); 
....................          printf("%c : ",0x1a); 
....................      } 
....................    } 
....................    else return (0); 
....................     
.................... } 
.................... //************************************************************************************************* 
.................... int bip(char *tel_n) 
.................... { 
....................    int16  time; 
....................    int rep[10]; 
....................    //buffer[1]='s'; 
....................    //fprintf(GSM,"ATE1\r\n"); 
....................    //delay_ms(1000); 
....................    no_ok=0; 
*
2392:  MOVLB  1
2394:  CLRF   xBE
....................    fprintf(GSM,"ATD%s;\r\n",tel_n); 
2396:  MOVLW  0A
2398:  MOVWF  FF6
239A:  MOVLW  03
239C:  MOVWF  FF7
239E:  MOVLW  03
23A0:  MOVLB  3
23A2:  MOVWF  x87
23A4:  MOVLB  0
23A6:  CALL   1B8A
23AA:  MOVFF  37A,FEA
23AE:  MOVFF  379,FE9
23B2:  RCALL  236C
23B4:  MOVLW  0F
23B6:  MOVWF  FF6
23B8:  MOVLW  03
23BA:  MOVWF  FF7
23BC:  MOVLW  03
23BE:  MOVLB  3
23C0:  MOVWF  x87
23C2:  MOVLB  0
23C4:  CALL   1B8A
....................    //get_string(rep,2); 
....................    //fprintf(DEBUG,"rep=%s\r\n",rep); 
....................    //get_string(rep,2); 
....................    //fprintf(DEBUG,"rep=%s\r\n",rep); 
....................    for(time=0;time<30000;time++) 
23C8:  MOVLB  3
23CA:  CLRF   x7C
23CC:  CLRF   x7B
23CE:  MOVF   x7C,W
23D0:  SUBLW  75
23D2:  BTFSS  FD8.0
23D4:  BRA    2590
23D6:  BNZ   23E0
23D8:  MOVF   x7B,W
23DA:  SUBLW  2F
23DC:  BTFSS  FD8.0
23DE:  BRA    2590
....................    { 
....................       if(no_ok) 
23E0:  MOVLB  1
23E2:  MOVF   xBE,F
23E4:  BTFSC  FD8.2
23E6:  BRA    257A
....................       { 
....................          fprintf(DEBUG,"No ok\r\n"); 
23E8:  MOVLW  14
23EA:  MOVWF  FF6
23EC:  MOVLW  03
23EE:  MOVWF  FF7
23F0:  CLRF   16
23F2:  BTFSC  FF2.7
23F4:  BSF    16.7
23F6:  BCF    FF2.7
23F8:  MOVLB  0
23FA:  CALL   102C
23FE:  BTFSC  16.7
2400:  BSF    FF2.7
....................          no_ok=0; 
2402:  MOVLB  1
2404:  CLRF   xBE
....................          strcpy(buffer,SerialBuffer); 
2406:  MOVLW  01
2408:  MOVWF  FEA
240A:  MOVLW  C8
240C:  MOVWF  FE9
240E:  CLRF   FE2
2410:  MOVLW  1C
2412:  MOVWF  FE1
2414:  MOVF   FE7,F
2416:  MOVFF  FE6,FEE
241A:  BNZ   2414
....................          fprintf(DEBUG,"buffer=%c%c%c%c\r\n",buffer[0],buffer[1],buffer[2],buffer[3]); 
241C:  MOVLW  1C
241E:  MOVWF  FF6
2420:  MOVLW  03
2422:  MOVWF  FF7
2424:  MOVLW  07
2426:  MOVLB  3
2428:  MOVWF  x87
242A:  MOVLB  0
242C:  RCALL  21D4
242E:  CLRF   16
2430:  BTFSC  FF2.7
2432:  BSF    16.7
2434:  BCF    FF2.7
2436:  MOVFF  1C8,3AE
243A:  CALL   0FDA
243E:  BTFSC  16.7
2440:  BSF    FF2.7
2442:  CLRF   16
2444:  BTFSC  FF2.7
2446:  BSF    16.7
2448:  BCF    FF2.7
244A:  MOVFF  1C9,3AE
244E:  CALL   0FDA
2452:  BTFSC  16.7
2454:  BSF    FF2.7
2456:  CLRF   16
2458:  BTFSC  FF2.7
245A:  BSF    16.7
245C:  BCF    FF2.7
245E:  MOVFF  1CA,3AE
2462:  CALL   0FDA
2466:  BTFSC  16.7
2468:  BSF    FF2.7
246A:  CLRF   16
246C:  BTFSC  FF2.7
246E:  BSF    16.7
2470:  BCF    FF2.7
2472:  MOVFF  1CB,3AE
2476:  CALL   0FDA
247A:  BTFSC  16.7
247C:  BSF    FF2.7
247E:  CLRF   16
2480:  BTFSC  FF2.7
2482:  BSF    16.7
2484:  BCF    FF2.7
2486:  MOVLW  0D
2488:  MOVLB  3
248A:  MOVWF  xAE
248C:  MOVLB  0
248E:  CALL   0FDA
2492:  BTFSC  16.7
2494:  BSF    FF2.7
2496:  CLRF   16
2498:  BTFSC  FF2.7
249A:  BSF    16.7
249C:  BCF    FF2.7
249E:  MOVLW  0A
24A0:  MOVLB  3
24A2:  MOVWF  xAE
24A4:  MOVLB  0
24A6:  CALL   0FDA
24AA:  BTFSC  16.7
24AC:  BSF    FF2.7
....................          if ((buffer[0]=='B')||(buffer[1]=='B'))  
24AE:  MOVLB  1
24B0:  MOVF   xC8,W
24B2:  SUBLW  42
24B4:  BZ    24BC
24B6:  MOVF   xC9,W
24B8:  SUBLW  42
24BA:  BNZ   24E0
....................          { 
....................             //fprintf(GSM,"ATE0\r\n"); 
....................             //delay_ms(1000); 
....................             fprintf(DEBUG,"Busy status\r\n"); 
24BC:  MOVLW  2E
24BE:  MOVWF  FF6
24C0:  MOVLW  03
24C2:  MOVWF  FF7
24C4:  CLRF   16
24C6:  BTFSC  FF2.7
24C8:  BSF    16.7
24CA:  BCF    FF2.7
24CC:  MOVLB  0
24CE:  CALL   102C
24D2:  BTFSC  16.7
24D4:  BSF    FF2.7
....................             return 1; 
24D6:  MOVLW  01
24D8:  MOVWF  01
24DA:  BRA    2590
....................          } 
24DC:  BRA    2578
24DE:  MOVLB  1
....................          else  
....................          { 
....................             fprintf(DEBUG,"No carr status %c%c%c%c\r\n",buffer[0],buffer[1],buffer[2],buffer[3]); 
24E0:  MOVLW  3C
24E2:  MOVWF  FF6
24E4:  MOVLW  03
24E6:  MOVWF  FF7
24E8:  MOVLW  0F
24EA:  MOVLB  3
24EC:  MOVWF  x87
24EE:  MOVLB  0
24F0:  RCALL  21D4
24F2:  CLRF   16
24F4:  BTFSC  FF2.7
24F6:  BSF    16.7
24F8:  BCF    FF2.7
24FA:  MOVFF  1C8,3AE
24FE:  CALL   0FDA
2502:  BTFSC  16.7
2504:  BSF    FF2.7
2506:  CLRF   16
2508:  BTFSC  FF2.7
250A:  BSF    16.7
250C:  BCF    FF2.7
250E:  MOVFF  1C9,3AE
2512:  CALL   0FDA
2516:  BTFSC  16.7
2518:  BSF    FF2.7
251A:  CLRF   16
251C:  BTFSC  FF2.7
251E:  BSF    16.7
2520:  BCF    FF2.7
2522:  MOVFF  1CA,3AE
2526:  CALL   0FDA
252A:  BTFSC  16.7
252C:  BSF    FF2.7
252E:  CLRF   16
2530:  BTFSC  FF2.7
2532:  BSF    16.7
2534:  BCF    FF2.7
2536:  MOVFF  1CB,3AE
253A:  CALL   0FDA
253E:  BTFSC  16.7
2540:  BSF    FF2.7
2542:  CLRF   16
2544:  BTFSC  FF2.7
2546:  BSF    16.7
2548:  BCF    FF2.7
254A:  MOVLW  0D
254C:  MOVLB  3
254E:  MOVWF  xAE
2550:  MOVLB  0
2552:  CALL   0FDA
2556:  BTFSC  16.7
2558:  BSF    FF2.7
255A:  CLRF   16
255C:  BTFSC  FF2.7
255E:  BSF    16.7
2560:  BCF    FF2.7
2562:  MOVLW  0A
2564:  MOVLB  3
2566:  MOVWF  xAE
2568:  MOVLB  0
256A:  CALL   0FDA
256E:  BTFSC  16.7
2570:  BSF    FF2.7
....................             return 0; 
2572:  MOVLW  00
2574:  MOVWF  01
2576:  BRA    2590
2578:  MOVLB  1
....................          } 
....................       } 
....................       delay_ms(1); 
257A:  MOVLW  01
257C:  MOVLB  3
257E:  MOVWF  x8C
2580:  MOVLB  0
2582:  CALL   1750
2586:  MOVLB  3
2588:  INCF   x7B,F
258A:  BTFSC  FD8.2
258C:  INCF   x7C,F
258E:  BRA    23CE
2590:  MOVLB  0
....................        
....................    } 
2592:  GOTO   3176 (RETURN)
....................    //fprintf(GSM,"ATH\r\n"); 
....................    /*if (SIM_WaitResponse(50000)>0)  
....................    //{ 
....................        
....................       sprintf(token,"NO CARRIER"); 
....................       if (strstr(temp,token)==0) return -1; 
....................       else return 1; 
....................   /* }    
....................    else  
....................    { 
....................       return 0; 
....................    }*/ 
.................... } 
....................  
.................... //************************************************************************************************* 
.................... //************************************************************************************************* 
....................  
.................... void init_GPS() 
.................... { 
....................     
....................    //output_high(GPS_MRST); 
....................    delay_ms(100); 
....................    output_low(GPS_MRST); 
....................    delay_ms(100); 
....................    output_high(GPS_MRST); 
....................   // #USE RS232(BAUD=4800, XMIT=GPS_TX, RCV=GPS_RX) 
....................    //for(p=0;p<6;p++) printf("PSRF103,0%d,01,00,00*25\r\n",p); 
....................     
.................... } 
....................  
.................... //------------------------------------------------------------------------------------------------ 
.................... #ifdef GPS0 
.................... int get_gps_speed(char *s0,char *c0) 
*
36F2:  MOVLB  3
36F4:  CLRF   x7C
.................... { 
....................   //#USE RS232(BAUD=4800, XMIT=GPS_TX, RCV=GPS_RX) 
....................    char ok=0,x1; 
....................    do 
....................    { 
....................       i0=0; 
36F6:  MOVLB  1
36F8:  CLRF   xC7
....................       w='\0'; 
36FA:  CLRF   xBD
....................       vergule_n=0; 
36FC:  CLRF   x43
....................       do 
....................       {          
....................          w=fgetc(GPS); 
36FE:  MOVLB  0
3700:  RCALL  3694
3702:  MOVFF  01,1BD
....................       }while(w>20); 
3706:  MOVLB  1
3708:  MOVF   xBD,W
370A:  SUBLW  14
370C:  BNC   36FE
....................       do 
....................       { 
....................          w=fgetc(GPS); 
370E:  MOVLB  0
3710:  RCALL  3694
3712:  MOVFF  01,1BD
....................          if(w>20) 
3716:  MOVLB  1
3718:  MOVF   xBD,W
371A:  SUBLW  14
371C:  BC    375C
....................          { 
....................             temp0[i0]=w; 
371E:  CLRF   03
3720:  MOVF   xC7,W
3722:  ADDLW  EF
3724:  MOVWF  FE9
3726:  MOVLW  00
3728:  ADDWFC 03,W
372A:  MOVWF  FEA
372C:  MOVFF  1BD,FEF
....................             if(i0<6) head[i0]=w; 
3730:  MOVF   xC7,W
3732:  SUBLW  05
3734:  BNC   374A
3736:  CLRF   03
3738:  MOVF   xC7,W
373A:  ADDLW  E8
373C:  MOVWF  FE9
373E:  MOVLW  00
3740:  ADDWFC 03,W
3742:  MOVWF  FEA
3744:  MOVFF  1BD,FEF
3748:  BRA    375A
....................             else head[i0]='\0'; 
374A:  CLRF   03
374C:  MOVF   xC7,W
374E:  ADDLW  E8
3750:  MOVWF  FE9
3752:  MOVLW  00
3754:  ADDWFC 03,W
3756:  MOVWF  FEA
3758:  CLRF   FEF
....................             i0++; 
375A:  INCF   xC7,F
....................          } 
....................       } 
....................       while(w!=13); 
375C:  MOVF   xBD,W
375E:  SUBLW  0D
3760:  BNZ   370E
....................       w=fgetc(GPS); 
3762:  MOVLB  0
3764:  RCALL  3694
3766:  MOVFF  01,1BD
....................       for(x1=0;x1<i0;x1++)  
376A:  MOVLB  3
376C:  CLRF   x7D
376E:  MOVLB  1
3770:  MOVF   xC7,W
3772:  MOVLB  3
3774:  SUBWF  x7D,W
3776:  BC    37A8
....................       { 
....................          if(temp0[x1]==',') 
3778:  CLRF   03
377A:  MOVF   x7D,W
377C:  ADDLW  EF
377E:  MOVWF  FE9
3780:  MOVLW  00
3782:  ADDWFC 03,W
3784:  MOVWF  FEA
3786:  MOVF   FEF,W
3788:  SUBLW  2C
378A:  BNZ   37A4
....................          { 
....................             vergule_pos[vergule_n]=x1; 
378C:  CLRF   03
378E:  MOVLB  1
3790:  MOVF   x43,W
3792:  ADDLW  2F
3794:  MOVWF  FE9
3796:  MOVLW  01
3798:  ADDWFC 03,W
379A:  MOVWF  FEA
379C:  MOVFF  37D,FEF
....................             vergule_n++; 
37A0:  INCF   x43,F
37A2:  MOVLB  3
....................          } 
37A4:  INCF   x7D,F
37A6:  BRA    376E
....................       } 
....................        
....................       if((head[3]=='V')&&(head[4]=='T')&&(head[5]=='G'))  
37A8:  MOVLB  0
37AA:  MOVF   xEB,W
37AC:  SUBLW  56
37AE:  BTFSS  FD8.2
37B0:  BRA    38A6
37B2:  MOVF   xEC,W
37B4:  SUBLW  54
37B6:  BTFSS  FD8.2
37B8:  BRA    38A6
37BA:  MOVF   xED,W
37BC:  SUBLW  47
37BE:  BNZ   38A6
....................       {  #ifdef DEBUG0 
....................             fprintf(DEBUG,"Get Speed\r\n"); 
37C0:  MOVLW  56
37C2:  MOVWF  FF6
37C4:  MOVLW  03
37C6:  MOVWF  FF7
37C8:  CLRF   16
37CA:  BTFSC  FF2.7
37CC:  BSF    16.7
37CE:  BCF    FF2.7
37D0:  CALL   102C
37D4:  BTFSC  16.7
37D6:  BSF    FF2.7
....................             //fprintf(DEBUG,"msg=%s\r\n",temp0); 
....................          #endif  
....................          for(j=0;j<(vergule_pos[1]-vergule_pos[0])-1;j++) c0[j]=temp0[j+vergule_pos[0]+1]; 
37D8:  MOVLB  1
37DA:  CLRF   xC6
37DC:  MOVF   x2F,W
37DE:  SUBWF  x30,W
37E0:  ADDLW  FF
37E2:  SUBWF  xC6,W
37E4:  BC    3826
37E6:  CLRF   03
37E8:  MOVF   xC6,W
37EA:  MOVLB  3
37EC:  ADDWF  x7A,W
37EE:  MOVWF  01
37F0:  MOVF   x7B,W
37F2:  ADDWFC 03,F
37F4:  MOVFF  01,37E
37F8:  MOVFF  03,37F
37FC:  MOVLB  1
37FE:  MOVF   x2F,W
3800:  ADDWF  xC6,W
3802:  ADDLW  01
3804:  CLRF   03
3806:  ADDLW  EF
3808:  MOVWF  FE9
380A:  MOVLW  00
380C:  ADDWFC 03,W
380E:  MOVWF  FEA
3810:  MOVFF  FEF,380
3814:  MOVFF  37F,FEA
3818:  MOVFF  01,FE9
381C:  MOVFF  380,FEF
3820:  MOVLB  1
3822:  INCF   xC6,F
3824:  BRA    37DC
....................          c0[j]='\0'; 
3826:  CLRF   03
3828:  MOVF   xC6,W
382A:  MOVLB  3
382C:  ADDWF  x7A,W
382E:  MOVWF  FE9
3830:  MOVF   x7B,W
3832:  ADDWFC 03,W
3834:  MOVWF  FEA
3836:  CLRF   FEF
....................          for(j=0;j<(vergule_pos[7]-vergule_pos[6])-1;j++) s0[j]=temp0[j+vergule_pos[6]+1]; 
3838:  MOVLB  1
383A:  CLRF   xC6
383C:  MOVF   x35,W
383E:  SUBWF  x36,W
3840:  ADDLW  FF
3842:  SUBWF  xC6,W
3844:  BC    3886
3846:  CLRF   03
3848:  MOVF   xC6,W
384A:  MOVLB  3
384C:  ADDWF  x78,W
384E:  MOVWF  01
3850:  MOVF   x79,W
3852:  ADDWFC 03,F
3854:  MOVFF  01,37E
3858:  MOVFF  03,37F
385C:  MOVLB  1
385E:  MOVF   x35,W
3860:  ADDWF  xC6,W
3862:  ADDLW  01
3864:  CLRF   03
3866:  ADDLW  EF
3868:  MOVWF  FE9
386A:  MOVLW  00
386C:  ADDWFC 03,W
386E:  MOVWF  FEA
3870:  MOVFF  FEF,380
3874:  MOVFF  37F,FEA
3878:  MOVFF  01,FE9
387C:  MOVFF  380,FEF
3880:  MOVLB  1
3882:  INCF   xC6,F
3884:  BRA    383C
....................          s0[j]='\0'; 
3886:  CLRF   03
3888:  MOVF   xC6,W
388A:  MOVLB  3
388C:  ADDWF  x78,W
388E:  MOVWF  FE9
3890:  MOVF   x79,W
3892:  ADDWFC 03,W
3894:  MOVWF  FEA
3896:  CLRF   FEF
....................          ok=1; 
3898:  MOVLW  01
389A:  MOVWF  x7C
....................          return i0; 
389C:  MOVLB  1
389E:  MOVFF  1C7,01
38A2:  BRA    38B0
38A4:  MOVLB  0
....................       } 
....................    }while(ok==0); 
38A6:  MOVLB  3
38A8:  MOVF   x7C,F
38AA:  BTFSC  FD8.2
38AC:  BRA    36F6
38AE:  MOVLB  1
38B0:  MOVLB  0
38B2:  RETURN 0
.................... } 
.................... //------------------------------------------------------------------------------------------------ 
.................... int get_gps_time(char *d0,char *t1) 
.................... { 
....................    //#USE RS232(BAUD=4800, XMIT=GPS_TX, RCV=GPS_RX) 
....................    char ok=0,x1; 
....................    do 
....................    { 
....................       i0=0; 
....................       w='\0'; 
....................       vergule_n=0; 
....................       do 
....................       {          
....................          w=fgetc(GPS); 
....................       }while(w>20); 
....................       do 
....................       { 
....................          w=fgetc(GPS); 
....................          if(w>20) 
....................          { 
....................             temp0[i0]=w; 
....................             if(i0<6) head[i0]=w; 
....................             else head[i0]='\0'; 
....................             i0++; 
....................          } 
....................       } 
....................       while(w!=13); 
....................       w=fgetc(GPS); 
....................       for(x1=0;x1<i0;x1++)  
....................       { 
....................          if(temp0[x1]==',') 
....................          { 
....................             vergule_pos[vergule_n]=x1; 
....................             vergule_n++; 
....................          } 
....................       } 
....................       #ifdef DEBUG0 
....................         // fprintf(DEBUG,"Get Time\r\n"); 
....................         // fprintf(DEBUG,"h=%c%c%c\r\n",head[3],head[4],head[5]); 
....................       #endif 
....................       if((head[3]=='R')&&(head[4]=='M')&&(head[5]=='C'))  
....................       {   
....................          #ifdef DEBUG0 
....................             fprintf(DEBUG,"Get Time\r\n"); 
....................             fprintf(DEBUG,"msg=%s\r\n",temp0); 
....................          #endif  
....................          //for(j=0;j<(vergule_pos[1]-vergule_pos[0]);j++) t1[j]=temp0[j+vergule_pos[0]+1]; 
....................          for(j=0;j<6;j++) t1[j]=temp0[j+vergule_pos[0]+1]; 
....................          t1[j]='\0'; 
....................          for(j=0;j<6;j++) d0[j]=temp0[j+vergule_pos[8]+1]; 
....................          //for(j=0;j<(vergule_pos[9]-vergule_pos[8]);j++) d0[j]=temp0[j+vergule_pos[8]+1]; 
....................           
....................          d0[j]='\0', 
....................          ok=1; 
....................          return i0; 
....................       } 
....................    }while(ok==0);    
.................... } 
.................... //------------------------------------------------------------------------------------------------ 
.................... int get_gps_pos() 
.................... { 
....................    //#USE RS232(BAUD=4800, XMIT=GPS_TX, RCV=GPS_RX) 
....................    char ok,x1; 
....................    do 
....................    { 
....................       ok=0; 
....................       i0=0; 
....................       w='\0'; 
....................       vergule_n=0; 
....................       do 
....................       {          
....................          w=fgetc(GPS); 
....................       }while(w>20); 
....................       do 
....................       { 
....................          w=fgetc(GPS); 
....................          if(w>20) 
....................          { 
....................             temp0[i0]=w; 
....................             if(i0<6) head[i0]=w; 
....................             else head[i0]='\0'; 
....................             i0++; 
....................          } 
....................       } 
....................       while(w!=13); 
....................       w=fgetc(GPS); 
....................       for(x1=0;x1<i0;x1++)  
....................       { 
....................          if(temp0[x1]==',') 
....................          { 
....................             vergule_pos[vergule_n]=x1; 
....................             vergule_n++; 
....................          } 
....................       } 
....................       fprintf(DEBUG,"h=%s\n\r",head); 
....................       //strcpy(txt_test,"$GPGGA"); 
....................       #ifdef DEBUG0 
....................          fprintf(DEBUG,"Get Position\r\n"); 
....................          fprintf(DEBUG,"h=%c%c%c\r\n",head[3],head[4],head[5]); 
....................       #endif 
....................       if((head[3]=='G')&&(head[4]=='G')&&(head[5]=='A'))  
....................       {    
....................          #ifdef DEBUG0 
....................             fprintf(DEBUG,"Get Position\r\n"); 
....................             fprintf(DEBUG,"msg=%s\r\n",temp0); 
....................          #endif  
....................          for(j=0;j<(vergule_pos[2]-vergule_pos[1]);j++) x0[j]=temp0[j+vergule_pos[1]+1]; 
....................          x0[j]=temp0[vergule_pos[2]+1]; 
....................          //for(g0=j;g0<15;g0++)  
....................          x0[j+1]='\0'; 
....................          for(j=0;j<(vergule_pos[4]-vergule_pos[3]);j++) y0[j]=temp0[j+vergule_pos[3]+1]; 
....................          y0[j]=temp0[vergule_pos[4]+1]; 
....................          y0[j+1]='\0'; 
....................          ok=1; 
....................          x[0]=x0[0]; 
....................          x[1]=x0[1]; 
....................          y[0]=y0[0]; 
....................          y[1]=y0[1]; 
....................          return i0; 
....................       }; 
....................    }while(ok==0); 
.................... } 
.................... #endif 
.................... void SIM2EEPROM(char n) 
.................... { 
....................    char n01[10],i; 
....................    SerialBuffer[0]='\0'; 
*
1D0C:  CLRF   1C
....................    fprintf(GSM,"AT+CPBR=%d\r\n",n); 
1D0E:  MOVLW  A2
1D10:  MOVWF  FF6
1D12:  MOVLW  03
1D14:  MOVWF  FF7
1D16:  MOVLW  08
1D18:  MOVLB  3
1D1A:  MOVWF  x87
1D1C:  MOVLB  0
1D1E:  RCALL  1B8A
1D20:  MOVFF  378,384
1D24:  MOVLW  18
1D26:  MOVLB  3
1D28:  MOVWF  x85
1D2A:  MOVLB  0
1D2C:  BRA    1BE0
1D2E:  MOVLW  0D
1D30:  BTFSS  F9E.4
1D32:  BRA    1D30
1D34:  MOVWF  FAD
1D36:  MOVLW  0A
1D38:  BTFSS  F9E.4
1D3A:  BRA    1D38
1D3C:  MOVWF  FAD
....................    delay_ms(100); 
1D3E:  MOVLW  64
1D40:  MOVLB  3
1D42:  MOVWF  x8C
1D44:  MOVLB  0
1D46:  RCALL  1750
....................    if( SIM_WaitResponse(10000)) 
1D48:  MOVLB  3
1D4A:  CLRF   x87
1D4C:  CLRF   x86
1D4E:  MOVLW  27
1D50:  MOVWF  x85
1D52:  MOVLW  10
1D54:  MOVWF  x84
1D56:  MOVLB  0
1D58:  BRA    1CA0
1D5A:  MOVF   01,F
1D5C:  BZ    1E0C
....................    { 
....................       //fprintf(GPS,"\rtemp1=%s\r\n",buffer); 
....................       n01[0]='0'; 
1D5E:  MOVLW  30
1D60:  MOVLB  3
1D62:  MOVWF  x79
....................       //write_eeprom(10*(n-1),'0'); 
....................       for(i=12;i<21;i++)  
1D64:  MOVLW  0C
1D66:  MOVWF  x83
1D68:  MOVF   x83,W
1D6A:  SUBLW  14
1D6C:  BNC   1DA2
....................       { 
....................          //write_eeprom(10*(n-1)+(i-13),temp01[i]); 
....................          n01[i-11]=buffer[i]; 
1D6E:  MOVLW  0B
1D70:  SUBWF  x83,W
1D72:  CLRF   03
1D74:  ADDLW  79
1D76:  MOVWF  01
1D78:  MOVLW  03
1D7A:  ADDWFC 03,F
1D7C:  MOVFF  03,385
1D80:  CLRF   03
1D82:  MOVF   x83,W
1D84:  ADDLW  C8
1D86:  MOVWF  FE9
1D88:  MOVLW  01
1D8A:  ADDWFC 03,W
1D8C:  MOVWF  FEA
1D8E:  MOVFF  FEF,386
1D92:  MOVFF  385,FEA
1D96:  MOVFF  01,FE9
1D9A:  MOVFF  386,FEF
1D9E:  INCF   x83,F
1DA0:  BRA    1D68
....................       } 
....................       for(i=0;i<10;i++)  
1DA2:  CLRF   x83
1DA4:  MOVF   x83,W
1DA6:  SUBLW  09
1DA8:  BNC   1DF8
....................       { 
....................          write_eeprom(10*(n-1)+i,n01[i]); 
1DAA:  MOVLW  01
1DAC:  SUBWF  x78,W
1DAE:  MULLW  0A
1DB0:  MOVF   FF3,W
1DB2:  ADDWF  x83,W
1DB4:  MOVWF  x84
1DB6:  CLRF   03
1DB8:  MOVF   x83,W
1DBA:  ADDLW  79
1DBC:  MOVWF  FE9
1DBE:  MOVLW  03
1DC0:  ADDWFC 03,W
1DC2:  MOVWF  FEA
1DC4:  MOVFF  FEF,385
1DC8:  MOVF   FF2,W
1DCA:  MOVWF  00
1DCC:  BCF    FF2.7
1DCE:  MOVFF  384,FA9
1DD2:  MOVFF  385,FA8
1DD6:  BCF    FA6.6
1DD8:  BCF    FA6.7
1DDA:  BSF    FA6.2
1DDC:  MOVLB  F
1DDE:  MOVLW  55
1DE0:  MOVWF  FA7
1DE2:  MOVLW  AA
1DE4:  MOVWF  FA7
1DE6:  BSF    FA6.1
1DE8:  BTFSC  FA6.1
1DEA:  BRA    1DE8
1DEC:  BCF    FA6.2
1DEE:  MOVF   00,W
1DF0:  IORWF  FF2,F
1DF2:  MOVLB  3
1DF4:  INCF   x83,F
1DF6:  BRA    1DA4
....................       } 
....................       n01[i-11]='\0'; 
1DF8:  MOVLW  0B
1DFA:  SUBWF  x83,W
1DFC:  CLRF   03
1DFE:  ADDLW  79
1E00:  MOVWF  FE9
1E02:  MOVLW  03
1E04:  ADDWFC 03,W
1E06:  MOVWF  FEA
1E08:  CLRF   FEF
....................       //fprintf(GPS,"n_tel %d=%s\r\n",n,n01); 
....................    } 
1E0A:  MOVLB  0
....................    else 
....................    { 
....................       //fprintf(GPS,"SIM2EEPROM erreur"); 
....................    } 
1E0C:  RETURN 0
.................... } 
.................... /* 
.................... int WritePhoneBook(char index,*n,*nom) 
.................... { 
....................     SerialBuffer[0]='\0'; 
....................    fprintf(GSM,"AT+CPBW=%d,\"%s\",161,\"%s\"\r\n",index,n,nom); 
....................    delay_ms(100); 
....................    if( SIM_WaitResponse(10000)) 
....................    { 
....................       return(1); 
....................    } 
....................    else return(0); 
....................    //"AT+CPBW=1",n,"161,",nom 
.................... }*/ 
....................  
.................... int get_ring_n(char *tel_n0) 
.................... { 
....................   int32 t1; 
....................   char i1; 
....................   receive_flag=0; 
*
3A28:  BCF    x9F.1
....................   t1=0; 
3A2A:  MOVLB  3
3A2C:  CLRF   x7D
3A2E:  CLRF   x7C
3A30:  CLRF   x7B
3A32:  CLRF   x7A
....................   for (;;)  
....................   { 
....................      if(end_receive) 
3A34:  MOVLB  0
3A36:  BTFSS  x9F.2
3A38:  BRA    3A9C
....................      { 
....................        if(buffer[1]=='+') 
3A3A:  MOVLB  1
3A3C:  MOVF   xC9,W
3A3E:  SUBLW  2B
3A40:  BNZ   3A96
....................        { 
....................          for(i1=0;i1<10;i1++) tel_n0[i1]=buffer[i1+9]; 
3A42:  MOVLB  3
3A44:  CLRF   x7E
3A46:  MOVF   x7E,W
3A48:  SUBLW  09
3A4A:  BNC   3A84
3A4C:  CLRF   03
3A4E:  MOVF   x7E,W
3A50:  ADDWF  x78,W
3A52:  MOVWF  01
3A54:  MOVF   x79,W
3A56:  ADDWFC 03,F
3A58:  MOVFF  01,37F
3A5C:  MOVFF  03,380
3A60:  MOVLW  09
3A62:  ADDWF  x7E,W
3A64:  CLRF   03
3A66:  ADDLW  C8
3A68:  MOVWF  FE9
3A6A:  MOVLW  01
3A6C:  ADDWFC 03,W
3A6E:  MOVWF  FEA
3A70:  MOVFF  FEF,381
3A74:  MOVFF  380,FEA
3A78:  MOVFF  01,FE9
3A7C:  MOVFF  381,FEF
3A80:  INCF   x7E,F
3A82:  BRA    3A46
....................          tel_n0[i1]='\0'; 
3A84:  CLRF   03
3A86:  MOVF   x7E,W
3A88:  ADDWF  x78,W
3A8A:  MOVWF  FE9
3A8C:  MOVF   x79,W
3A8E:  ADDWFC 03,W
3A90:  MOVWF  FEA
3A92:  CLRF   FEF
3A94:  MOVLB  1
....................        } 
....................        //fprintf(DEBUG,"s0= %s\n\r",buffer); 
....................        end_receive=0; 
3A96:  MOVLB  0
3A98:  BCF    x9F.2
....................      } 
3A9A:  BRA    3ADA
....................      else 
....................      { 
....................          delay_ms(1); 
3A9C:  MOVLW  01
3A9E:  MOVLB  3
3AA0:  MOVWF  x8C
3AA2:  MOVLB  0
3AA4:  CALL   1750
....................          t1++; 
3AA8:  MOVLW  01
3AAA:  MOVLB  3
3AAC:  ADDWF  x7A,F
3AAE:  BTFSC  FD8.0
3AB0:  INCF   x7B,F
3AB2:  BTFSC  FD8.2
3AB4:  INCF   x7C,F
3AB6:  BTFSC  FD8.2
3AB8:  INCF   x7D,F
....................          if(t1>5000) return(0); 
3ABA:  MOVF   x7D,F
3ABC:  BNZ   3AD2
3ABE:  MOVF   x7C,F
3AC0:  BNZ   3AD2
3AC2:  MOVF   x7B,W
3AC4:  SUBLW  12
3AC6:  BC    3AD8
3AC8:  XORLW  FF
3ACA:  BNZ   3AD2
3ACC:  MOVF   x7A,W
3ACE:  SUBLW  88
3AD0:  BC    3AD8
3AD2:  MOVLW  00
3AD4:  MOVWF  01
3AD6:  BRA    3ADE
3AD8:  MOVLB  0
....................      } 
3ADA:  BRA    3A36
3ADC:  MOVLB  3
....................     }  
3ADE:  MOVLB  0
3AE0:  GOTO   4BCC (RETURN)
.................... } 
.................... //------------------------------------------------------------------------------ 
.................... int get_sms_n(char *tel_n0) 
*
345C:  MOVLW  3C
345E:  MOVLB  3
3460:  MOVWF  x80
3462:  MOVWF  x81
.................... { 
....................    
....................   int32 t1; 
....................   char i1,i0,n_start=60,n_end=60; 
....................  // fprintf(DEBUG,"get_sms_n start\r\n") ; 
....................   receive_flag=0; 
3464:  MOVLB  0
3466:  BCF    x9F.1
....................   if(end_receive) 
3468:  BTFSS  x9F.2
346A:  BRA    3576
....................   { 
....................      for(i0=0;i0<sms_buff_l;i0++) 
346C:  MOVLB  3
346E:  CLRF   x7F
3470:  MOVLB  0
3472:  MOVF   xDF,W
3474:  MOVLB  3
3476:  SUBWF  x7F,W
3478:  BTFSC  FD8.0
347A:  BRA    3570
....................      { 
....................        if(sms_buffer[i0]=='+') 
347C:  CLRF   03
347E:  MOVF   x7F,W
3480:  ADDLW  28
3482:  MOVWF  FE9
3484:  MOVLW  02
3486:  ADDWFC 03,W
3488:  MOVWF  FEA
348A:  MOVF   FEF,W
348C:  SUBLW  2B
348E:  BNZ   34D8
....................        { 
....................           if((sms_buffer[i0+2]=='M') &&(sms_buffer[i0+3]=='G')&&(sms_buffer[i0+4]=='R')) 
3490:  MOVLW  02
3492:  ADDWF  x7F,W
3494:  CLRF   03
3496:  ADDLW  28
3498:  MOVWF  FE9
349A:  MOVLW  02
349C:  ADDWFC 03,W
349E:  MOVWF  FEA
34A0:  MOVF   FEF,W
34A2:  SUBLW  4D
34A4:  BNZ   34D8
34A6:  MOVLW  03
34A8:  ADDWF  x7F,W
34AA:  CLRF   03
34AC:  ADDLW  28
34AE:  MOVWF  FE9
34B0:  MOVLW  02
34B2:  ADDWFC 03,W
34B4:  MOVWF  FEA
34B6:  MOVF   FEF,W
34B8:  SUBLW  47
34BA:  BNZ   34D8
34BC:  MOVLW  04
34BE:  ADDWF  x7F,W
34C0:  CLRF   03
34C2:  ADDLW  28
34C4:  MOVWF  FE9
34C6:  MOVLW  02
34C8:  ADDWFC 03,W
34CA:  MOVWF  FEA
34CC:  MOVF   FEF,W
34CE:  SUBLW  52
34D0:  BNZ   34D8
....................           { 
....................              suit_flag=1; 
34D2:  MOVLB  0
34D4:  BSF    xA0.1
34D6:  MOVLB  3
....................               
....................           } 
....................        } 
....................        if(suit_flag) 
34D8:  MOVLB  0
34DA:  BTFSS  xA0.1
34DC:  BRA    356A
....................        { 
....................             //fprintf(DEBUG,"l=%d i0=%d\n\r",sms_buff_l,i0); 
....................             if(sms_buffer[i0]==',') 
34DE:  CLRF   03
34E0:  MOVLB  3
34E2:  MOVF   x7F,W
34E4:  ADDLW  28
34E6:  MOVWF  FE9
34E8:  MOVLW  02
34EA:  ADDWFC 03,W
34EC:  MOVWF  FEA
34EE:  MOVF   FEF,W
34F0:  SUBLW  2C
34F2:  BNZ   3500
....................             { 
....................                n_start=i0+6; 
34F4:  MOVLW  06
34F6:  ADDWF  x7F,W
34F8:  MOVWF  x80
....................                n_end=i0+14; 
34FA:  MOVLW  0E
34FC:  ADDWF  x7F,W
34FE:  MOVWF  x81
....................                //fprintf(DEBUG,"start=%d end=%d \n\r",n_start,n_end); 
....................                 
....................             } 
....................             if(i0>n_start-1) 
3500:  MOVLW  01
3502:  SUBWF  x80,W
3504:  SUBWF  x7F,W
3506:  BZ    353C
3508:  BNC   353C
....................             { 
....................                 tel_n0[i0-n_start+1]=sms_buffer[i0];  
350A:  MOVF   x80,W
350C:  SUBWF  x7F,W
350E:  ADDLW  01
3510:  CLRF   03
3512:  ADDWF  x78,W
3514:  MOVWF  01
3516:  MOVF   x79,W
3518:  ADDWFC 03,F
351A:  MOVFF  03,383
351E:  CLRF   03
3520:  MOVF   x7F,W
3522:  ADDLW  28
3524:  MOVWF  FE9
3526:  MOVLW  02
3528:  ADDWFC 03,W
352A:  MOVWF  FEA
352C:  MOVFF  FEF,384
3530:  MOVFF  383,FEA
3534:  MOVFF  01,FE9
3538:  MOVFF  384,FEF
....................             } 
....................             if(i0>n_end) 
353C:  MOVF   x7F,W
353E:  SUBWF  x81,W
3540:  BC    3568
....................             { 
....................                tel_n0[0]='0'; 
3542:  MOVFF  378,FE9
3546:  MOVFF  379,FEA
354A:  MOVLW  30
354C:  MOVWF  FEF
....................                tel_n0[i0-n_start+1]='\0'; 
354E:  MOVF   x80,W
3550:  SUBWF  x7F,W
3552:  ADDLW  01
3554:  CLRF   03
3556:  ADDWF  x78,W
3558:  MOVWF  FE9
355A:  MOVF   x79,W
355C:  ADDWFC 03,W
355E:  MOVWF  FEA
3560:  CLRF   FEF
....................               // fprintf(DEBUG,"s0= %s\n\r",tel_n0);  
....................               // fprintf(DEBUG,"get_sms_n end:1\r\n"); 
....................                return 1; 
3562:  MOVLW  01
3564:  MOVWF  01
3566:  BRA    35AC
3568:  MOVLB  0
....................             } 
....................        } 
356A:  MOVLB  3
356C:  INCF   x7F,F
356E:  BRA    3470
....................      } 
....................     // fprintf(DEBUG,"s0= %s\n\r",tel_n0); 
....................      end_receive=0; 
3570:  MOVLB  0
3572:  BCF    x9F.2
....................   } 
3574:  BRA    35AC
....................   else 
....................   { 
....................       delay_ms(1); 
3576:  MOVLW  01
3578:  MOVLB  3
357A:  MOVWF  x8C
357C:  MOVLB  0
357E:  CALL   1750
....................       t1++; 
3582:  MOVLW  01
3584:  MOVLB  3
3586:  ADDWF  x7A,F
3588:  BTFSC  FD8.0
358A:  INCF   x7B,F
358C:  BTFSC  FD8.2
358E:  INCF   x7C,F
3590:  BTFSC  FD8.2
3592:  INCF   x7D,F
....................       if(t1>5000); 
3594:  MOVF   x7D,F
3596:  BNZ   35AC
3598:  MOVF   x7C,F
359A:  BNZ   35AC
359C:  MOVF   x7B,W
359E:  SUBLW  12
35A0:  BC    35AC
35A2:  XORLW  FF
35A4:  BNZ   35AC
35A6:  MOVF   x7A,W
35A8:  SUBLW  88
35AA:  BNC   35AC
35AC:  MOVLB  0
....................   } 
35AE:  GOTO   4728 (RETURN)
....................   // fprintf(DEBUG,"get_sms_n end :0\r\n");     
.................... } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... int read_new_sms() 
.................... { 
....................    fprintf(GSM,"AT+CMGR=1\r\n"); 
....................    get_ring_n(tel_n1); 
....................     
....................    delay_ms(1000);  
....................    fprintf(GSM,"AT+CMGD=1\r\n"); 
....................    return 0; 
....................     
.................... } 
.................... //------------------------------------------------------------------------------ 
.................... int get_pass_word(char *pass_tmp) 
.................... { 
....................    int s0; 
....................    for(s0=2;(sms_buffer0[s0]!='#')&&(s0<18);s0++) 
35B2:  MOVLW  02
35B4:  MOVLB  3
35B6:  MOVWF  x7A
35B8:  CLRF   03
35BA:  MOVF   x7A,W
35BC:  ADDLW  08
35BE:  MOVWF  FE9
35C0:  MOVLW  02
35C2:  ADDWFC 03,W
35C4:  MOVWF  FEA
35C6:  MOVF   FEF,W
35C8:  SUBLW  23
35CA:  BZ    3606
35CC:  MOVF   x7A,W
35CE:  SUBLW  11
35D0:  BNC   3606
....................    { 
....................       pass_tmp[s0-2]=sms_buffer0[s0]; 
35D2:  MOVLW  02
35D4:  SUBWF  x7A,W
35D6:  CLRF   03
35D8:  ADDWF  x78,W
35DA:  MOVWF  01
35DC:  MOVF   x79,W
35DE:  ADDWFC 03,F
35E0:  MOVFF  03,37C
35E4:  CLRF   03
35E6:  MOVF   x7A,W
35E8:  ADDLW  08
35EA:  MOVWF  FE9
35EC:  MOVLW  02
35EE:  ADDWFC 03,W
35F0:  MOVWF  FEA
35F2:  MOVFF  FEF,37D
35F6:  MOVFF  37C,FEA
35FA:  MOVFF  01,FE9
35FE:  MOVFF  37D,FEF
3602:  INCF   x7A,F
3604:  BRA    35B8
....................        
....................    } 
....................    nl0=s0-2; 
3606:  MOVLW  02
3608:  SUBWF  x7A,W
360A:  MOVLB  0
360C:  MOVWF  xE0
....................    return 0; 
360E:  MOVLW  00
3610:  MOVWF  01
3612:  GOTO   484C (RETURN)
.................... } 
.................... //------------------------------------------------------------------------------ 
.................... void save_pass_word() 
*
3918:  MOVLB  3
391A:  CLRF   x7A
.................... { 
....................    int s0,nl,nl0=0; 
....................     
....................    nl=read_eeprom(pass_add); 
391C:  MOVFF  FF2,37B
3920:  BCF    FF2.7
3922:  MOVLW  28
3924:  MOVWF  FA9
3926:  BCF    FA6.6
3928:  BCF    FA6.7
392A:  BSF    FA6.0
392C:  MOVF   FA8,W
392E:  BTFSC  x7B.7
3930:  BSF    FF2.7
3932:  MOVWF  x79
....................    for(s0=3+nl;(sms_buffer0[s0]!='#')&&(s0<32);s0++) 
3934:  MOVLW  03
3936:  ADDWF  x79,W
3938:  MOVWF  x78
393A:  CLRF   03
393C:  MOVF   x78,W
393E:  ADDLW  08
3940:  MOVWF  FE9
3942:  MOVLW  02
3944:  ADDWFC 03,W
3946:  MOVWF  FEA
3948:  MOVF   FEF,W
394A:  SUBLW  23
394C:  BZ    39A4
394E:  MOVF   x78,W
3950:  SUBLW  1F
3952:  BNC   39A4
....................    { 
....................       write_eeprom(pass_add+s0-2-nl,sms_buffer0[s0]); 
3954:  MOVLW  28
3956:  ADDWF  x78,W
3958:  ADDLW  FE
395A:  BSF    FD8.0
395C:  SUBFWB x79,W
395E:  MOVWF  x7B
3960:  CLRF   03
3962:  MOVF   x78,W
3964:  ADDLW  08
3966:  MOVWF  FE9
3968:  MOVLW  02
396A:  ADDWFC 03,W
396C:  MOVWF  FEA
396E:  MOVFF  FEF,37C
3972:  MOVF   FF2,W
3974:  MOVWF  00
3976:  BCF    FF2.7
3978:  MOVFF  37B,FA9
397C:  MOVFF  37C,FA8
3980:  BCF    FA6.6
3982:  BCF    FA6.7
3984:  BSF    FA6.2
3986:  MOVLB  F
3988:  MOVLW  55
398A:  MOVWF  FA7
398C:  MOVLW  AA
398E:  MOVWF  FA7
3990:  BSF    FA6.1
3992:  BTFSC  FA6.1
3994:  BRA    3992
3996:  BCF    FA6.2
3998:  MOVF   00,W
399A:  IORWF  FF2,F
....................       nl0++; 
399C:  MOVLB  3
399E:  INCF   x7A,F
39A0:  INCF   x78,F
39A2:  BRA    393A
....................        
....................    } 
....................    write_eeprom(pass_add,nl0); 
39A4:  MOVF   FF2,W
39A6:  MOVWF  00
39A8:  BCF    FF2.7
39AA:  MOVLW  28
39AC:  MOVWF  FA9
39AE:  MOVFF  37A,FA8
39B2:  BCF    FA6.6
39B4:  BCF    FA6.7
39B6:  BSF    FA6.2
39B8:  MOVLB  F
39BA:  MOVLW  55
39BC:  MOVWF  FA7
39BE:  MOVLW  AA
39C0:  MOVWF  FA7
39C2:  BSF    FA6.1
39C4:  BTFSC  FA6.1
39C6:  BRA    39C4
39C8:  BCF    FA6.2
39CA:  MOVF   00,W
39CC:  IORWF  FF2,F
39CE:  MOVLB  0
39D0:  GOTO   4AD4 (RETURN)
.................... } 
.................... //------------------------------------------------------------------------------ 
.................... int pass_word_ok() 
.................... { 
....................    char nl,s0,c0; 
....................    nl=read_eeprom(pass_add); 
*
3616:  MOVFF  FF2,37B
361A:  BCF    FF2.7
361C:  MOVLW  28
361E:  MOVWF  FA9
3620:  BCF    FA6.6
3622:  BCF    FA6.7
3624:  BSF    FA6.0
3626:  MOVF   FA8,W
3628:  MOVLB  3
362A:  BTFSC  x7B.7
362C:  BSF    FF2.7
362E:  MOVWF  x78
....................    if(nl0!=nl) return 0; 
3630:  MOVF   x78,W
3632:  MOVLB  0
3634:  SUBWF  xE0,W
3636:  BZ    363E
3638:  MOVLW  00
363A:  MOVWF  01
363C:  BRA    368E
....................    for(s0=0;s0<nl;s0++) 
363E:  MOVLB  3
3640:  CLRF   x79
3642:  MOVF   x78,W
3644:  SUBWF  x79,W
3646:  BC    368A
....................    { 
....................       c0=read_eeprom(pass_add+s0+1); 
3648:  MOVLW  28
364A:  ADDWF  x79,W
364C:  ADDLW  01
364E:  MOVWF  x7B
3650:  MOVFF  FF2,37C
3654:  BCF    FF2.7
3656:  MOVFF  37B,FA9
365A:  BCF    FA6.6
365C:  BCF    FA6.7
365E:  BSF    FA6.0
3660:  MOVF   FA8,W
3662:  BTFSC  x7C.7
3664:  BSF    FF2.7
3666:  MOVWF  x7A
....................       if(pass_word[s0]!=c0) 
3668:  CLRF   03
366A:  MOVF   x79,W
366C:  ADDLW  49
366E:  MOVWF  FE9
3670:  MOVLW  01
3672:  ADDWFC 03,W
3674:  MOVWF  FEA
3676:  MOVF   x7A,W
3678:  SUBWF  FEF,W
367A:  BZ    3686
....................       { 
....................          //fprintf(DEBUG,"pw %d :c0=%c p=%c\r\n",s0,c0,pass_word[s0]); 
....................          return(0); 
367C:  MOVLW  00
367E:  MOVWF  01
3680:  MOVLB  0
3682:  BRA    368E
3684:  MOVLB  3
....................           
....................       } 
3686:  INCF   x79,F
3688:  BRA    3642
....................         
....................    } 
....................    return(1); 
368A:  MOVLW  01
368C:  MOVWF  01
368E:  MOVLB  0
3690:  GOTO   4850 (RETURN)
....................     
....................     
.................... } 
.................... //------------------------------------------------------------------------------ 
.................... void read_sold_msg(char *msg) 
.................... { 
....................    int i1; 
....................    for(i1=0;i1<read_eeprom(sold_add);i1++) 
*
39D4:  MOVLB  3
39D6:  CLRF   x7A
39D8:  MOVFF  FF2,37B
39DC:  BCF    FF2.7
39DE:  MOVLW  32
39E0:  MOVWF  FA9
39E2:  BCF    FA6.6
39E4:  BCF    FA6.7
39E6:  BSF    FA6.0
39E8:  MOVF   FA8,W
39EA:  BTFSC  x7B.7
39EC:  BSF    FF2.7
39EE:  SUBWF  x7A,W
39F0:  BC    3A22
....................    { 
....................       msg[i1]=read_eeprom(sold_add+1+i1); 
39F2:  CLRF   03
39F4:  MOVF   x7A,W
39F6:  ADDWF  x78,W
39F8:  MOVWF  FE9
39FA:  MOVF   x79,W
39FC:  ADDWFC 03,W
39FE:  MOVWF  FEA
3A00:  MOVLW  33
3A02:  ADDWF  x7A,W
3A04:  MOVWF  x7D
3A06:  MOVFF  FF2,37E
3A0A:  BCF    FF2.7
3A0C:  MOVFF  37D,FA9
3A10:  BCF    FA6.6
3A12:  BCF    FA6.7
3A14:  BSF    FA6.0
3A16:  MOVF   FA8,W
3A18:  BTFSC  x7E.7
3A1A:  BSF    FF2.7
3A1C:  MOVWF  FEF
3A1E:  INCF   x7A,F
3A20:  BRA    39D8
....................    } 
3A22:  MOVLB  0
3A24:  GOTO   4A4C (RETURN)
.................... } 
.................... //------------------------------------------------------------------------------ 
.................... int16 get_sold_val() 
.................... { 
....................    int i1,i2; 
....................    start_ok=0; 
*
32F4:  BCF    xA0.6
....................    sold_val=0; 
32F6:  MOVLB  2
32F8:  CLRF   x88
32FA:  CLRF   x87
....................    for(i1=0;i1<sold_msg_l;i1++) 
32FC:  MOVLB  3
32FE:  CLRF   x78
3300:  MOVLB  2
3302:  MOVF   xA6,W
3304:  MOVLB  3
3306:  SUBWF  x78,W
3308:  BTFSC  FD8.0
330A:  BRA    3404
....................    { 
....................       if(buffer[i1]==':') start_ok=1; 
330C:  CLRF   03
330E:  MOVF   x78,W
3310:  ADDLW  C8
3312:  MOVWF  FE9
3314:  MOVLW  01
3316:  ADDWFC 03,W
3318:  MOVWF  FEA
331A:  MOVF   FEF,W
331C:  SUBLW  3A
331E:  BNZ   3326
3320:  MOVLB  0
3322:  BSF    xA0.6
3324:  MOVLB  3
....................       if((buffer[i1]>47)&&(buffer[i1]<58)&&(start_ok)) 
3326:  CLRF   03
3328:  MOVF   x78,W
332A:  ADDLW  C8
332C:  MOVWF  FE9
332E:  MOVLW  01
3330:  ADDWFC 03,W
3332:  MOVWF  FEA
3334:  MOVF   FEF,W
3336:  SUBLW  2F
3338:  BC    33EA
333A:  CLRF   03
333C:  MOVF   x78,W
333E:  ADDLW  C8
3340:  MOVWF  FE9
3342:  MOVLW  01
3344:  ADDWFC 03,W
3346:  MOVWF  FEA
3348:  MOVF   FEF,W
334A:  SUBLW  39
334C:  BNC   33EA
334E:  MOVLB  0
3350:  BTFSC  xA0.6
3352:  BRA    3358
3354:  MOVLB  3
3356:  BRA    33EA
....................       { 
....................          #ifdef DEBUG0 
....................          fprintf(DEBUG,"-%c-",buffer[i1]); 
3358:  CLRF   03
335A:  MOVLB  3
335C:  MOVF   x78,W
335E:  ADDLW  C8
3360:  MOVWF  FE9
3362:  MOVLW  01
3364:  ADDWFC 03,W
3366:  MOVWF  FEA
3368:  MOVFF  FEF,37A
336C:  CLRF   16
336E:  BTFSC  FF2.7
3370:  BSF    16.7
3372:  BCF    FF2.7
3374:  MOVLW  2D
3376:  MOVWF  xAE
3378:  MOVLB  0
337A:  CALL   0FDA
337E:  BTFSC  16.7
3380:  BSF    FF2.7
3382:  CLRF   16
3384:  BTFSC  FF2.7
3386:  BSF    16.7
3388:  BCF    FF2.7
338A:  MOVFF  37A,3AE
338E:  CALL   0FDA
3392:  BTFSC  16.7
3394:  BSF    FF2.7
3396:  CLRF   16
3398:  BTFSC  FF2.7
339A:  BSF    16.7
339C:  BCF    FF2.7
339E:  MOVLW  2D
33A0:  MOVLB  3
33A2:  MOVWF  xAE
33A4:  MOVLB  0
33A6:  CALL   0FDA
33AA:  BTFSC  16.7
33AC:  BSF    FF2.7
....................          #endif 
....................          sold_val=sold_val*10+(buffer[i1]-48); 
33AE:  MOVFF  288,397
33B2:  MOVFF  287,396
33B6:  MOVLB  3
33B8:  CLRF   x99
33BA:  MOVLW  0A
33BC:  MOVWF  x98
33BE:  MOVLB  0
33C0:  CALL   2728
33C4:  CLRF   03
33C6:  MOVLB  3
33C8:  MOVF   x78,W
33CA:  ADDLW  C8
33CC:  MOVWF  FE9
33CE:  MOVLW  01
33D0:  ADDWFC 03,W
33D2:  MOVWF  FEA
33D4:  MOVLW  30
33D6:  SUBWF  FEF,W
33D8:  ADDWF  01,W
33DA:  MOVLB  2
33DC:  MOVWF  x87
33DE:  MOVLW  00
33E0:  MOVLB  3
33E2:  ADDWFC 02,W
33E4:  MOVLB  2
33E6:  MOVWF  x88
33E8:  MOVLB  3
....................       } 
....................       if(buffer[i1]=='.') break; 
33EA:  CLRF   03
33EC:  MOVF   x78,W
33EE:  ADDLW  C8
33F0:  MOVWF  FE9
33F2:  MOVLW  01
33F4:  ADDWFC 03,W
33F6:  MOVWF  FEA
33F8:  MOVF   FEF,W
33FA:  SUBLW  2E
33FC:  BTFSC  FD8.2
33FE:  BRA    3404
3400:  INCF   x78,F
3402:  BRA    3300
....................    } 
....................    return(sold_val); 
3404:  MOVLB  2
3406:  MOVFF  287,01
340A:  MOVFF  288,02
340E:  BRA    3456
....................    #ifdef DEBUG0 
....................    fprintf(DEBUG,"%s\r\nSold= %ld DA\r\n",buffer,sold_val); 
3410:  MOVLW  01
3412:  MOVWF  FEA
3414:  MOVLW  C8
3416:  MOVWF  FE9
3418:  MOVLB  0
341A:  CALL   20AE
341E:  MOVLW  CA
3420:  MOVWF  FF6
3422:  MOVLW  03
3424:  MOVWF  FF7
3426:  MOVLW  08
3428:  MOVLB  3
342A:  MOVWF  x87
342C:  MOVLB  0
342E:  CALL   21D4
3432:  MOVLW  10
3434:  MOVWF  FE9
3436:  MOVFF  288,37B
343A:  MOVFF  287,37A
343E:  BRA    31F0
3440:  MOVLW  D5
3442:  MOVWF  FF6
3444:  MOVLW  03
3446:  MOVWF  FF7
3448:  MOVLW  05
344A:  MOVLB  3
344C:  MOVWF  x87
344E:  MOVLB  0
3450:  CALL   21D4
3454:  MOVLB  2
....................    #endif 
3456:  MOVLB  0
3458:  GOTO   4638 (RETURN)
.................... } 
.................... //****************************************************************************** 
.................... byte speed_cal(char s[3]) 
.................... {   
....................     
....................    byte p,s0; 
....................    //strcpy(s,"21.39"); 
....................    s0=0; 
*
38B4:  MOVLB  3
38B6:  CLRF   x7B
....................    p=0; 
38B8:  CLRF   x7A
....................    for(p=0;p<3;p++) 
38BA:  CLRF   x7A
38BC:  MOVF   x7A,W
38BE:  SUBLW  02
38C0:  BNC   3910
....................    { 
....................       if((s[p]>'0')&&(s[p]<'9')) 
38C2:  CLRF   03
38C4:  MOVF   x7A,W
38C6:  ADDWF  x78,W
38C8:  MOVWF  FE9
38CA:  MOVF   x79,W
38CC:  ADDWFC 03,W
38CE:  MOVWF  FEA
38D0:  MOVF   FEF,W
38D2:  SUBLW  30
38D4:  BC    390A
38D6:  CLRF   03
38D8:  MOVF   x7A,W
38DA:  ADDWF  x78,W
38DC:  MOVWF  FE9
38DE:  MOVF   x79,W
38E0:  ADDWFC 03,W
38E2:  MOVWF  FEA
38E4:  MOVF   FEF,W
38E6:  SUBLW  38
38E8:  BNC   390A
....................       { 
....................          s0=s0*10+(s[p]-48); 
38EA:  MOVF   x7B,W
38EC:  MULLW  0A
38EE:  MOVFF  FF3,37C
38F2:  CLRF   03
38F4:  MOVF   x7A,W
38F6:  ADDWF  x78,W
38F8:  MOVWF  FE9
38FA:  MOVF   x79,W
38FC:  ADDWFC 03,W
38FE:  MOVWF  FEA
3900:  MOVLW  30
3902:  SUBWF  FEF,W
3904:  ADDWF  x7C,W
3906:  MOVWF  x7B
....................          //fprintf(DEBUG,"sp=%d s0=%d\r\n",s[p],s0); 
....................       } else break; 
3908:  BRA    390C
390A:  BRA    3910
390C:  INCF   x7A,F
390E:  BRA    38BC
....................    } 
....................    return(s0); 
3910:  MOVFF  37B,01
3914:  MOVLB  0
3916:  RETURN 0
.................... } 
.................... //############################################################################### 
.................... void gps_dact() 
*
1838:  MOVLB  3
183A:  CLRF   x8E
.................... { 
....................    char str0[20],c0,c1=0,f; 
....................    strcpy(str0,"PSRF103,00,00,00,01"); 
183C:  MOVLW  03
183E:  MOVWF  FEA
1840:  MOVLW  79
1842:  MOVWF  FE9
1844:  MOVFF  FF2,390
1848:  BCF    FF2.7
184A:  MOVLW  00
184C:  MOVLB  0
184E:  CALL   00A2
1852:  TBLRD*-
1854:  TBLRD*+
1856:  MOVF   FF5,W
1858:  MOVWF  FEE
185A:  IORLW  00
185C:  BNZ   1854
185E:  MOVLB  3
1860:  BTFSC  x90.7
1862:  BSF    FF2.7
....................    for(f=0;f<6;f++) 
1864:  CLRF   x8F
1866:  MOVF   x8F,W
1868:  SUBLW  05
186A:  BNC   18D6
....................    { 
....................       c1=0; 
186C:  CLRF   x8E
....................       str0[9]='0'+f; 
186E:  MOVLW  30
1870:  ADDWF  x8F,W
1872:  MOVWF  x82
....................       for(c0=0;c0<19;c0++)  
1874:  CLRF   x8D
1876:  MOVF   x8D,W
1878:  SUBLW  12
187A:  BNC   1892
....................       { 
....................          c1^=str0[c0]; 
187C:  CLRF   03
187E:  MOVF   x8D,W
1880:  ADDLW  79
1882:  MOVWF  FE9
1884:  MOVLW  03
1886:  ADDWFC 03,W
1888:  MOVWF  FEA
188A:  MOVF   FEF,W
188C:  XORWF  x8E,F
188E:  INCF   x8D,F
1890:  BRA    1876
....................       } 
....................       fprintf(GPS_COM,"$%s*%x\r\n",str0,c1); 
1892:  MOVLW  24
1894:  MOVWF  xAB
1896:  MOVLB  0
1898:  RCALL  177A
189A:  MOVLW  03
189C:  MOVWF  FEA
189E:  MOVLW  79
18A0:  MOVWF  FE9
18A2:  RCALL  17CE
18A4:  MOVLW  2A
18A6:  MOVLB  3
18A8:  MOVWF  xAB
18AA:  MOVLB  0
18AC:  RCALL  177A
18AE:  MOVFF  38E,3A9
18B2:  MOVLW  57
18B4:  MOVLB  3
18B6:  MOVWF  xAA
18B8:  MOVLB  0
18BA:  RCALL  17F2
18BC:  MOVLW  0D
18BE:  MOVLB  3
18C0:  MOVWF  xAB
18C2:  MOVLB  0
18C4:  RCALL  177A
18C6:  MOVLW  0A
18C8:  MOVLB  3
18CA:  MOVWF  xAB
18CC:  MOVLB  0
18CE:  RCALL  177A
18D0:  MOVLB  3
18D2:  INCF   x8F,F
18D4:  BRA    1866
....................    } 
18D6:  MOVLB  0
18D8:  GOTO   194C (RETURN)
.................... } 
.................... //------------------------------------------------------------------------------ 
.................... void gps_act(char f)  
*
2596:  MOVLB  3
2598:  CLRF   xA8
.................... { 
....................    char str0[20],c0,c1=0; 
....................    strcpy(str0,"PSRF103,00,01,00,01"); 
259A:  MOVLW  03
259C:  MOVWF  FEA
259E:  MOVLW  93
25A0:  MOVWF  FE9
25A2:  MOVFF  FF2,3A9
25A6:  BCF    FF2.7
25A8:  MOVLW  00
25AA:  MOVLB  0
25AC:  CALL   00D0
25B0:  TBLRD*-
25B2:  TBLRD*+
25B4:  MOVF   FF5,W
25B6:  MOVWF  FEE
25B8:  IORLW  00
25BA:  BNZ   25B2
25BC:  MOVLB  3
25BE:  BTFSC  xA9.7
25C0:  BSF    FF2.7
....................    str0[9]='0'+f; 
25C2:  MOVLW  30
25C4:  ADDWF  x92,W
25C6:  MOVWF  x9C
....................    for(c0=0;c0<19;c0++)  
25C8:  CLRF   xA7
25CA:  MOVF   xA7,W
25CC:  SUBLW  12
25CE:  BNC   25E6
....................    { 
....................       c1^=str0[c0]; 
25D0:  CLRF   03
25D2:  MOVF   xA7,W
25D4:  ADDLW  93
25D6:  MOVWF  FE9
25D8:  MOVLW  03
25DA:  ADDWFC 03,W
25DC:  MOVWF  FEA
25DE:  MOVF   FEF,W
25E0:  XORWF  xA8,F
25E2:  INCF   xA7,F
25E4:  BRA    25CA
....................    } 
....................    fprintf(GPS_COM,"$%s*%x\r\n",str0,c1); 
25E6:  MOVLW  24
25E8:  MOVWF  xAB
25EA:  MOVLB  0
25EC:  CALL   177A
25F0:  MOVLW  03
25F2:  MOVWF  FEA
25F4:  MOVLW  93
25F6:  MOVWF  FE9
25F8:  CALL   17CE
25FC:  MOVLW  2A
25FE:  MOVLB  3
2600:  MOVWF  xAB
2602:  MOVLB  0
2604:  CALL   177A
2608:  MOVFF  3A8,3A9
260C:  MOVLW  57
260E:  MOVLB  3
2610:  MOVWF  xAA
2612:  MOVLB  0
2614:  CALL   17F2
2618:  MOVLW  0D
261A:  MOVLB  3
261C:  MOVWF  xAB
261E:  MOVLB  0
2620:  CALL   177A
2624:  MOVLW  0A
2626:  MOVLB  3
2628:  MOVWF  xAB
262A:  MOVLB  0
262C:  CALL   177A
2630:  GOTO   27B8 (RETURN)
.................... } 
.................... //------------------------------------------------------------------------------ 
.................... void init_GPS0() 
.................... { 
....................    int o; 
....................    for(o=0;o<15;o++)  
*
18DC:  MOVLB  3
18DE:  CLRF   x78
18E0:  MOVF   x78,W
18E2:  SUBLW  0E
18E4:  BNC   190A
....................    { 
....................       x[o]='\0'; 
18E6:  CLRF   03
18E8:  MOVF   x78,W
18EA:  ADDLW  A1
18EC:  MOVWF  FE9
18EE:  MOVLW  00
18F0:  ADDWFC 03,W
18F2:  MOVWF  FEA
18F4:  CLRF   FEF
....................       y[o]='\0'; 
18F6:  CLRF   03
18F8:  MOVF   x78,W
18FA:  ADDLW  B0
18FC:  MOVWF  FE9
18FE:  MOVLW  00
1900:  ADDWFC 03,W
1902:  MOVWF  FEA
1904:  CLRF   FEF
1906:  INCF   x78,F
1908:  BRA    18E0
....................    } 
....................    output_float(GPS_MRST); 
190A:  BSF    F92.4
....................    delay_ms(1000); 
190C:  MOVLW  04
190E:  MOVWF  x79
1910:  MOVLW  FA
1912:  MOVWF  x8C
1914:  MOVLB  0
1916:  RCALL  1750
1918:  MOVLB  3
191A:  DECFSZ x79,F
191C:  BRA    1910
....................    output_low(GPS_MRST); 
191E:  BCF    F92.4
1920:  BCF    F89.4
....................    delay_ms(1000); 
1922:  MOVLW  04
1924:  MOVWF  x79
1926:  MOVLW  FA
1928:  MOVWF  x8C
192A:  MOVLB  0
192C:  RCALL  1750
192E:  MOVLB  3
1930:  DECFSZ x79,F
1932:  BRA    1926
....................    output_float(GPS_MRST); 
1934:  BSF    F92.4
....................    delay_ms(1000); 
1936:  MOVLW  04
1938:  MOVWF  x79
193A:  MOVLW  FA
193C:  MOVWF  x8C
193E:  MOVLB  0
1940:  RCALL  1750
1942:  MOVLB  3
1944:  DECFSZ x79,F
1946:  BRA    193A
....................    gps_dact(); 
1948:  MOVLB  0
194A:  BRA    1838
194C:  GOTO   3C18 (RETURN)
....................     
.................... } 
.................... //------------------------------------------------------------------------------ 
.................... int get_gps_pos0() 
*
2790:  MOVLB  3
2792:  CLRF   x79
2794:  CLRF   x7A
.................... { 
....................    unsigned char pp=0,vergule_n_p=0,ZL,i,z_count; 
....................    unsigned int16 sx,sy,sx1,sx2,sy1,sy2;  
....................    char z0[8];  
....................    fprintf(DEBUG,"GPS GET POS"); 
2796:  MOVLW  DC
2798:  MOVWF  FF6
279A:  MOVLW  03
279C:  MOVWF  FF7
279E:  CLRF   16
27A0:  BTFSC  FF2.7
27A2:  BSF    16.7
27A4:  BCF    FF2.7
27A6:  MOVLB  0
27A8:  CALL   102C
27AC:  BTFSC  16.7
27AE:  BSF    FF2.7
....................    gps_act(0); 
27B0:  MOVLB  3
27B2:  CLRF   x92
27B4:  MOVLB  0
27B6:  BRA    2596
....................    do 
....................    { 
....................       w=fgetc(GPS_COM); 
27B8:  RCALL  2634
27BA:  MOVFF  01,1BD
....................       if(w==',') 
27BE:  MOVLB  1
27C0:  MOVF   xBD,W
27C2:  SUBLW  2C
27C4:  BNZ   27DE
....................       { 
....................          vergule_pos[vergule_n_p]=pp; 
27C6:  CLRF   03
27C8:  MOVLB  3
27CA:  MOVF   x7A,W
27CC:  ADDLW  2F
27CE:  MOVWF  FE9
27D0:  MOVLW  01
27D2:  ADDWFC 03,W
27D4:  MOVWF  FEA
27D6:  MOVFF  379,FEF
....................          vergule_n_p++; 
27DA:  INCF   x7A,F
27DC:  MOVLB  1
....................       } 
....................       if(pp<6) head[pp]=w; 
27DE:  MOVLB  3
27E0:  MOVF   x79,W
27E2:  SUBLW  05
27E4:  BNC   27F8
27E6:  CLRF   03
27E8:  MOVF   x79,W
27EA:  ADDLW  E8
27EC:  MOVWF  FE9
27EE:  MOVLW  00
27F0:  ADDWFC 03,W
27F2:  MOVWF  FEA
27F4:  MOVFF  1BD,FEF
....................       temp[pp]=w; 
27F8:  CLRF   03
27FA:  MOVF   x79,W
27FC:  ADDLW  59
27FE:  MOVWF  FE9
2800:  MOVLW  01
2802:  ADDWFC 03,W
2804:  MOVWF  FEA
2806:  MOVFF  1BD,FEF
....................       pp++; 
280A:  INCF   x79,F
....................      temp[pp]='\0';    
280C:  CLRF   03
280E:  MOVF   x79,W
2810:  ADDLW  59
2812:  MOVWF  FE9
2814:  MOVLW  01
2816:  ADDWFC 03,W
2818:  MOVWF  FEA
281A:  CLRF   FEF
....................    } 
....................    while(w!=13); 
281C:  MOVLB  1
281E:  MOVF   xBD,W
2820:  SUBLW  0D
2822:  BTFSC  FD8.2
2824:  BRA    282A
2826:  MOVLB  0
2828:  BRA    27B8
....................    w=fgetc(GPS_COM); 
282A:  MOVLB  0
282C:  RCALL  2634
282E:  MOVFF  01,1BD
2832:  CLRF   16
2834:  BTFSC  FF2.7
2836:  BSF    16.7
2838:  BCF    FF2.7
....................    fprintf(DEBUG,"=%s",temp); 
283A:  MOVLW  3D
283C:  MOVLB  3
283E:  MOVWF  xAE
2840:  MOVLB  0
2842:  CALL   0FDA
2846:  BTFSC  16.7
2848:  BSF    FF2.7
284A:  MOVLW  01
284C:  MOVWF  FEA
284E:  MOVLW  59
2850:  MOVWF  FE9
2852:  RCALL  20AE
....................    if(pp<70) return (0); 
2854:  MOVLB  3
2856:  MOVF   x79,W
2858:  SUBLW  45
285A:  BNC   2862
285C:  MOVLW  00
285E:  MOVWF  01
2860:  BRA    2D70
....................     
....................    strcpy(txt_test,"$GPGGA"); 
2862:  MOVLW  01
2864:  MOVWF  FEA
2866:  MOVLW  44
2868:  MOVWF  FE9
286A:  MOVFF  FF2,392
286E:  BCF    FF2.7
2870:  MOVLW  00
2872:  MOVLB  0
2874:  CALL   00FE
2878:  TBLRD*-
287A:  TBLRD*+
287C:  MOVF   FF5,W
287E:  MOVWF  FEE
2880:  IORLW  00
2882:  BNZ   287A
2884:  MOVLB  3
2886:  BTFSC  x92.7
2888:  BSF    FF2.7
....................    if((strncmp(head,txt_test,6))==0)  
288A:  CLRF   x93
288C:  MOVLW  E8
288E:  MOVWF  x92
2890:  MOVLW  01
2892:  MOVWF  x95
2894:  MOVLW  44
2896:  MOVWF  x94
2898:  CLRF   x97
289A:  MOVLW  06
289C:  MOVWF  x96
289E:  MOVLB  0
28A0:  RCALL  2692
28A2:  MOVF   01,F
28A4:  BTFSS  FD8.2
28A6:  BRA    2D6A
....................    {    
....................         for(j=0;j<(vergule_pos[2]-vergule_pos[1]);j++) x0[j]=temp[j+vergule_pos[1]+1]; 
28A8:  MOVLB  1
28AA:  CLRF   xC6
28AC:  MOVF   x30,W
28AE:  SUBWF  x31,W
28B0:  SUBWF  xC6,W
28B2:  BC    28F2
28B4:  CLRF   03
28B6:  MOVF   xC6,W
28B8:  ADDLW  BF
28BA:  MOVWF  01
28BC:  MOVLW  00
28BE:  ADDWFC 03,F
28C0:  MOVFF  01,392
28C4:  MOVFF  03,393
28C8:  MOVLB  1
28CA:  MOVF   x30,W
28CC:  ADDWF  xC6,W
28CE:  ADDLW  01
28D0:  CLRF   03
28D2:  ADDLW  59
28D4:  MOVWF  FE9
28D6:  MOVLW  01
28D8:  ADDWFC 03,W
28DA:  MOVWF  FEA
28DC:  MOVFF  FEF,394
28E0:  MOVFF  393,FEA
28E4:  MOVFF  01,FE9
28E8:  MOVFF  394,FEF
28EC:  MOVLB  1
28EE:  INCF   xC6,F
28F0:  BRA    28AC
....................         x0[j]=temp[vergule_pos[2]+1]; 
28F2:  CLRF   03
28F4:  MOVF   xC6,W
28F6:  ADDLW  BF
28F8:  MOVWF  01
28FA:  MOVLW  00
28FC:  ADDWFC 03,F
28FE:  MOVFF  03,393
2902:  MOVLW  01
2904:  MOVLB  1
2906:  ADDWF  x31,W
2908:  CLRF   03
290A:  ADDLW  59
290C:  MOVWF  FE9
290E:  MOVLW  01
2910:  ADDWFC 03,W
2912:  MOVWF  FEA
2914:  MOVFF  FEF,394
2918:  MOVLB  3
291A:  MOVFF  393,FEA
291E:  MOVFF  01,FE9
2922:  MOVFF  394,FEF
....................         x0[j+1]='\0'; 
2926:  MOVLW  01
2928:  MOVLB  1
292A:  ADDWF  xC6,W
292C:  CLRF   03
292E:  ADDLW  BF
2930:  MOVWF  FE9
2932:  MOVLW  00
2934:  ADDWFC 03,W
2936:  MOVWF  FEA
2938:  CLRF   FEF
....................         for(j=0;j<(vergule_pos[4]-vergule_pos[3]);j++) y0[j]=temp[j+vergule_pos[3]+1]; 
293A:  CLRF   xC6
293C:  MOVF   x32,W
293E:  SUBWF  x33,W
2940:  SUBWF  xC6,W
2942:  BC    2982
2944:  CLRF   03
2946:  MOVF   xC6,W
2948:  ADDLW  CE
294A:  MOVWF  01
294C:  MOVLW  00
294E:  ADDWFC 03,F
2950:  MOVFF  01,392
2954:  MOVFF  03,393
2958:  MOVLB  1
295A:  MOVF   x32,W
295C:  ADDWF  xC6,W
295E:  ADDLW  01
2960:  CLRF   03
2962:  ADDLW  59
2964:  MOVWF  FE9
2966:  MOVLW  01
2968:  ADDWFC 03,W
296A:  MOVWF  FEA
296C:  MOVFF  FEF,394
2970:  MOVFF  393,FEA
2974:  MOVFF  01,FE9
2978:  MOVFF  394,FEF
297C:  MOVLB  1
297E:  INCF   xC6,F
2980:  BRA    293C
....................         y0[j]=temp[vergule_pos[4]+1]; 
2982:  CLRF   03
2984:  MOVF   xC6,W
2986:  ADDLW  CE
2988:  MOVWF  01
298A:  MOVLW  00
298C:  ADDWFC 03,F
298E:  MOVFF  03,393
2992:  MOVLW  01
2994:  MOVLB  1
2996:  ADDWF  x33,W
2998:  CLRF   03
299A:  ADDLW  59
299C:  MOVWF  FE9
299E:  MOVLW  01
29A0:  ADDWFC 03,W
29A2:  MOVWF  FEA
29A4:  MOVFF  FEF,394
29A8:  MOVLB  3
29AA:  MOVFF  393,FEA
29AE:  MOVFF  01,FE9
29B2:  MOVFF  394,FEF
....................         y0[j+1]='\0'; 
29B6:  MOVLW  01
29B8:  MOVLB  1
29BA:  ADDWF  xC6,W
29BC:  CLRF   03
29BE:  ADDLW  CE
29C0:  MOVWF  FE9
29C2:  MOVLW  00
29C4:  ADDWFC 03,W
29C6:  MOVWF  FEA
29C8:  CLRF   FEF
....................         ok=1; 
29CA:  MOVLB  0
29CC:  BSF    x9F.3
....................                  
....................         y[0]=y0[0]; 
29CE:  MOVFF  CE,B0
....................         y[1]=y0[1]; 
29D2:  MOVFF  CF,B1
....................         y[2]=' '; 
29D6:  MOVLW  20
29D8:  MOVWF  xB2
....................         y[3]=y0[2]; 
29DA:  MOVFF  D0,B3
....................         y[4]=y0[3]; 
29DE:  MOVFF  D1,B4
....................         sx=((int16)(x0[5]-'0')*1000+(int16)(x0[6]-'0')*100+(int16)(x0[7]-'0')*10+(int16)(x0[8]-'0'))*6; 
29E2:  MOVLW  30
29E4:  SUBWF  xC4,W
29E6:  MOVLB  3
29E8:  CLRF   x93
29EA:  MOVWF  x92
29EC:  MOVFF  393,397
29F0:  MOVWF  x96
29F2:  MOVLW  03
29F4:  MOVWF  x99
29F6:  MOVLW  E8
29F8:  MOVWF  x98
29FA:  MOVLB  0
29FC:  RCALL  2728
29FE:  MOVFF  02,393
2A02:  MOVFF  01,392
2A06:  MOVLW  30
2A08:  SUBWF  xC5,W
2A0A:  MOVLB  3
2A0C:  CLRF   x95
2A0E:  MOVWF  x94
2A10:  MOVFF  395,397
2A14:  MOVWF  x96
2A16:  CLRF   x99
2A18:  MOVLW  64
2A1A:  MOVWF  x98
2A1C:  MOVLB  0
2A1E:  RCALL  2728
2A20:  MOVFF  02,03
2A24:  MOVF   01,W
2A26:  MOVLB  3
2A28:  ADDWF  x92,F
2A2A:  MOVF   02,W
2A2C:  ADDWFC x93,F
2A2E:  MOVLW  30
2A30:  MOVLB  0
2A32:  SUBWF  xC6,W
2A34:  MOVLB  3
2A36:  CLRF   x95
2A38:  MOVWF  x94
2A3A:  MOVFF  395,397
2A3E:  MOVWF  x96
2A40:  CLRF   x99
2A42:  MOVLW  0A
2A44:  MOVWF  x98
2A46:  MOVLB  0
2A48:  RCALL  2728
2A4A:  MOVFF  02,03
2A4E:  MOVF   01,W
2A50:  MOVLB  3
2A52:  ADDWF  x92,F
2A54:  MOVF   02,W
2A56:  ADDWFC x93,F
2A58:  MOVLW  30
2A5A:  MOVLB  0
2A5C:  SUBWF  xC7,W
2A5E:  CLRF   03
2A60:  MOVLB  3
2A62:  ADDWF  x92,F
2A64:  MOVF   03,W
2A66:  ADDWFC x93,F
2A68:  MOVFF  393,397
2A6C:  MOVFF  392,396
2A70:  CLRF   x99
2A72:  MOVLW  06
2A74:  MOVWF  x98
2A76:  MOVLB  0
2A78:  RCALL  2728
2A7A:  MOVFF  02,37F
2A7E:  MOVFF  01,37E
....................         sx1=sx/1000; 
2A82:  MOVFF  37F,395
2A86:  MOVFF  37E,394
2A8A:  MOVLW  03
2A8C:  MOVLB  3
2A8E:  MOVWF  x97
2A90:  MOVLW  E8
2A92:  MOVWF  x96
2A94:  MOVLB  0
2A96:  RCALL  274A
2A98:  MOVFF  02,383
2A9C:  MOVFF  01,382
....................         sx2=sx%1000; 
2AA0:  MOVFF  37F,395
2AA4:  MOVFF  37E,394
2AA8:  MOVLW  03
2AAA:  MOVLB  3
2AAC:  MOVWF  x97
2AAE:  MOVLW  E8
2AB0:  MOVWF  x96
2AB2:  MOVLB  0
2AB4:  RCALL  274A
2AB6:  MOVFF  00,384
2ABA:  MOVLB  3
2ABC:  MOVFF  03,385
....................         x[0]=x0[0]; 
2AC0:  MOVFF  BF,A1
....................         x[1]=x0[1]; 
2AC4:  MOVFF  C0,A2
....................         x[2]=' '; 
2AC8:  MOVLW  20
2ACA:  MOVLB  0
2ACC:  MOVWF  xA3
....................         x[3]=x0[2]; 
2ACE:  MOVFF  C1,A4
....................         x[4]=x0[3]; 
2AD2:  MOVFF  C2,A5
....................         x[5]=' '; 
2AD6:  MOVWF  xA6
....................         x[6]=(char)(sx1/10)+'0'; 
2AD8:  MOVFF  383,395
2ADC:  MOVFF  382,394
2AE0:  MOVLB  3
2AE2:  CLRF   x97
2AE4:  MOVLW  0A
2AE6:  MOVWF  x96
2AE8:  MOVLB  0
2AEA:  RCALL  274A
2AEC:  MOVLW  30
2AEE:  ADDWF  01,W
2AF0:  MOVWF  xA7
....................         x[7]=(char)(sx1%10)+'0'; 
2AF2:  MOVFF  383,395
2AF6:  MOVFF  382,394
2AFA:  MOVLB  3
2AFC:  CLRF   x97
2AFE:  MOVLW  0A
2B00:  MOVWF  x96
2B02:  MOVLB  0
2B04:  RCALL  274A
2B06:  MOVF   00,W
2B08:  ADDLW  30
2B0A:  MOVWF  xA8
....................         x[8]='.'; 
2B0C:  MOVLW  2E
2B0E:  MOVWF  xA9
....................         if(sx2>99) 
2B10:  MOVLB  3
2B12:  MOVF   x85,F
2B14:  BNZ   2B1C
2B16:  MOVF   x84,W
2B18:  SUBLW  63
2B1A:  BC    2B76
....................         { 
....................            x[9]=sx2/100+'0'; 
2B1C:  MOVFF  385,395
2B20:  MOVFF  384,394
2B24:  CLRF   x97
2B26:  MOVLW  64
2B28:  MOVWF  x96
2B2A:  MOVLB  0
2B2C:  RCALL  274A
2B2E:  MOVLW  30
2B30:  MOVLB  3
2B32:  ADDWF  01,W
2B34:  MOVLB  0
2B36:  MOVWF  xAA
....................            x[10]=(sx2%100)/10+'0'; 
2B38:  MOVFF  385,395
2B3C:  MOVFF  384,394
2B40:  MOVLB  3
2B42:  CLRF   x97
2B44:  MOVLW  64
2B46:  MOVWF  x96
2B48:  MOVLB  0
2B4A:  RCALL  274A
2B4C:  MOVFF  00,392
2B50:  MOVLB  3
2B52:  MOVFF  03,393
2B56:  MOVFF  03,395
2B5A:  MOVFF  00,394
2B5E:  CLRF   x97
2B60:  MOVLW  0A
2B62:  MOVWF  x96
2B64:  MOVLB  0
2B66:  RCALL  274A
2B68:  MOVLW  30
2B6A:  MOVLB  3
2B6C:  ADDWF  01,W
2B6E:  MOVLB  0
2B70:  MOVWF  xAB
....................         } 
2B72:  BRA    2B9A
2B74:  MOVLB  3
....................         else 
....................         { 
....................            x[9]='0'; 
2B76:  MOVLW  30
2B78:  MOVLB  0
2B7A:  MOVWF  xAA
....................            x[10]=sx2/10+'0'; 
2B7C:  MOVFF  385,395
2B80:  MOVFF  384,394
2B84:  MOVLB  3
2B86:  CLRF   x97
2B88:  MOVLW  0A
2B8A:  MOVWF  x96
2B8C:  MOVLB  0
2B8E:  RCALL  274A
2B90:  MOVLW  30
2B92:  MOVLB  3
2B94:  ADDWF  01,W
2B96:  MOVLB  0
2B98:  MOVWF  xAB
....................         } 
....................         x[11]=x0[10]; 
2B9A:  MOVFF  C9,AC
....................          
....................         sy=((int16)(y0[6]-'0')*1000+(int16)(y0[7]-'0')*100+(int16)(y0[8]-'0')*10+(int16)(y0[9]-'0'))*6; 
2B9E:  MOVLW  30
2BA0:  SUBWF  xD4,W
2BA2:  MOVLB  3
2BA4:  CLRF   x93
2BA6:  MOVWF  x92
2BA8:  MOVFF  393,397
2BAC:  MOVWF  x96
2BAE:  MOVLW  03
2BB0:  MOVWF  x99
2BB2:  MOVLW  E8
2BB4:  MOVWF  x98
2BB6:  MOVLB  0
2BB8:  RCALL  2728
2BBA:  MOVFF  02,393
2BBE:  MOVFF  01,392
2BC2:  MOVLW  30
2BC4:  SUBWF  xD5,W
2BC6:  MOVLB  3
2BC8:  CLRF   x95
2BCA:  MOVWF  x94
2BCC:  MOVFF  395,397
2BD0:  MOVWF  x96
2BD2:  CLRF   x99
2BD4:  MOVLW  64
2BD6:  MOVWF  x98
2BD8:  MOVLB  0
2BDA:  RCALL  2728
2BDC:  MOVFF  02,03
2BE0:  MOVF   01,W
2BE2:  MOVLB  3
2BE4:  ADDWF  x92,F
2BE6:  MOVF   02,W
2BE8:  ADDWFC x93,F
2BEA:  MOVLW  30
2BEC:  MOVLB  0
2BEE:  SUBWF  xD6,W
2BF0:  MOVLB  3
2BF2:  CLRF   x95
2BF4:  MOVWF  x94
2BF6:  MOVFF  395,397
2BFA:  MOVWF  x96
2BFC:  CLRF   x99
2BFE:  MOVLW  0A
2C00:  MOVWF  x98
2C02:  MOVLB  0
2C04:  RCALL  2728
2C06:  MOVFF  02,03
2C0A:  MOVF   01,W
2C0C:  MOVLB  3
2C0E:  ADDWF  x92,F
2C10:  MOVF   02,W
2C12:  ADDWFC x93,F
2C14:  MOVLW  30
2C16:  MOVLB  0
2C18:  SUBWF  xD7,W
2C1A:  CLRF   03
2C1C:  MOVLB  3
2C1E:  ADDWF  x92,F
2C20:  MOVF   03,W
2C22:  ADDWFC x93,F
2C24:  MOVFF  393,397
2C28:  MOVFF  392,396
2C2C:  CLRF   x99
2C2E:  MOVLW  06
2C30:  MOVWF  x98
2C32:  MOVLB  0
2C34:  RCALL  2728
2C36:  MOVFF  02,381
2C3A:  MOVFF  01,380
....................         sy1=sy/1000; 
2C3E:  MOVFF  381,395
2C42:  MOVFF  380,394
2C46:  MOVLW  03
2C48:  MOVLB  3
2C4A:  MOVWF  x97
2C4C:  MOVLW  E8
2C4E:  MOVWF  x96
2C50:  MOVLB  0
2C52:  RCALL  274A
2C54:  MOVFF  02,387
2C58:  MOVFF  01,386
....................         sy2=sy%1000; 
2C5C:  MOVFF  381,395
2C60:  MOVFF  380,394
2C64:  MOVLW  03
2C66:  MOVLB  3
2C68:  MOVWF  x97
2C6A:  MOVLW  E8
2C6C:  MOVWF  x96
2C6E:  MOVLB  0
2C70:  RCALL  274A
2C72:  MOVFF  00,388
2C76:  MOVLB  3
2C78:  MOVFF  03,389
....................         y[0]=y0[0]; 
2C7C:  MOVFF  CE,B0
....................         y[1]=y0[1]; 
2C80:  MOVFF  CF,B1
....................         y[2]=y0[2]; 
2C84:  MOVFF  D0,B2
....................         y[3]=' '; 
2C88:  MOVLW  20
2C8A:  MOVLB  0
2C8C:  MOVWF  xB3
....................         y[4]=y0[3]; 
2C8E:  MOVFF  D1,B4
....................         y[5]=y0[4]; 
2C92:  MOVFF  D2,B5
....................         y[6]=' '; 
2C96:  MOVWF  xB6
....................         y[7]=(char)(sy1/10)+'0'; 
2C98:  MOVFF  387,395
2C9C:  MOVFF  386,394
2CA0:  MOVLB  3
2CA2:  CLRF   x97
2CA4:  MOVLW  0A
2CA6:  MOVWF  x96
2CA8:  MOVLB  0
2CAA:  RCALL  274A
2CAC:  MOVLW  30
2CAE:  ADDWF  01,W
2CB0:  MOVWF  xB7
....................         y[8]=(char)(sy1%10)+'0'; 
2CB2:  MOVFF  387,395
2CB6:  MOVFF  386,394
2CBA:  MOVLB  3
2CBC:  CLRF   x97
2CBE:  MOVLW  0A
2CC0:  MOVWF  x96
2CC2:  MOVLB  0
2CC4:  RCALL  274A
2CC6:  MOVF   00,W
2CC8:  ADDLW  30
2CCA:  MOVWF  xB8
....................         y[9]='.'; 
2CCC:  MOVLW  2E
2CCE:  MOVWF  xB9
....................         if(sy2>99) 
2CD0:  MOVLB  3
2CD2:  MOVF   x89,F
2CD4:  BNZ   2CDC
2CD6:  MOVF   x88,W
2CD8:  SUBLW  63
2CDA:  BC    2D36
....................         { 
....................            y[10]=sy2/100+'0'; 
2CDC:  MOVFF  389,395
2CE0:  MOVFF  388,394
2CE4:  CLRF   x97
2CE6:  MOVLW  64
2CE8:  MOVWF  x96
2CEA:  MOVLB  0
2CEC:  RCALL  274A
2CEE:  MOVLW  30
2CF0:  MOVLB  3
2CF2:  ADDWF  01,W
2CF4:  MOVLB  0
2CF6:  MOVWF  xBA
....................            y[11]=(sy2%100)/10+'0'; 
2CF8:  MOVFF  389,395
2CFC:  MOVFF  388,394
2D00:  MOVLB  3
2D02:  CLRF   x97
2D04:  MOVLW  64
2D06:  MOVWF  x96
2D08:  MOVLB  0
2D0A:  RCALL  274A
2D0C:  MOVFF  00,392
2D10:  MOVLB  3
2D12:  MOVFF  03,393
2D16:  MOVFF  03,395
2D1A:  MOVFF  00,394
2D1E:  CLRF   x97
2D20:  MOVLW  0A
2D22:  MOVWF  x96
2D24:  MOVLB  0
2D26:  RCALL  274A
2D28:  MOVLW  30
2D2A:  MOVLB  3
2D2C:  ADDWF  01,W
2D2E:  MOVLB  0
2D30:  MOVWF  xBB
....................         } 
2D32:  BRA    2D5A
2D34:  MOVLB  3
....................         else 
....................         { 
....................            y[10]='0'; 
2D36:  MOVLW  30
2D38:  MOVLB  0
2D3A:  MOVWF  xBA
....................            y[11]=sy2/10+'0'; 
2D3C:  MOVFF  389,395
2D40:  MOVFF  388,394
2D44:  MOVLB  3
2D46:  CLRF   x97
2D48:  MOVLW  0A
2D4A:  MOVWF  x96
2D4C:  MOVLB  0
2D4E:  RCALL  274A
2D50:  MOVLW  30
2D52:  MOVLB  3
2D54:  ADDWF  01,W
2D56:  MOVLB  0
2D58:  MOVWF  xBB
....................         } 
....................         y[12]=y0[11]; 
2D5A:  MOVFF  D9,BC
....................         //fprintf(DEBUG,"x0=%s SX=%ld SX1=%ld SX2=%ld\r\n",x0,sx,sx1,sx2); 
....................         return pp; 
2D5E:  MOVLB  3
2D60:  MOVFF  379,01
2D64:  BRA    2D70
....................    } 
2D66:  BRA    2D70
2D68:  MOVLB  0
....................    else return 0;    
2D6A:  MOVLW  00
2D6C:  MOVWF  01
2D6E:  MOVLB  3
2D70:  MOVLB  0
2D72:  GOTO   2E18 (RETURN)
.................... } 
....................  
.................... /////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... #define USB_HID_DEVICE     FALSE             // deshabilitamos el uso de las directivas HID 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_BULK   // turn on EP1(EndPoint1) for IN bulk/interrupt transfers 
.................... #define USB_EP1_RX_ENABLE  USB_ENABLE_BULK   // turn on EP1(EndPoint1) for OUT bulk/interrupt transfers 
.................... #define USB_EP1_TX_SIZE    32                // size to allocate for the tx endpoint 1 buffer 
.................... #define USB_EP1_RX_SIZE    32                // size to allocate for the rx endpoint 1 buffer 
.................... #ifdef ALARME 
.................... #define USB_CON_SENSE_PIN PIN_B0 
.................... #else  
.................... #define USB_CON_SENSE_PIN PIN_B4 
.................... #endif 
....................  
.................... /////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... #include <pic18_usb.h>                      // Microchip PIC18Fxx5x Hardware layer for CCS's PIC USB driver 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.h                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC18 family chips.  Current //// 
.................... //// supported families are:                                         //// 
.................... ////     PIC18F2455/2550/4455/4550                                   //// 
.................... ////     PIC18F2450/4450                                             //// 
.................... ////     PIC18F2458/2553/4458/4553                                   //// 
.................... ////     PIC18F13K50/14K50                                           //// 
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     //// 
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       //// 
.................... ////     PIC18FxxK50                                                 //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      //// 
.................... //// that are specific to only this HW peripheral that you may       //// 
.................... //// find useful to use in your application.                         //// 
.................... ////                                                                 //// 
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    //// 
.................... ////  Due to the limited USB RAM of this family, a limitation of     //// 
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   //// 
.................... ////  The HW actually supports more endpoints, but to simplify       //// 
.................... ////  driver development this driver will only support the first 3   //// 
.................... ////  so there is an easier memory block to work with.               //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on Vusb, even if you are      //// 
.................... ////  using the internal 3.3V USB regulator.                         //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Feb 22, 2013:                                                   //// 
.................... ////  Added support for 18F45K50 family.                             //// 
.................... ////                                                                 //// 
.................... //// Dec 16, 2010:                                                   //// 
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_H__ 
.................... #DEFINE __PIC18_USB_H__ 
....................  
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   1 
.................... #endif 
....................  
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH 
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50")) 
....................    //due to limited ram, force max packet length to 8 for this chip 
....................    #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................    #if USB_USE_FULL_SPEED==0 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
.................... #endif 
....................  
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8)) 
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8 
....................  #error Max Endpoint 0 length can't be less than 8! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64 
....................  #error Max Endpoint 0 length can't be greater than 64! 
.................... #endif 
....................  
.................... #include <usb_hw_layer.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_hw_layer.h                            //// 
.................... ////                                                                   //// 
.................... //// HW Layer for the USB Stack.                                       //// 
.................... ////                                                                   //// 
.................... //// HW drivers for the USB stack must support this API.               //// 
.................... ////                                                                   //// 
.................... //// The HW driver must also have a token handler that will call       //// 
.................... //// usb_token_reset() when the device is init/reset, will call        //// 
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          //// 
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    //// 
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     //// 
.................... //// See usb.h for documentation of these functions.                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __USB_HW_LAYER_H__ 
.................... #define __USB_HW_LAYER_H__ 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
....................  
.................... // USER LEVEL FUNCTIONS: 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_cs(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt. 
.................... /*  
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* If the user does call this function while USB is connected, the USB  
.................... /* peripheral will be disabled only momentarily because usb_task() will 
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB 
.................... /* reset of the device. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_put_packet() 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to (0..15). 
.................... /*        ptr - points to data to send. 
.................... /*        len - amount of data to send. 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid,  
.................... /*                 or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only  
.................... /*         reason it will return FALSE is if because the TX buffer is still full  
.................... /*         from the last time it tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a  
.................... /*          difference between a packet and a message.  If you wanted to send a  
.................... /*          512 byte message on an endpoint that only supported 64 byte packets, 
.................... /*          this would be accomplished this by sending 8 64-byte packets,  
.................... /*          followed by a 0 length packet.  If the last (or only packet) being  
.................... /*          sent is less than the max packet size defined in your descriptor  
.................... /*          then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message  
.................... /*          correctly and know if a 0 lenght packet needs to be sent. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer and saved to ptr. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB endpoint buffer. 
.................... /*          Until this is called, if there is data in the receive buffer the 
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion 
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be 
.................... /*          allowed to send a new packet.  Only receives one packet, if you need  
.................... /*          to receive multiple packets or handle 0-length terminator packets, 
.................... /*          then use usb_gets(). 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max); 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check (0..15) 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /*          See API section of USB.H for more information. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_kbhit(unsigned int8 en); 
....................  
.................... /****************************************************************************** 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_tbe(unsigned int8 en); 
....................  
.................... //////////////// END USER LEVEL FUNCTIONS ///////////////////////////////////// 
....................  
....................  
.................... /// 
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by 
.................... ///            the USB stack, and are not meant to be called by the  
.................... ///            user/application. 
.................... /// 
....................  
.................... /***************************************************************************** 
.................... /* usb_stall_ep() 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will 
.................... /*          send STALL packet if the host tries to access this endpoint's  
.................... /*          buffer. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_stall_ep(unsigned int8 endpoint); 
....................  
....................  
.................... /***************************************************************************** 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_unstall_ep(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_endpoint_stalled() 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and  
.................... /*          Clear_Feature Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.   
.................... /*          The host will now talk to use with the following address. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_address(unsigned int8 address); 
....................  
.................... /****************************************************************************** 
.................... /* usb_set_configured() 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_configured(unsigned int8 config); 
....................  
.................... /****************************************************************************** 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints (all endpoints but 0) 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_disable_endpoints(void); 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoint() 
.................... /* 
.................... /* Input: Endpoint to disable (0..15) 
.................... /* 
.................... /* Summary: Disables specified endpoint 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoint(unsigned int8 en); 
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: One of these 3 functions will be called by the USB stack after 
.................... /*          handling a SETUP packet. 
.................... /*           
.................... /*          After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /*          The operation of these functions depends on how SETUP packets 
.................... /*          are handled in the hardware layer. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(unsigned int8 len); 
.................... void usb_request_get_data(void); 
.................... void usb_request_stall(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //////////////////////// EXTRA USER FUNCTIONS ///////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC). 
.................... /*          This routine is useful if you want to setup an endpoint by 
.................... /*          writing to the buffer directly. 
.................... /*          This routine is not necessary if you use usb_put_packet(). 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for release 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not 
.................... /*          want to use usb_get_packet(), instead you want to handle with 
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size(). 
.................... /*          This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_rx_packet_size() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark to check 
.................... /* 
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer. 
.................... /* 
.................... /* Summary: Read the number of data stored in the receive buffer.  When you 
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The 
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint. 
.................... /*    This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... int16 usb_rx_packet_size(int8 endpoint); 
....................  
.................... #ENDIF 
....................  
.................... //#include ".\include\rr2_USB_Monitor.h"      //  
.................... #include ".\include\EMNT_USB.h"               //  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          EMNT_USB.h                    //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      32 //config+interface+class+endpoint 
....................  
....................    //configuration descriptor 
....................    char const USB_CONFIG_DESC[] =  
....................    { 
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN,     //length of descriptor size 
....................          USB_DESC_CONFIG_TYPE,         //constant CONFIGURATION (0x02) 
....................          USB_TOTAL_CONFIG_LEN,0,  //size of all data returned for this config 
....................          1,      //number of interfaces this device supports 
....................          0x01,                //identifier for this configuration.  (IF we had more than one configurations) 
....................          0x00,                //index of string descriptor for this configuration 
....................          0xC0,                //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 reserved and bit7=1 
....................          0x32,                //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA) 
....................  
....................    //interface descriptor 0 alt 0 
....................          USB_DESC_INTERFACE_LEN,  //length of descriptor 
....................          USB_DESC_INTERFACE_TYPE,      //constant INTERFACE (0x04) 
....................          0x00,                //number defining this interface (IF we had more than one interface) 
....................          0x00,                //alternate setting 
....................          2,       //number of endpoints, not counting endpoint 0. 
....................          0xFF,                //class code, FF = vendor defined 
....................          0xFF,                //subclass code, FF = vendor 
....................          0xFF,                //protocol code, FF = vendor 
....................          0x00,                //index of string descriptor for interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor 
....................          USB_DESC_ENDPOINT_TYPE,     //constant ENDPOINT (0x05) 
....................          0x81,              //endpoint number and direction (0x81 = EP1 IN) 
....................          0x02,              //transfer type supported (0 is control, 1 is iso, 2 is bulk, 3 is interrupt) 
....................          USB_EP1_TX_SIZE,0x00,         //maximum packet size supported 
....................          0x01,              //polling interval in ms. (for interrupt transfers ONLY) 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor 
....................          USB_DESC_ENDPOINT_TYPE,     //constant ENDPOINT (0x05) 
....................          0x01,              //endpoint number and direction (0x01 = EP1 OUT) 
....................          0x02,              //transfer type supported (0 is control, 1 is iso, 2 is bulk, 3 is interrupt) 
....................          USB_EP1_RX_SIZE,0x00,         //maximum packet size supported 
....................          0x01,              //polling interval in ms. (for interrupt transfers ONLY) 
....................  
....................   }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //NOTE: DO TO A LIMITATION OF THE CCS CODE, ALL HID INTERFACES MUST START AT 0 AND BE SEQUENTIAL 
....................    //      FOR EXAMPLE, IF YOU HAVE 2 HID INTERFACES THEY MUST BE INTERFACE 0 AND INTERFACE 1 
....................    #define USB_NUM_HID_INTERFACES   0 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   1 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={1}; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    //device descriptor 
....................    char const USB_DEVICE_DESC[] = 
....................    { 
....................          USB_DESC_DEVICE_LEN,          //the length of this report 
....................          0x01,                //constant DEVICE (0x01) 
....................          0x10,0x01,           //usb version in bcd 
....................          0x00,                //class code (if 0, interface defines class.  FF is vendor defined) 
....................          0x00,                //subclass code 
....................          0x00,                //protocol code 
....................          USB_MAX_EP0_PACKET_LENGTH,   //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) 
....................          0x77,0x07,           //vendor id (0x0777 is EMNT) 
....................          0x84,0x50,           //product id 
....................          0x02,0x00,           //device release number 
....................          0x01,                //index of string description of manufacturer. therefore we point to string_1 array (see below) 
....................          0x02,                //index of string descriptor of the product 
....................          0x00,                //index of string descriptor of serial number 
....................          USB_NUM_CONFIGURATIONS   //number of possible configurations 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... //the offset of the starting location of each string. 
.................... //offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... const char USB_STRING_DESC_OFFSET[]={0,4,14}; 
....................  
.................... #define USB_STRING_DESC_COUNT sizeof(USB_STRING_DESC_OFFSET) 
....................  
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1 --> la compaia del producto ??? 
....................          10, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'E',0, 
....................          'M',0, 
....................          'N',0, 
....................        'T',0, 
....................    //string 2 --> nombre del dispositivo 
....................          40, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................        'E',0, 
....................          'M',0, 
....................          'N',0, 
....................        'T',0, 
....................        ' ',0, 
....................          'G',0, 
....................          'P',0, 
....................          'S',0, 
....................          '/',0, 
....................          'G',0, 
....................          'S',0, 
....................          'M',0, 
....................          ' ',0, 
....................        'S',0, 
....................        'y',0, 
....................          's',0, 
....................        't',0, 
....................        'e',0, 
....................          'm',0 
.................... }; 
....................  
....................  
.................... #ENDIF 
....................  
.................... #include <usb.c>                            // handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The functions that are meant to be     //// 
.................... //// called by the user (init, put packet, get packet, etc) are        //// 
.................... //// documented in USB.H.                                              //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must must provide the API as described in usb_hw_layer.h.         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// June 8th, 2011:                                                   //// 
.................... ////  Problem with usb_gets() and usb_puts() and specifying timeout=0  //// 
.................... ////     (for no timeout) resolved.                                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// November 13th, 2009:                                              //// 
.................... ////  usb_endpoint_is_valid() has an extra check.                      //// 
.................... ////                                                                   //// 
.................... //// June 9th, 2009:                                                   //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// Dec 14, 2007:                                                     //// 
.................... ////  usb_kbhit() moved to device driver.                              //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #if defined(__DO_DEBUG_USB) 
....................    #define debug_usb printf 
....................    void debug_putc(char c) {uart_putc(c);} 
....................    void debug_display_ram(unsigned int8 len, unsigned int8 *ptr) { 
....................       unsigned int8 max=16; 
....................       debug_usb(debug_putc,"[%U - ",len); 
....................       //if (max>len) {max=len;} 
....................       max = len; 
....................       while(max--) { 
....................          debug_usb(debug_putc,"%02X",*ptr); 
....................          len--; 
....................          ptr++; 
....................       } 
....................       if (len) {debug_usb(debug_putc,"...");} 
....................       debug_usb(debug_putc,"] "); 
....................    } 
.................... #else 
....................    #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................    #define debug_putc(c) 
....................    #define debug_display_ram(x,y) 
.................... #endif 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #if defined(__PIC16F_USB_H__) 
....................  #include <pic16f_usb.c> 
.................... #endif 
....................  
.................... #if defined(__PIC18_USB_H__) 
....................  #include <pic18_usb.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     //// 
.................... //// documentation about the PIC18 hardware layer.                   //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Feb 22, 2013:                                                   //// 
.................... ////  Added support for 18F45K50 family.                             //// 
.................... ////                                                                 //// 
.................... //// July 9th, 2012:                                                 //// 
.................... ////  Removed the clearing of the UOWN bit inside token done ISR     //// 
.................... ////     for non-setup packets on endpoint 0 or all other            //// 
.................... ////     endpoints.  This really only affects people using           //// 
.................... ////     usb_put_packet() or usb_get_packet() inside of other        //// 
.................... ////     interrupts.                                                 //// 
.................... ////                                                                 //// 
.................... //// Sep 22, 2011:                                                   //// 
.................... ////  Added USB_NO_ISR_PREPROCESSOR.  This is a rarely used option   //// 
.................... ////     primarily developed for users developing code where         //// 
.................... ////     usb_isr() is called by a #int_global instead of #int_usb.   //// 
.................... ////                                                                 //// 
.................... //// Dec 16, 2010:                                                   //// 
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           //// 
.................... ////                                                                 //// 
.................... //// Oct 15th, 2010:                                                 //// 
.................... ////  Added initial 18F47J53 family support.                         //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     //// 
.................... ////     will not be used.  usb_task() must be called periodically   //// 
.................... ////     in your main loop.  If it is not called faster than once    //// 
.................... ////     per millisecond, USB may not work.                          //// 
.................... ////                                                                 //// 
.................... //// Nov 13th, 2009:                                                 //// 
.................... ////  usb_disable_endpoint() won't touch BD status registers for     //// 
.................... ////     endpoints that aren't allocated.                            //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_C__ 
.................... #DEFINE __PIC18_USB_C__ 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #bit USBIE=getenv("BIT:USBIE") 
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \ 
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \ 
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \ 
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50")) 
....................  #define __USB_87J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F45K50") ||  \ 
....................        (getenv("DEVICE")=="PIC18F25K50") ||  \ 
....................        (getenv("DEVICE")=="PIC18F24K50")) 
....................  #define __USB_45K50__ 
....................  #define USB_TOTAL_RAM_SPACE  1024 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16  
....................  #define USB_PIC_NO_USB_GPIO  //D+ and D- are not shared with any GPIO 
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \ 
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \ 
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50")) 
....................  #define __USB_46J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450")) 
....................  #define __USB_4450__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || \ 
....................        (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50")) 
....................  #define __USB_K50__ //backwards compatability 
....................  #define __USB_14K50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100) 
....................  #define USB_RAM_START  0x200 
....................  #define USB_NUM_UEP 8 
....................  //technically this device supports 8 endpoints, but for RAM reasons you should 
....................  //attempt to only use the first 3 endpoints. 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \ 
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \ 
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \ 
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") \ 
....................        ) 
....................  #define __USB_4550__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F26J53") || (getenv("DEVICE")=="PIC18F27J53") || \ 
....................        (getenv("DEVICE")=="PIC18F46J53") || (getenv("DEVICE")=="PIC18F47J53") \ 
....................        ) 
....................  #define __USB_18FJ53__ 
....................  #define USB_TOTAL_RAM_SPACE  (0xE00) //0x000:0xDFF.  save 0x00:0xFF for compiler use 
....................  #define USB_BDT_START  0xD00 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library. 
.................... #endif 
....................  
.................... #if !defined(USB_BDT_START) 
.................... #define USB_BDT_START   USB_RAM_START 
.................... #endif 
....................  
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  15 
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  14 
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  13 
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  12 
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  11 
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  10 
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  9 
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  8 
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  7 
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  6 
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  5 
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  4 
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  3 
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  2 
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  1 
.................... #else 
....................  #define USB_LAST_DEFINED_ENDPOINT  0 
.................... #endif 
....................  
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8) 
....................  
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\ 
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\ 
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\ 
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\ 
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\ 
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\ 
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\ 
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\ 
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\ 
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\ 
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if defined(USB_RAM_START) 
....................    #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE) 
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle 
....................    #endif 
.................... #else 
....................    #if (USB_DATA_BUFFER_NEEDED > USB_TOTAL_RAM_SPACE) 
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle 
....................    #endif 
.................... #endif 
....................  
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT) 
....................  #error You are trying to use an invalid endpoint for this hardware! 
.................... #endif 
....................  
.................... #if defined(USB_RAM_START) 
.................... #define USB_DATA_BUFFER_LOCATION ((int16)USB_RAM_START+USB_CONTROL_REGISTER_SIZE) 
.................... #else 
.................... #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM) 
.................... #endif 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8 stat; 
....................    unsigned int8 cnt; 
....................    unsigned int16 addr; 
.................... } STRUCT_BD; 
....................  
.................... #if defined(USB_RAM_START) 
.................... struct 
.................... { 
....................    struct 
....................    { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
....................    } bd[USB_LAST_DEFINED_ENDPOINT+1]; 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... #locate g_USBRAM=USB_RAM_START 
.................... #define g_USBBDT g_USBRAM.bd 
.................... #else 
.................... struct 
.................... { 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... struct 
.................... { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
.................... } g_USBBDT[USB_LAST_DEFINED_ENDPOINT+1]; 
.................... #locate g_USBBDT=USB_BDT_START 
.................... #endif 
....................  
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer 
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer 
....................  
.................... //these buffer definitions needed for CDC library 
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer 
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer 
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer 
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #if !defined(USB_USE_ERROR_COUNTER) 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #if !defined(USB_PING_PONG_MODE) 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    unsigned int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #if defined(__USB_4550__) || defined(__USB_4450__) 
....................    #byte UFRML   =  0xF66 
....................    #byte UFRMH   =  0xF67 
....................    #byte UIR     =  0xF68 
....................    #byte UIE     =  0xF69 
....................    #byte UEIR    =  0xF6A 
....................    #byte UEIE    =  0xF6B 
....................    #byte U1STAT   =  0xF6C 
....................    #byte UCON    =  0xF6D 
....................    #byte UADDR   =  0xF6E 
....................    #byte UCFG    =  0xF6F 
....................    #define  UEP0_LOC 0xF70 
.................... #elif defined(__USB_46J50__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #elif defined(__USB_14K50__) 
....................    #byte UFRML   =  0xF5D 
....................    #byte UFRMH   =  0xF5E 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF60 
....................    #byte UEIR    =  0xF5F 
....................    #byte UEIE    =  0xF5B 
....................    #byte U1STAT   =  0xF63 
....................    #byte UCON    =  0xF64 
....................    #byte UADDR   =  0xF5C 
....................    #byte UCFG    =  0xF61 
....................    #define  UEP0_LOC 0xF53 
.................... #elif defined(__USB_18FJ53__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #else 
....................    #byte UFRML = getenv("SFR:UFRML") 
....................    #byte UFRMH = getenv("SFR:UFRMH") 
....................    #byte UIR = getenv("SFR:UIR") 
....................    #byte UIE = getenv("SFR:UIE") 
....................    #byte UEIR = getenv("SFR:UEIR") 
....................    #byte UEIE = getenv("SFR:UEIE") 
....................    #byte U1STAT = getenv("SFR:USTAT") 
....................    #byte UCON = getenv("SFR:UCON") 
....................    #byte UADDR = getenv("SFR:UADDR") 
....................    #byte UCFG = getenv("SFR:UCFG") 
.................... #endif 
....................  
.................... unsigned int8 USTATCopy; 
....................  
.................... unsigned int8 g_UEP[USB_NUM_UEP]; 
.................... #if defined(UEP0_LOC) 
.................... #locate g_UEP=UEP0_LOC 
.................... #else 
.................... #locate g_UEP=getenv("SFR:UEP0") 
.................... #endif 
.................... #define UEP(x) g_UEP[x] 
....................  
.................... #define BIT_SOF   6 
.................... #define BIT_STALL 5 
.................... #define BIT_IDLE  4 
.................... #define BIT_TRN   3 
.................... #define BIT_ACTV  2 
.................... #define BIT_UERR  1 
.................... #define BIT_URST  0 
....................  
.................... #BIT UIR_SOF = UIR.BIT_SOF 
.................... #BIT UIR_STALL = UIR.BIT_STALL 
.................... #BIT UIR_IDLE = UIR.BIT_IDLE 
.................... #BIT UIR_TRN = UIR.BIT_TRN 
.................... #BIT UIR_ACTV = UIR.BIT_ACTV 
.................... #BIT UIR_UERR = UIR.BIT_UERR 
.................... #BIT UIR_URST = UIR.BIT_URST 
....................  
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #bit UCON_PBRST=UCON.6 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    g_USBBDT[x].out.stat 
....................  #define EP_BDxCNT_O(x)   g_USBBDT[x].out.cnt 
....................  #define EP_BDxADR_O(x)   g_USBBDT[x].out.addr 
....................  #define EP_BDxST_I(x)    g_USBBDT[x].in.stat 
....................  #define EP_BDxCNT_I(x)   g_USBBDT[x].in.cnt 
....................  #define EP_BDxADR_I(x)   g_USBBDT[x].in.addr 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET 
.................... #else 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #if defined(__USB_4550__) 
....................  #define __USB_UCFG_UOEMON  0x40 
.................... #endif 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #if !defined(__USB_14K50__) 
....................  #define __USB_UCFG_UTRDIS  0x08 
.................... #endif 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if defined(USB_EXTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  0 
.................... #endif 
....................  
.................... #if defined(USB_INTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if !defined(__USB_UCFG_MY_UPUEN) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #if defined(__USB_UCFG_UTRDIS) 
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS 
.................... #else 
....................  #define __UCFG_VAL_DISABLED__   0 
.................... #endif 
....................  
....................  
.................... unsigned int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... #if defined(USB_ISR_POLLING) 
.................... void usb_isr(void); 
.................... #endif 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... // see usb_hw_layer.h for more documentation 
.................... int1 usb_kbhit(unsigned int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7))); 
*
1EBA:  CLRF   03
1EBC:  MOVLB  3
1EBE:  MOVF   x78,W
1EC0:  ADDLW  70
1EC2:  MOVWF  FE9
1EC4:  MOVLW  0F
1EC6:  ADDWFC 03,W
1EC8:  MOVWF  FEA
1ECA:  MOVF   FEF,F
1ECC:  BZ    1EE8
1ECE:  MOVF   x78,W
1ED0:  MULLW  08
1ED2:  MOVF   FF3,W
1ED4:  CLRF   x7A
1ED6:  MOVWF  x79
1ED8:  MOVWF  FE9
1EDA:  MOVLW  04
1EDC:  ADDWF  x7A,W
1EDE:  MOVWF  FEA
1EE0:  MOVFF  FEF,37B
1EE4:  BTFSS  x7B.7
1EE6:  BRA    1EEC
1EE8:  MOVLW  00
1EEA:  BRA    1EEE
1EEC:  MOVLW  01
1EEE:  MOVWF  01
1EF0:  MOVLB  0
1EF2:  GOTO   3D04 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_tbe(unsigned int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7))); 
*
0CA0:  CLRF   03
0CA2:  MOVLB  3
0CA4:  MOVF   xB4,W
0CA6:  ADDLW  70
0CA8:  MOVWF  FE9
0CAA:  MOVLW  0F
0CAC:  ADDWFC 03,W
0CAE:  MOVWF  FEA
0CB0:  MOVF   FEF,F
0CB2:  BZ    0CD8
0CB4:  MOVF   xB4,W
0CB6:  MULLW  08
0CB8:  MOVF   FF3,W
0CBA:  CLRF   xB6
0CBC:  MOVWF  xB5
0CBE:  MOVLW  04
0CC0:  ADDWF  xB5,F
0CC2:  MOVLW  00
0CC4:  ADDWFC xB6,F
0CC6:  MOVFF  3B5,FE9
0CCA:  MOVLW  04
0CCC:  ADDWF  xB6,W
0CCE:  MOVWF  FEA
0CD0:  MOVFF  FEF,3B7
0CD4:  BTFSS  xB7.7
0CD6:  BRA    0CDC
0CD8:  MOVLW  00
0CDA:  BRA    0CDE
0CDC:  MOVLW  01
0CDE:  MOVWF  01
0CE0:  MOVLB  0
0CE2:  RETURN 0
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_detach(void) 
.................... { 
....................    UCON = 0;  //disable USB hardware 
*
1E0E:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts 
1E10:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__; 
1E12:  MOVLW  08
1E14:  MOVWF  F6F
....................  
....................    // set D+/D- to inputs 
....................   #if defined(__USB_87J50__) 
....................    set_tris_f(get_tris_f() | 0x18); 
....................   #elif defined(__USB_14K50__) 
....................    set_tris_a(get_tris_a() | 0x3); 
....................   #elif !defined(USB_PIC_NO_USB_GPIO) 
....................    set_tris_c(get_tris_c() | 0x30); //pin_c4 and pin_c5 
1E16:  MOVF   F94,W
1E18:  IORLW  30
1E1A:  MOVLB  3
1E1C:  MOVWF  F94
....................   #endif 
....................    
....................    usb_state = USB_STATE_DETACHED; 
1E1E:  MOVLB  2
1E20:  CLRF   xC4
1E22:  CLRF   16
1E24:  BTFSC  FF2.7
1E26:  BSF    16.7
1E28:  BCF    FF2.7
....................     
....................    usb_token_reset();              //clear the chapter9 stack 
1E2A:  MOVLB  0
1E2C:  CALL   0502
1E30:  BTFSC  16.7
1E32:  BSF    FF2.7
1E34:  RETURN 0
....................    //__usb_kbhit_status=0; 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_attach(void)  
*
1E3C:  CLRF   16
1E3E:  BTFSC  FF2.7
1E40:  BSF    16.7
1E42:  BCF    FF2.7
.................... { 
....................    usb_token_reset(); 
1E44:  CALL   0502
1E48:  BTFSC  16.7
1E4A:  BSF    FF2.7
....................    UCON = 0; 
1E4C:  CLRF   F6D
....................    UCFG = __UCFG_VAL_ENABLED__; 
1E4E:  MOVLW  14
1E50:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts 
1E52:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus 
1E54:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
1E56:  MOVLW  01
1E58:  MOVLB  2
1E5A:  MOVWF  xC4
1E5C:  MOVLB  0
1E5E:  GOTO   1E6E (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init_cs(void) 
.................... { 
....................    usb_detach(); 
*
1E36:  RCALL  1E0E
1E38:  GOTO   1E98 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_task(void)  
.................... { 
....................   #if defined(USB_ISR_POLLING) 
....................    if (interrupt_active(INT_USB)) 
....................    { 
....................       usb_isr(); 
....................    } 
....................   #endif 
....................  
....................   #if defined(USB_CDC_DELAYED_FLUSH) 
....................    if (usb_enumerated()) 
....................    { 
....................       usb_cdc_flush_out_buffer(); 
....................    } 
....................   #endif 
....................  
....................    if (usb_attached())  
*
1E62:  BSF    F93.0
1E64:  BTFSS  F81.0
1E66:  BRA    1E70
....................    { 
....................       if (UCON_USBEN==0)  
1E68:  BTFSC  F6D.3
1E6A:  BRA    1E6E
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
1E6C:  BRA    1E3C
....................       } 
....................    } 
1E6E:  BRA    1E76
....................    else  
....................    { 
....................       if (UCON_USBEN==1)   
1E70:  BTFSS  F6D.3
1E72:  BRA    1E76
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
1E74:  RCALL  1E0E
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0))  
1E76:  MOVLB  2
1E78:  DECFSZ xC4,W
1E7A:  BRA    1E92
1E7C:  BTFSC  F6D.5
1E7E:  BRA    1E92
....................    { 
....................       UIR=0; 
1E80:  CLRF   F68
....................       UIE=0; 
1E82:  CLRF   F69
....................      #if !defined(USB_ISR_POLLING) 
....................       enable_interrupts(INT_USB); 
1E84:  BSF    FA0.5
....................       enable_interrupts(GLOBAL); 
1E86:  MOVLW  C0
1E88:  IORWF  FF2,F
....................      #endif 
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR 
1E8A:  MOVLW  11
1E8C:  MOVWF  F69
....................       usb_state=USB_STATE_POWERED; 
1E8E:  MOVLW  02
1E90:  MOVWF  xC4
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
1E92:  MOVLB  0
1E94:  RETURN 0
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init(void)  
.................... { 
....................    usb_init_cs(); 
1E96:  BRA    1E36
....................  
....................    do  
....................    { 
....................       usb_task(); 
1E98:  RCALL  1E62
....................    } while (usb_state != USB_STATE_POWERED); 
1E9A:  MOVLB  2
1E9C:  MOVF   xC4,W
1E9E:  SUBLW  02
1EA0:  BTFSC  FD8.2
1EA2:  BRA    1EA8
1EA4:  MOVLB  0
1EA6:  BRA    1E98
1EA8:  MOVLB  0
1EAA:  GOTO   3CC4 (RETURN)
.................... } 
....................  
....................  
.................... // see pic18_usb.h for documentation 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    if (usb_tbe(endpoint))  
*
0CE4:  MOVFF  3AF,3B4
0CE8:  RCALL  0CA0
0CEA:  MOVF   01,F
0CEC:  BZ    0DB8
....................    { 
....................       EP_BDxCNT_I(endpoint)=len; 
0CEE:  MOVLB  3
0CF0:  MOVF   xAF,W
0CF2:  MULLW  08
0CF4:  MOVF   FF3,W
0CF6:  CLRF   xB5
0CF8:  MOVWF  xB4
0CFA:  MOVLW  04
0CFC:  ADDWF  xB4,F
0CFE:  MOVLW  00
0D00:  ADDWFC xB5,F
0D02:  MOVLW  01
0D04:  ADDWF  xB4,W
0D06:  MOVWF  01
0D08:  MOVLW  00
0D0A:  ADDWFC xB5,W
0D0C:  MOVWF  03
0D0E:  MOVFF  01,FE9
0D12:  MOVLW  04
0D14:  ADDWF  03,W
0D16:  MOVWF  FEA
0D18:  MOVFF  3B0,FEF
....................  
....................       debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE)  
0D1C:  MOVF   xB2,W
0D1E:  SUBLW  02
0D20:  BNZ   0D50
....................       { 
....................          i = EP_BDxST_I(endpoint); 
0D22:  MOVF   xAF,W
0D24:  MULLW  08
0D26:  MOVF   FF3,W
0D28:  CLRF   xB5
0D2A:  MOVWF  xB4
0D2C:  MOVLW  04
0D2E:  ADDWF  xB4,F
0D30:  MOVLW  00
0D32:  ADDWFC xB5,F
0D34:  MOVFF  3B4,FE9
0D38:  MOVLW  04
0D3A:  ADDWF  xB5,W
0D3C:  MOVWF  FEA
0D3E:  MOVFF  FEF,3B3
....................          if (bit_test(i,6)) 
0D42:  BTFSS  xB3.6
0D44:  BRA    0D4A
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0D46:  CLRF   xB2
0D48:  BRA    0D4E
....................          else 
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0D4A:  MOVLW  01
0D4C:  MOVWF  xB2
....................       } 
0D4E:  BRA    0D76
....................       else if (tgl == USB_DTS_USERX)  
0D50:  MOVF   xB2,W
0D52:  SUBLW  04
0D54:  BNZ   0D76
....................       { 
....................          i = EP_BDxST_O(endpoint); 
0D56:  MOVF   xAF,W
0D58:  MULLW  08
0D5A:  MOVF   FF3,W
0D5C:  CLRF   xB5
0D5E:  MOVWF  FE9
0D60:  MOVLW  04
0D62:  ADDWF  xB5,W
0D64:  MOVWF  FEA
0D66:  MOVFF  FEF,3B3
....................          if (bit_test(i,6)) 
0D6A:  BTFSS  xB3.6
0D6C:  BRA    0D74
....................             tgl = USB_DTS_DATA1; 
0D6E:  MOVLW  01
0D70:  MOVWF  xB2
0D72:  BRA    0D76
....................          else 
....................             tgl = USB_DTS_DATA0; 
0D74:  CLRF   xB2
....................       } 
....................       if (tgl == USB_DTS_DATA1)  
0D76:  DECFSZ xB2,W
0D78:  BRA    0D80
....................          i=0xC8;  //DATA1, UOWN 
0D7A:  MOVLW  C8
0D7C:  MOVWF  xB3
0D7E:  BRA    0D84
....................       else //if (tgl == USB_DTS_DATA0)  
....................          i=0x88; //DATA0, UOWN 
0D80:  MOVLW  88
0D82:  MOVWF  xB3
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
0D84:  BTFSS  xB1.0
0D86:  BRA    0D8A
0D88:  BSF    xB3.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
0D8A:  BTFSS  xB1.1
0D8C:  BRA    0D90
0D8E:  BSF    xB3.1
....................  
....................       debug_usb(debug_putc, " %X", i); 
....................  
....................       EP_BDxST_I(endpoint) = i;//save changes 
0D90:  MOVF   xAF,W
0D92:  MULLW  08
0D94:  MOVF   FF3,W
0D96:  CLRF   xB5
0D98:  MOVWF  xB4
0D9A:  MOVLW  04
0D9C:  ADDWF  xB4,F
0D9E:  MOVLW  00
0DA0:  ADDWFC xB5,F
0DA2:  MOVFF  3B4,FE9
0DA6:  MOVLW  04
0DA8:  ADDWF  xB5,W
0DAA:  MOVWF  FEA
0DAC:  MOVFF  3B3,FEF
....................        
....................       //putc('!'); 
....................        
....................       return(1); 
0DB0:  MOVLW  01
0DB2:  MOVWF  01
0DB4:  BRA    0DBE
....................    } 
0DB6:  MOVLB  0
....................    else  
....................    { 
....................       //putc('_'); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................    return(0); 
0DB8:  MOVLW  00
0DBA:  MOVWF  01
0DBC:  MOVLB  3
0DBE:  MOVLB  0
0DC0:  RETURN 0
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl)  
*
2006:  CLRF   16
2008:  BTFSC  FF2.7
200A:  BSF    16.7
200C:  BCF    FF2.7
.................... { 
....................    unsigned int8 * buff_add;     
....................  
....................    if (usb_tbe(endpoint))  
200E:  MOVFF  378,3B4
2012:  CALL   0CA0
2016:  BTFSC  16.7
2018:  BSF    FF2.7
201A:  MOVF   01,F
201C:  BZ    20A8
....................    { 
....................       buff_add = EP_BDxADR_I(endpoint); 
201E:  MOVLB  3
2020:  MOVF   x78,W
2022:  MULLW  08
2024:  MOVF   FF3,W
2026:  CLRF   x81
2028:  MOVWF  x80
202A:  MOVLW  04
202C:  ADDWF  x80,F
202E:  MOVLW  00
2030:  ADDWFC x81,F
2032:  MOVLW  02
2034:  ADDWF  x80,W
2036:  MOVWF  01
2038:  MOVLW  00
203A:  ADDWFC x81,W
203C:  MOVWF  03
203E:  MOVFF  01,FE9
2042:  MOVLW  04
2044:  ADDWF  03,W
2046:  MOVWF  FEA
2048:  MOVFF  FEC,37F
204C:  MOVF   FED,F
204E:  MOVFF  FEF,37E
....................       memcpy(buff_add, ptr, len);      
2052:  MOVFF  37F,FEA
2056:  MOVFF  37E,FE9
205A:  MOVFF  37A,FE2
205E:  MOVFF  379,FE1
2062:  MOVFF  37C,02
2066:  MOVFF  37B,01
206A:  MOVF   01,F
206C:  BZ    2072
206E:  INCF   02,F
2070:  BRA    2076
2072:  MOVF   02,F
2074:  BZ    2082
2076:  MOVFF  FE6,FEE
207A:  DECFSZ 01,F
207C:  BRA    2076
207E:  DECFSZ 02,F
2080:  BRA    2076
2082:  CLRF   16
2084:  BTFSC  FF2.7
2086:  BSF    16.7
2088:  BCF    FF2.7
....................        
....................       return(usb_flush_in(endpoint, len, tgl)); 
208A:  MOVFF  378,3AF
208E:  MOVFF  37C,3B1
2092:  MOVFF  37B,3B0
2096:  MOVFF  37D,3B2
209A:  MOVLB  0
209C:  CALL   0CE4
20A0:  BTFSC  16.7
20A2:  BSF    FF2.7
20A4:  MOVF   01,W
20A6:  BRA    20AC
....................    } 
....................    else  
....................    { 
....................       //putc('-'); 
....................       //printf("%X", EP_BDxST_I(endpoint)); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................  
....................    return(0); 
20A8:  MOVLW  00
20AA:  MOVWF  01
20AC:  RETURN 0
.................... } 
....................  
.................... // see pic18_usb.h for documentation 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int16 len; 
....................  
....................   #if USB_IGNORE_RX_DTS 
....................    if (tgl == USB_DTS_STALL)  
....................    { 
....................       debug_usb(debug_putc, '*'); 
....................       EP_BDxCNT_O(endpoint) = 0x84; 
....................       EP_BDxST_I(endpoint) = 0x84; 
....................       return; 
....................    } 
....................    else 
....................       i=0x80; 
....................   #else 
....................    i = EP_BDxST_O(endpoint); 
*
0BD2:  MOVLB  3
0BD4:  MOVF   xAF,W
0BD6:  MULLW  08
0BD8:  MOVF   FF3,W
0BDA:  CLRF   xB5
0BDC:  MOVWF  FE9
0BDE:  MOVLW  04
0BE0:  ADDWF  xB5,W
0BE2:  MOVWF  FEA
0BE4:  MOVFF  FEF,3B1
....................    if (tgl == USB_DTS_TOGGLE)  
0BE8:  MOVF   xB0,W
0BEA:  SUBLW  02
0BEC:  BNZ   0BFA
....................    { 
....................       if (bit_test(i,6)) 
0BEE:  BTFSS  xB1.6
0BF0:  BRA    0BF6
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0BF2:  CLRF   xB0
0BF4:  BRA    0BFA
....................       else 
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0BF6:  MOVLW  01
0BF8:  MOVWF  xB0
....................    } 
....................    if (tgl == USB_DTS_STALL)  
0BFA:  MOVF   xB0,W
0BFC:  SUBLW  03
0BFE:  BNZ   0C26
....................    { 
....................       i = 0x84; 
0C00:  MOVLW  84
0C02:  MOVWF  xB1
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints 
0C04:  MOVF   xAF,W
0C06:  MULLW  08
0C08:  MOVF   FF3,W
0C0A:  CLRF   xB5
0C0C:  MOVWF  xB4
0C0E:  MOVLW  04
0C10:  ADDWF  xB4,F
0C12:  MOVLW  00
0C14:  ADDWFC xB5,F
0C16:  MOVFF  3B4,FE9
0C1A:  MOVLW  04
0C1C:  ADDWF  xB5,W
0C1E:  MOVWF  FEA
0C20:  MOVLW  84
0C22:  MOVWF  FEF
....................    } 
0C24:  BRA    0C34
....................    else if (tgl == USB_DTS_DATA1) 
0C26:  DECFSZ xB0,W
0C28:  BRA    0C30
....................       i = 0xC8;  //DATA1, UOWN 
0C2A:  MOVLW  C8
0C2C:  MOVWF  xB1
0C2E:  BRA    0C34
....................    else //if (tgl == USB_DTS_DATA0)  
....................       i = 0x88; //DATA0, UOWN 
0C30:  MOVLW  88
0C32:  MOVWF  xB1
....................   #endif 
....................  
....................    //bit_clear(__usb_kbhit_status,endpoint); 
....................  
....................    len = usb_ep_rx_size[endpoint]; 
0C34:  BCF    FD8.0
0C36:  RLCF   xAF,W
0C38:  CLRF   03
0C3A:  MOVFF  FF2,3B4
0C3E:  BCF    FF2.7
0C40:  MOVLB  0
0C42:  CALL   0140
0C46:  TBLRD*+
0C48:  MOVFF  FF5,03
0C4C:  MOVLB  3
0C4E:  BTFSC  xB4.7
0C50:  BSF    FF2.7
0C52:  MOVWF  xB2
0C54:  MOVFF  03,3B3
....................    EP_BDxCNT_O(endpoint) = len; 
0C58:  MOVF   xAF,W
0C5A:  MULLW  08
0C5C:  MOVF   FF3,W
0C5E:  CLRF   xB5
0C60:  MOVWF  xB4
0C62:  MOVLW  01
0C64:  ADDWF  xB4,W
0C66:  MOVWF  01
0C68:  MOVLW  00
0C6A:  ADDWFC xB5,W
0C6C:  MOVWF  03
0C6E:  MOVFF  01,FE9
0C72:  MOVLW  04
0C74:  ADDWF  03,W
0C76:  MOVWF  FEA
0C78:  MOVFF  3B2,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
0C7C:  BTFSS  xB3.0
0C7E:  BRA    0C82
0C80:  BSF    xB1.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
0C82:  BTFSS  xB3.1
0C84:  BRA    0C88
0C86:  BSF    xB1.1
....................  
....................    EP_BDxST_O(endpoint) = i; 
0C88:  MOVF   xAF,W
0C8A:  MULLW  08
0C8C:  MOVF   FF3,W
0C8E:  CLRF   xB5
0C90:  MOVWF  FE9
0C92:  MOVLW  04
0C94:  ADDWF  xB5,W
0C96:  MOVWF  FEA
0C98:  MOVFF  3B1,FEF
0C9C:  MOVLB  0
0C9E:  RETURN 0
.................... } 
....................  
.................... // see pic18_usb.h for documentation 
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint)  
.................... { 
....................    return(EP_BDxCNT_O(endpoint)); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB. 
....................  
.................... /***************************************************************************** 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC  
.................... /*          RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /*****************************************************************************/ 
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max)  
.................... { 
....................    unsigned int8 * al; 
....................    unsigned int8 st; 
....................    unsigned int16 i; 
....................  
....................    al = EP_BDxADR_O(endpoint); 
*
1EF6:  MOVLB  3
1EF8:  MOVF   x7D,W
1EFA:  MULLW  08
1EFC:  MOVF   FF3,W
1EFE:  CLRF   x88
1F00:  MOVWF  x87
1F02:  MOVLW  02
1F04:  ADDWF  x87,W
1F06:  MOVWF  01
1F08:  MOVLW  00
1F0A:  ADDWFC x88,W
1F0C:  MOVWF  03
1F0E:  MOVFF  01,FE9
1F12:  MOVLW  04
1F14:  ADDWF  03,W
1F16:  MOVWF  FEA
1F18:  MOVFF  FEC,383
1F1C:  MOVF   FED,F
1F1E:  MOVFF  FEF,382
....................    i = EP_BDxCNT_O(endpoint); 
1F22:  MOVF   x7D,W
1F24:  MULLW  08
1F26:  MOVF   FF3,W
1F28:  CLRF   x88
1F2A:  MOVWF  x87
1F2C:  MOVLW  01
1F2E:  ADDWF  x87,W
1F30:  MOVWF  01
1F32:  MOVLW  00
1F34:  ADDWFC x88,W
1F36:  MOVWF  03
1F38:  MOVFF  01,FE9
1F3C:  MOVLW  04
1F3E:  ADDWF  03,W
1F40:  MOVWF  FEA
1F42:  CLRF   x86
1F44:  MOVFF  FEF,385
....................    st = EP_BDxST_O(endpoint); 
1F48:  MOVF   x7D,W
1F4A:  MULLW  08
1F4C:  MOVF   FF3,W
1F4E:  CLRF   x88
1F50:  MOVWF  FE9
1F52:  MOVLW  04
1F54:  ADDWF  x88,W
1F56:  MOVWF  FEA
1F58:  MOVFF  FEF,384
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
1F5C:  BTFSS  x84.0
1F5E:  BRA    1F62
1F60:  BSF    x86.0
....................    if (bit_test(st,1)) {bit_set(i,9);} 
1F62:  BTFSS  x84.1
1F64:  BRA    1F68
1F66:  BSF    x86.1
....................  
....................    if (i < max) {max = i;} 
1F68:  MOVF   x86,W
1F6A:  SUBWF  x81,W
1F6C:  BNC   1F7E
1F6E:  BNZ   1F76
1F70:  MOVF   x80,W
1F72:  SUBWF  x85,W
1F74:  BC    1F7E
1F76:  MOVFF  386,381
1F7A:  MOVFF  385,380
....................     
....................    memcpy(ptr, al ,max); 
1F7E:  MOVFF  37F,FEA
1F82:  MOVFF  37E,FE9
1F86:  MOVFF  383,FE2
1F8A:  MOVFF  382,FE1
1F8E:  MOVFF  381,02
1F92:  MOVFF  380,01
1F96:  MOVF   01,F
1F98:  BZ    1F9E
1F9A:  INCF   02,F
1F9C:  BRA    1FA2
1F9E:  MOVF   02,F
1FA0:  BZ    1FAE
1FA2:  MOVFF  FE6,FEE
1FA6:  DECFSZ 01,F
1FA8:  BRA    1FA2
1FAA:  DECFSZ 02,F
1FAC:  BRA    1FA2
....................  
....................    return(max); 
1FAE:  MOVFF  380,01
1FB2:  MOVFF  381,02
1FB6:  MOVLB  0
1FB8:  GOTO   1FD2 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max) 
.................... { 
....................    max = usb_get_packet_buffer(endpoint, ptr, max); 
1FBC:  MOVFF  378,37D
1FC0:  MOVFF  37A,37F
1FC4:  MOVFF  379,37E
1FC8:  MOVFF  37C,381
1FCC:  MOVFF  37B,380
1FD0:  BRA    1EF6
1FD2:  MOVFF  02,37C
1FD6:  MOVFF  01,37B
1FDA:  CLRF   16
1FDC:  BTFSC  FF2.7
1FDE:  BSF    16.7
1FE0:  BCF    FF2.7
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
1FE2:  MOVFF  378,3AF
1FE6:  MOVLW  02
1FE8:  MOVLB  3
1FEA:  MOVWF  xB0
1FEC:  MOVLB  0
1FEE:  CALL   0BD2
1FF2:  BTFSC  16.7
1FF4:  BSF    FF2.7
....................  
....................    return(max); 
1FF6:  MOVLB  3
1FF8:  MOVFF  37B,01
1FFC:  MOVFF  37C,02
2000:  MOVLB  0
2002:  GOTO   3D40 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_stall_ep(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
0A98:  MOVLB  3
0A9A:  BCF    xB0.0
0A9C:  BTFSC  xAF.7
0A9E:  BSF    xB0.0
....................    endpoint &= 0x7F; 
0AA0:  BCF    xAF.7
....................     
....................    if (direction)  
0AA2:  BTFSS  xB0.0
0AA4:  BRA    0AC8
....................    { 
....................       EP_BDxST_I(endpoint) = 0x84; 
0AA6:  MOVF   xAF,W
0AA8:  MULLW  08
0AAA:  MOVF   FF3,W
0AAC:  CLRF   xB2
0AAE:  MOVWF  xB1
0AB0:  MOVLW  04
0AB2:  ADDWF  xB1,F
0AB4:  MOVLW  00
0AB6:  ADDWFC xB2,F
0AB8:  MOVFF  3B1,FE9
0ABC:  MOVLW  04
0ABE:  ADDWF  xB2,W
0AC0:  MOVWF  FEA
0AC2:  MOVLW  84
0AC4:  MOVWF  FEF
....................    } 
0AC6:  BRA    0ADC
....................    else  
....................    { 
....................       EP_BDxST_O(endpoint) = 0x84; 
0AC8:  MOVF   xAF,W
0ACA:  MULLW  08
0ACC:  MOVF   FF3,W
0ACE:  CLRF   xB2
0AD0:  MOVWF  FE9
0AD2:  MOVLW  04
0AD4:  ADDWF  xB2,W
0AD6:  MOVWF  FEA
0AD8:  MOVLW  84
0ADA:  MOVWF  FEF
....................    } 
0ADC:  MOVLB  0
0ADE:  GOTO   0B70 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_unstall_ep(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
0A50:  MOVLB  3
0A52:  BCF    xB0.0
0A54:  BTFSC  xAF.7
0A56:  BSF    xB0.0
....................    endpoint &= 0x7F; 
0A58:  BCF    xAF.7
....................     
....................    if (direction)  
0A5A:  BTFSS  xB0.0
0A5C:  BRA    0A80
....................    { 
....................      #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint) = 0x80; 
....................      #else 
....................       EP_BDxST_I(endpoint) = 0x88; 
0A5E:  MOVF   xAF,W
0A60:  MULLW  08
0A62:  MOVF   FF3,W
0A64:  CLRF   xB2
0A66:  MOVWF  xB1
0A68:  MOVLW  04
0A6A:  ADDWF  xB1,F
0A6C:  MOVLW  00
0A6E:  ADDWFC xB2,F
0A70:  MOVFF  3B1,FE9
0A74:  MOVLW  04
0A76:  ADDWF  xB2,W
0A78:  MOVWF  FEA
0A7A:  MOVLW  88
0A7C:  MOVWF  FEF
....................      #endif 
....................    } 
0A7E:  BRA    0A92
....................    else  
....................    { 
....................       EP_BDxST_O(endpoint) = 0x00; 
0A80:  MOVF   xAF,W
0A82:  MULLW  08
0A84:  MOVF   FF3,W
0A86:  CLRF   xB2
0A88:  MOVWF  FE9
0A8A:  MOVLW  04
0A8C:  ADDWF  xB2,W
0A8E:  MOVWF  FEA
0A90:  CLRF   FEF
....................    } 
0A92:  MOVLB  0
0A94:  GOTO   0B60 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................    unsigned int8 st; 
....................     
....................    direction = bit_test(endpoint,7); 
*
0AE2:  MOVLB  3
0AE4:  BCF    xB0.0
0AE6:  BTFSC  xAF.7
0AE8:  BSF    xB0.0
....................    endpoint &= 0x7F; 
0AEA:  BCF    xAF.7
....................     
....................    if (direction)  
0AEC:  BTFSS  xB0.0
0AEE:  BRA    0B12
....................    { 
....................       st=EP_BDxST_I(endpoint); 
0AF0:  MOVF   xAF,W
0AF2:  MULLW  08
0AF4:  MOVF   FF3,W
0AF6:  CLRF   xB3
0AF8:  MOVWF  xB2
0AFA:  MOVLW  04
0AFC:  ADDWF  xB2,F
0AFE:  MOVLW  00
0B00:  ADDWFC xB3,F
0B02:  MOVFF  3B2,FE9
0B06:  MOVLW  04
0B08:  ADDWF  xB3,W
0B0A:  MOVWF  FEA
0B0C:  MOVFF  FEF,3B1
....................    } 
0B10:  BRA    0B26
....................    else  
....................    { 
....................       st=EP_BDxST_O(endpoint); 
0B12:  MOVF   xAF,W
0B14:  MULLW  08
0B16:  MOVF   FF3,W
0B18:  CLRF   xB3
0B1A:  MOVWF  FE9
0B1C:  MOVLW  04
0B1E:  ADDWF  xB3,W
0B20:  MOVWF  FEA
0B22:  MOVFF  FEF,3B1
....................    } 
....................     
....................    return(bit_test(st,7) && bit_test(st,2)); 
0B26:  BTFSS  xB1.7
0B28:  BRA    0B2E
0B2A:  BTFSC  xB1.2
0B2C:  BRA    0B32
0B2E:  MOVLW  00
0B30:  BRA    0B34
0B32:  MOVLW  01
0B34:  MOVWF  01
0B36:  MOVLB  0
0B38:  GOTO   0B88 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_address(unsigned int8 address)  
.................... { 
....................    UADDR = address; 
*
0DCC:  MOVFF  3B0,F6E
....................     
....................    if (address)  
0DD0:  MOVLB  3
0DD2:  MOVF   xB0,F
0DD4:  BZ    0DE0
....................    { 
....................       usb_state = USB_STATE_ADDRESS; 
0DD6:  MOVLW  04
0DD8:  MOVLB  2
0DDA:  MOVWF  xC4
....................    } 
0DDC:  BRA    0DE6
0DDE:  MOVLB  3
....................    else  
....................    { 
....................       usb_state = USB_STATE_POWERED; 
0DE0:  MOVLW  02
0DE2:  MOVLB  2
0DE4:  MOVWF  xC4
....................    } 
0DE6:  MOVLB  0
0DE8:  GOTO   0DFA (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_configured(unsigned int8 config)  
.................... { 
....................    unsigned int8 en; 
....................    unsigned int16 addy; 
....................    unsigned int8 new_uep; 
....................    unsigned int16 len; 
....................    unsigned int8 i; 
....................     
....................    if (config == 0) 
*
0704:  MOVLB  3
0706:  MOVF   xAF,F
0708:  BNZ   0718
....................    { 
....................       // if config=0 then set addressed state 
....................       usb_state = USB_STATE_ADDRESS; 
070A:  MOVLW  04
070C:  MOVLB  2
070E:  MOVWF  xC4
....................       usb_disable_endpoints(); 
0710:  MOVLB  0
0712:  RCALL  04E4
....................    } 
0714:  BRA    08DA
0716:  MOVLB  3
....................    else  
....................    { 
....................       // else set configed state 
....................       usb_state = USB_STATE_CONFIGURED;  
0718:  MOVLW  05
071A:  MOVLB  2
071C:  MOVWF  xC4
....................       addy = (unsigned int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH); 
071E:  MOVLW  04
0720:  MOVLB  3
0722:  MOVWF  xB2
0724:  MOVLW  90
0726:  MOVWF  xB1
....................       for (en=1; en<USB_NUM_UEP; en++)  
0728:  MOVLW  01
072A:  MOVWF  xB0
072C:  MOVF   xB0,W
072E:  SUBLW  0F
0730:  BTFSS  FD8.0
0732:  BRA    08DA
....................       { 
....................          // enable and config endpoints based upon user configuration 
....................          usb_disable_endpoint(en); 
0734:  MOVFF  3B0,3B8
0738:  MOVLB  0
073A:  RCALL  0490
....................          new_uep = 0; 
073C:  MOVLB  3
073E:  CLRF   xB3
....................          if (usb_ep_rx_type[en] != USB_ENABLE_DISABLED)  
0740:  CLRF   03
0742:  MOVF   xB0,W
0744:  MOVFF  FF2,3B7
0748:  BCF    FF2.7
074A:  MOVLB  0
074C:  RCALL  0120
074E:  MOVLB  3
0750:  BTFSC  xB7.7
0752:  BSF    FF2.7
0754:  SUBLW  FF
0756:  BZ    0812
....................          { 
....................             new_uep = 0x04; 
0758:  MOVLW  04
075A:  MOVWF  xB3
....................             len = usb_ep_rx_size[en]; 
075C:  BCF    FD8.0
075E:  RLCF   xB0,W
0760:  CLRF   03
0762:  MOVFF  FF2,3B7
0766:  BCF    FF2.7
0768:  MOVLB  0
076A:  RCALL  0140
076C:  TBLRD*+
076E:  MOVFF  FF5,03
0772:  MOVLB  3
0774:  BTFSC  xB7.7
0776:  BSF    FF2.7
0778:  MOVWF  xB4
077A:  MOVFF  03,3B5
....................             EP_BDxCNT_O(en) = len; 
077E:  MOVF   xB0,W
0780:  MULLW  08
0782:  MOVF   FF3,W
0784:  CLRF   xB8
0786:  MOVWF  xB7
0788:  MOVLW  01
078A:  ADDWF  xB7,W
078C:  MOVWF  01
078E:  MOVLW  00
0790:  ADDWFC xB8,W
0792:  MOVWF  03
0794:  MOVFF  01,FE9
0798:  MOVLW  04
079A:  ADDWF  03,W
079C:  MOVWF  FEA
079E:  MOVFF  3B4,FEF
....................             EP_BDxADR_O(en) = addy; 
07A2:  MOVF   xB0,W
07A4:  MULLW  08
07A6:  MOVF   FF3,W
07A8:  CLRF   xB8
07AA:  MOVWF  xB7
07AC:  MOVLW  02
07AE:  ADDWF  xB7,W
07B0:  MOVWF  01
07B2:  MOVLW  00
07B4:  ADDWFC xB8,W
07B6:  MOVWF  03
07B8:  MOVFF  01,FE9
07BC:  MOVLW  04
07BE:  ADDWF  03,W
07C0:  MOVWF  FEA
07C2:  MOVFF  3B2,FEC
07C6:  MOVF   FED,F
07C8:  MOVFF  3B1,FEF
....................             addy += usb_ep_rx_size[en]; 
07CC:  BCF    FD8.0
07CE:  RLCF   xB0,W
07D0:  CLRF   03
07D2:  MOVFF  FF2,3B7
07D6:  BCF    FF2.7
07D8:  MOVLB  0
07DA:  RCALL  0140
07DC:  TBLRD*+
07DE:  MOVFF  FF5,03
07E2:  MOVLB  3
07E4:  BTFSC  xB7.7
07E6:  BSF    FF2.7
07E8:  ADDWF  xB1,F
07EA:  MOVF   03,W
07EC:  ADDWFC xB2,F
....................            #if USB_IGNORE_RX_DTS 
....................             i = 0x80; 
....................            #else 
....................             i = 0x88; 
07EE:  MOVLW  88
07F0:  MOVWF  xB6
....................            #endif 
....................             if (bit_test(len,8)) {bit_set(i,0);} 
07F2:  BTFSS  xB5.0
07F4:  BRA    07F8
07F6:  BSF    xB6.0
....................             if (bit_test(len,9)) {bit_set(i,1);} 
07F8:  BTFSS  xB5.1
07FA:  BRA    07FE
07FC:  BSF    xB6.1
....................             EP_BDxST_O(en) = i; 
07FE:  MOVF   xB0,W
0800:  MULLW  08
0802:  MOVF   FF3,W
0804:  CLRF   xB8
0806:  MOVWF  FE9
0808:  MOVLW  04
080A:  ADDWF  xB8,W
080C:  MOVWF  FEA
080E:  MOVFF  3B6,FEF
....................          } 
....................          if (usb_ep_tx_type[en] != USB_ENABLE_DISABLED)  
0812:  CLRF   03
0814:  MOVF   xB0,W
0816:  MOVFF  FF2,3B7
081A:  BCF    FF2.7
081C:  MOVLB  0
081E:  RCALL  0120
0820:  MOVLB  3
0822:  BTFSC  xB7.7
0824:  BSF    FF2.7
0826:  SUBLW  FF
0828:  BZ    08A0
....................          { 
....................             new_uep |= 0x02; 
082A:  BSF    xB3.1
....................             EP_BDxADR_I(en) = addy; 
082C:  MOVF   xB0,W
082E:  MULLW  08
0830:  MOVF   FF3,W
0832:  CLRF   xB8
0834:  MOVWF  xB7
0836:  MOVLW  04
0838:  ADDWF  xB7,F
083A:  MOVLW  00
083C:  ADDWFC xB8,F
083E:  MOVLW  02
0840:  ADDWF  xB7,W
0842:  MOVWF  01
0844:  MOVLW  00
0846:  ADDWFC xB8,W
0848:  MOVWF  03
084A:  MOVFF  01,FE9
084E:  MOVLW  04
0850:  ADDWF  03,W
0852:  MOVWF  FEA
0854:  MOVFF  3B2,FEC
0858:  MOVF   FED,F
085A:  MOVFF  3B1,FEF
....................             addy += usb_ep_tx_size[en]; 
085E:  BCF    FD8.0
0860:  RLCF   xB0,W
0862:  CLRF   03
0864:  MOVFF  FF2,3B7
0868:  BCF    FF2.7
086A:  MOVLB  0
086C:  RCALL  0140
086E:  TBLRD*+
0870:  MOVFF  FF5,03
0874:  MOVLB  3
0876:  BTFSC  xB7.7
0878:  BSF    FF2.7
087A:  ADDWF  xB1,F
087C:  MOVF   03,W
087E:  ADDWFC xB2,F
....................             EP_BDxST_I(en) = 0x40; 
0880:  MOVF   xB0,W
0882:  MULLW  08
0884:  MOVF   FF3,W
0886:  CLRF   xB8
0888:  MOVWF  xB7
088A:  MOVLW  04
088C:  ADDWF  xB7,F
088E:  MOVLW  00
0890:  ADDWFC xB8,F
0892:  MOVFF  3B7,FE9
0896:  MOVLW  04
0898:  ADDWF  xB8,W
089A:  MOVWF  FEA
089C:  MOVLW  40
089E:  MOVWF  FEF
....................          } 
....................          if (new_uep == 0x06) {new_uep = 0x0E;} 
08A0:  MOVF   xB3,W
08A2:  SUBLW  06
08A4:  BNZ   08AA
08A6:  MOVLW  0E
08A8:  MOVWF  xB3
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;} 
08AA:  CLRF   03
08AC:  MOVF   xB0,W
08AE:  MOVFF  FF2,3B7
08B2:  BCF    FF2.7
08B4:  MOVLB  0
08B6:  RCALL  0120
08B8:  MOVLB  3
08BA:  BTFSC  xB7.7
08BC:  BSF    FF2.7
08BE:  SUBLW  01
08C0:  BZ    08C4
08C2:  BSF    xB3.4
....................           
....................          UEP(en) = new_uep; 
08C4:  CLRF   03
08C6:  MOVF   xB0,W
08C8:  ADDLW  70
08CA:  MOVWF  FE9
08CC:  MOVLW  0F
08CE:  ADDWFC 03,W
08D0:  MOVWF  FEA
08D2:  MOVFF  3B3,FEF
08D6:  INCF   xB0,F
08D8:  BRA    072C
08DA:  MOVLB  0
....................       } 
....................    } 
08DC:  GOTO   098E (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoint(unsigned int8 en)  
.................... { 
....................    UEP(en) = ENDPT_DISABLED; 
*
0490:  CLRF   03
0492:  MOVLB  3
0494:  MOVF   xB8,W
0496:  ADDLW  70
0498:  MOVWF  FE9
049A:  MOVLW  0F
049C:  ADDWFC 03,W
049E:  MOVWF  FEA
04A0:  CLRF   FEF
....................     
....................    if (usb_endpoint_is_valid(en)) 
04A2:  MOVFF  3B8,3B9
04A6:  MOVLB  0
04A8:  RCALL  042E
04AA:  MOVF   01,F
04AC:  BZ    04E2
....................    { 
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary       
04AE:  MOVLB  3
04B0:  MOVF   xB8,W
04B2:  MULLW  08
04B4:  MOVF   FF3,W
04B6:  CLRF   xBA
04B8:  MOVWF  FE9
04BA:  MOVLW  04
04BC:  ADDWF  xBA,W
04BE:  MOVWF  FEA
04C0:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary 
04C2:  MOVF   xB8,W
04C4:  MULLW  08
04C6:  MOVF   FF3,W
04C8:  CLRF   xBA
04CA:  MOVWF  xB9
04CC:  MOVLW  04
04CE:  ADDWF  xB9,F
04D0:  MOVLW  00
04D2:  ADDWFC xBA,F
04D4:  MOVFF  3B9,FE9
04D8:  MOVLW  04
04DA:  ADDWF  xBA,W
04DC:  MOVWF  FEA
04DE:  CLRF   FEF
04E0:  MOVLB  0
....................    } 
04E2:  RETURN 0
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoints(void)  
.................... { 
....................    unsigned int8 i; 
....................     
....................    for (i=1; i<USB_NUM_UEP; i++) 
04E4:  MOVLW  01
04E6:  MOVLB  3
04E8:  MOVWF  xB7
04EA:  MOVF   xB7,W
04EC:  SUBLW  0F
04EE:  BNC   04FE
....................       usb_disable_endpoint(i); 
04F0:  MOVFF  3B7,3B8
04F4:  MOVLB  0
04F6:  RCALL  0490
04F8:  MOVLB  3
04FA:  INCF   xB7,F
04FC:  BRA    04EA
04FE:  MOVLB  0
0500:  RETURN 0
....................        
....................    //__usb_kbhit_status=0; 
.................... } 
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... static void usb_clear_trn(void) 
.................... { 
....................    //UIR_TRN = 0; 
....................    //delay_cycles(6); 
....................    UIR &= ~(1 << BIT_TRN); 
*
0004:  BCF    F68.3
0006:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt  
.................... /*       method), then you must call this function rapidly.  If there is more  
.................... /*       than 10ms latency the PC may think the USB device is stalled and 
.................... /*       disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this  
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the  
.................... /*       USB interrupt. 
.................... /******************************************************************************/ 
.................... #if !defined(USB_ISR_POLLING) && !defined(USB_NO_ISR_PREPROCESSOR) 
.................... #int_usb NOCLEAR 
.................... #endif 
.................... void usb_isr(void) 
.................... { 
....................    unsigned int8 TRNAttempts; 
....................     
....................    clear_interrupt(INT_USB); 
*
0F34:  BCF    FA1.5
....................     
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though 
0F36:  MOVLB  2
0F38:  MOVF   xC4,F
0F3A:  BTFSC  FD8.2
0F3C:  BRA    0FD4
....................    if (UIR)  
0F3E:  MOVF   F68,F
0F40:  BTFSC  FD8.2
0F42:  BRA    0FD4
....................    { 
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................  
....................       //activity detected.  (only enable after sleep) 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();} 
0F44:  BTFSS  F68.2
0F46:  BRA    0F54
0F48:  BTFSS  F69.2
0F4A:  BRA    0F54
0F4C:  MOVLB  0
0F4E:  GOTO   03E8
0F52:  MOVLB  2
....................  
....................       if (UCON_SUSPND) return; 
0F54:  BTFSC  F6D.1
0F56:  BRA    0FD4
....................  
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
0F58:  BTFSS  F68.5
0F5A:  BRA    0F68
0F5C:  BTFSS  F69.5
0F5E:  BRA    0F68
0F60:  MOVLB  0
0F62:  GOTO   0418
0F66:  MOVLB  2
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
0F68:  BTFSS  F68.1
0F6A:  BRA    0F78
0F6C:  BTFSS  F69.1
0F6E:  BRA    0F78
0F70:  MOVLB  0
0F72:  GOTO   0426
0F76:  MOVLB  2
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
0F78:  BTFSS  F68.0
0F7A:  BRA    0F88
0F7C:  BTFSS  F69.0
0F7E:  BRA    0F88
0F80:  MOVLB  0
0F82:  GOTO   0532
0F86:  MOVLB  2
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
0F88:  BTFSS  F68.4
0F8A:  BRA    0F98
0F8C:  BTFSS  F69.4
0F8E:  BRA    0F98
0F90:  MOVLB  0
0F92:  GOTO   0560
0F96:  MOVLB  2
....................        
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
0F98:  BTFSS  F68.6
0F9A:  BRA    0FA8
0F9C:  BTFSS  F69.6
0F9E:  BRA    0FA8
0FA0:  MOVLB  0
0FA2:  GOTO   056A
0FA6:  MOVLB  2
....................  
....................       TRNAttempts = 0; 
0FA8:  MOVLB  3
0FAA:  CLRF   xAC
....................       do 
....................       { 
....................          if (UIR_TRN && UIE_TRN)  
0FAC:  BTFSS  F68.3
0FAE:  BRA    0FC4
0FB0:  BTFSS  F69.3
0FB2:  BRA    0FC4
....................          { 
....................             USTATCopy = U1STAT; 
0FB4:  MOVFF  F6C,2C3
....................             usb_clear_trn(); 
0FB8:  MOVLB  0
0FBA:  CALL   0004
....................             usb_isr_tok_dne(); 
0FBE:  BRA    0E26
....................          } 
0FC0:  BRA    0FC8
0FC2:  MOVLB  3
....................          else 
....................             break; 
0FC4:  BRA    0FD2
0FC6:  MOVLB  0
....................       } while (TRNAttempts++ < 4); 
0FC8:  MOVLB  3
0FCA:  MOVF   xAC,W
0FCC:  INCF   xAC,F
0FCE:  SUBLW  03
0FD0:  BC    0FAC
0FD2:  MOVLB  2
....................  
....................      #if defined(USB_CDC_ISR) 
....................       //has to be done here, can't be done until TRN is empty. 
....................       if (usb_cdc_kbhit()) 
....................       { 
....................          USB_CDC_ISR(); 
....................       } 
....................      #endif 
....................    } 
0FD4:  MOVLB  0
0FD6:  GOTO   0060
.................... } 
....................  
.................... // SOF interrupt not handled.  user must add this depending on application 
.................... void usb_isr_sof(void)  
.................... { 
....................    debug_usb(debug_putc, "\r\nSOF"); 
....................     
....................    //UIR_SOF = 0; 
....................    UIR &= ~(1 << BIT_SOF); 
*
056A:  BCF    F68.6
056C:  GOTO   0FA6 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /******************************************************************************/ 
.................... void usb_isr_rst(void)  
.................... { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR = 0; 
*
0532:  CLRF   F6A
....................    UIR = 0; 
0534:  CLRF   F68
....................    UEIE = 0x9F; 
0536:  MOVLW  9F
0538:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE; 
053A:  MOVLW  3D
053C:  MOVWF  F69
....................  
....................    UADDR = 0; 
053E:  CLRF   F6E
....................  
....................    usb_disable_endpoints(); 
0540:  RCALL  04E4
....................     
....................    usb_token_reset(); 
0542:  RCALL  0502
....................  
....................    UEP(0) = ENDPT_CONTROL | 0x10; 
0544:  MOVLW  16
0546:  MOVWF  F70
....................  
....................    while (UIR_TRN)  
0548:  BTFSS  F68.3
054A:  BRA    0550
....................    { 
....................       usb_clear_trn(); 
054C:  RCALL  0004
054E:  BRA    0548
....................    } 
....................  
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled 
0550:  BCF    F6D.4
....................  
....................    usb_init_ep0_setup(); 
0552:  RCALL  03F8
....................  
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state 
0554:  MOVLW  03
0556:  MOVLB  2
0558:  MOVWF  xC4
055A:  MOVLB  0
055C:  GOTO   0F86 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void)  
.................... { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
03F8:  MOVLW  40
03FA:  MOVLB  4
03FC:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION; 
03FE:  MOVLW  04
0400:  MOVWF  x03
0402:  MOVLW  10
0404:  MOVWF  x02
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
0406:  MOVLW  88
0408:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
040A:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH; 
040C:  MOVLW  04
040E:  MOVWF  x07
0410:  MOVLW  50
0412:  MOVWF  x06
0414:  MOVLB  0
0416:  RETURN 0
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr(void) 
.................... { 
....................   #if USB_USE_ERROR_COUNTER 
....................    int ints; 
....................   #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
....................   #if USB_USE_ERROR_COUNTER 
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) )  
....................    {  
....................       //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) )  
....................    {   
....................       //increment crc5 error counter 
....................       debug_usb(debug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) )  
....................    { 
....................       //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) )  
....................    {   
....................       //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) )  
....................    {   
....................       //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) )  
....................    {  
....................       //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
....................   #endif 
....................  
....................    UEIR = 0; 
*
0426:  CLRF   F6A
....................     
....................    //UIR_UERR = 0; 
....................    UIR &= ~(1 << BIT_UERR); 
0428:  BCF    F68.1
042A:  GOTO   0F76 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_uidle(void) 
.................... { 
....................    debug_usb(debug_putc, "I"); 
....................  
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
0560:  BSF    F69.2
....................     
....................    //UIR_IDLE = 0; //clear idle interrupt flag 
....................    UIR &= ~(1 << BIT_IDLE); 
0562:  BCF    F68.4
....................     
....................    UCON_SUSPND = 1; //set suspend. we are now suspended 
0564:  BSF    F6D.1
0566:  GOTO   0F96 (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_activity(void) 
.................... { 
....................    debug_usb(debug_putc, "A"); 
....................  
....................    UCON_SUSPND = 0; //turn off low power suspending 
*
03E8:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling 
03EA:  BCF    F69.2
....................     
....................    while(UIR_ACTV) 
03EC:  BTFSS  F68.2
03EE:  BRA    03F4
....................    { 
....................       //UIR_ACTV = 0; 
....................       UIR &= ~(1 << BIT_ACTV); 
03F0:  BCF    F68.2
03F2:  BRA    03EC
....................    } 
03F4:  GOTO   0F52 (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_stall(void)  
.................... { 
....................    debug_usb(debug_putc, "S"); 
....................     
....................     
....................    if (bit_test(UEP(0),0))  
*
0418:  BTFSS  F70.0
041A:  BRA    0420
....................    { 
....................       usb_init_ep0_setup(); 
041C:  RCALL  03F8
....................       bit_clear(UEP(0), 0); 
041E:  BCF    F70.0
....................    } 
....................     
....................    //UIR_STALL = 0; 
....................    UIR &= ~(1 << BIT_STALL); 
0420:  BCF    F68.5
0422:  GOTO   0F66 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;} 
*
0570:  MOVFF  3B2,2C5
0574:  RETURN 0
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;} 
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;} 
0576:  MOVLB  2
0578:  SETF   xC5
057A:  MOVLB  0
057C:  RETURN 0
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_tok_dne(void)  
.................... { 
....................    unsigned int8 en; 
....................  
....................    en = USTATCopy>>3; 
*
0E26:  MOVLB  2
0E28:  RRCF   xC3,W
0E2A:  MOVLB  3
0E2C:  MOVWF  xAD
0E2E:  RRCF   xAD,F
0E30:  RRCF   xAD,F
0E32:  MOVLW  1F
0E34:  ANDWF  xAD,F
....................  
....................    debug_usb(debug_putc, "T "); 
....................    debug_usb(debug_putc, "%X ", USTATCopy); 
....................  
....................    if (USTATCopy == USTAT_OUT_SETUP_E0)  
0E36:  MOVLB  2
0E38:  MOVF   xC3,F
0E3A:  BNZ   0EE6
....................    { 
....................       //new out or setup token in the buffer 
....................       int8 pidKey; 
....................        
....................       debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................        
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID 
0E3C:  MOVLB  4
0E3E:  MOVF   x00,W
0E40:  ANDLW  3C
0E42:  MOVLB  3
0E44:  MOVWF  xAE
....................        
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion 
0E46:  MOVLW  43
0E48:  MOVLB  4
0E4A:  ANDWF  x00,F
....................        
....................       if (pidKey == USB_PIC_PID_SETUP)  
0E4C:  MOVLB  3
0E4E:  MOVF   xAE,W
0E50:  SUBLW  34
0E52:  BNZ   0EA6
....................       { 
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00) 
0E54:  MOVLB  4
0E56:  MOVF   x04,W
0E58:  ANDLW  80
0E5A:  BZ    0E5E
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
0E5C:  CLRF   x04
....................  
....................          debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................          debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................          usb_isr_tok_setup_dne(); 
0E5E:  MOVLB  0
0E60:  BRA    0BA6
....................  
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
0E62:  BCF    F6D.4
....................  
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall()) 
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data()) 
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response()) 
....................          if (__setup_0_tx_size == 0xFF) 
0E64:  MOVLB  2
0E66:  INCFSZ xC5,W
0E68:  BRA    0E7A
....................             usb_flush_out(0, USB_DTS_STALL); 
0E6A:  MOVLB  3
0E6C:  CLRF   xAF
0E6E:  MOVLW  03
0E70:  MOVWF  xB0
0E72:  MOVLB  0
0E74:  RCALL  0BD2
0E76:  BRA    0EA0
0E78:  MOVLB  2
....................          else  
....................          { 
....................             usb_flush_out(0, USB_DTS_TOGGLE); 
0E7A:  MOVLB  3
0E7C:  CLRF   xAF
0E7E:  MOVLW  02
0E80:  MOVWF  xB0
0E82:  MOVLB  0
0E84:  RCALL  0BD2
....................             if (__setup_0_tx_size != 0xFE) 
0E86:  MOVLB  2
0E88:  MOVF   xC5,W
0E8A:  SUBLW  FE
0E8C:  BZ    0EA2
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX); 
0E8E:  MOVLB  3
0E90:  CLRF   xAF
0E92:  CLRF   xB1
0E94:  MOVFF  2C5,3B0
0E98:  MOVLW  04
0E9A:  MOVWF  xB2
0E9C:  MOVLB  0
0E9E:  RCALL  0CE4
0EA0:  MOVLB  2
....................          } 
....................          //why was this here? 
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
....................       } 
0EA2:  BRA    0EE0
0EA4:  MOVLB  3
....................       else if (pidKey == USB_PIC_PID_OUT)  
0EA6:  MOVF   xAE,W
0EA8:  SUBLW  04
0EAA:  BNZ   0EE2
....................       { 
....................          usb_isr_tok_out_dne(0); 
0EAC:  CLRF   xAF
0EAE:  MOVLB  0
0EB0:  RCALL  0DC2
....................          usb_flush_out(0, USB_DTS_TOGGLE); 
0EB2:  MOVLB  3
0EB4:  CLRF   xAF
0EB6:  MOVLW  02
0EB8:  MOVWF  xB0
0EBA:  MOVLB  0
0EBC:  RCALL  0BD2
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF)) 
0EBE:  MOVLB  2
0EC0:  MOVF   xC5,W
0EC2:  SUBLW  FE
0EC4:  BZ    0EE0
0EC6:  INCFSZ xC5,W
0EC8:  BRA    0ECC
0ECA:  BRA    0EE0
....................          { 
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
0ECC:  MOVLB  3
0ECE:  CLRF   xAF
0ED0:  CLRF   xB1
0ED2:  MOVFF  2C5,3B0
0ED6:  MOVLW  01
0ED8:  MOVWF  xB2
0EDA:  MOVLB  0
0EDC:  RCALL  0CE4
0EDE:  MOVLB  2
....................          } 
....................       } 
0EE0:  MOVLB  3
....................       else 
....................       { 
....................          debug_usb(debug_putc, "!!! "); 
....................       } 
....................    } 
0EE2:  BRA    0F2E
0EE4:  MOVLB  2
....................    else if (USTATCopy == USTAT_IN_E0)  
0EE6:  MOVF   xC3,W
0EE8:  SUBLW  04
0EEA:  BNZ   0F14
....................    {    
....................       //pic -> host transfer completed 
....................       //EP_BDxST_I(0) = EP_BDxST_I(0) & 0xC3;   //clear up any BDSTAL confusion 
....................       __setup_0_tx_size = 0xFF; 
0EEC:  SETF   xC5
....................       usb_isr_tok_in_dne(0); 
0EEE:  MOVLB  3
0EF0:  CLRF   xAF
0EF2:  MOVLB  0
0EF4:  RCALL  0DFE
....................       if (__setup_0_tx_size!=0xFF) 
0EF6:  MOVLB  2
0EF8:  INCFSZ xC5,W
0EFA:  BRA    0EFE
0EFC:  BRA    0F12
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE); 
0EFE:  MOVLB  3
0F00:  CLRF   xAF
0F02:  CLRF   xB1
0F04:  MOVFF  2C5,3B0
0F08:  MOVLW  02
0F0A:  MOVWF  xB2
0F0C:  MOVLB  0
0F0E:  RCALL  0CE4
0F10:  MOVLB  2
....................       else 
....................       { 
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................       }   
....................    } 
0F12:  BRA    0F2C
....................    else  
....................    { 
....................       if (!bit_test(USTATCopy, 2))  
0F14:  BTFSC  xC3.2
0F16:  BRA    0F24
....................       { 
....................          //EP_BDxST_O(en) = EP_BDxST_O(en) & 0xC3;   //clear up any BDSTAL confusion 
....................          usb_isr_tok_out_dne(en); 
0F18:  MOVFF  3AD,3AF
0F1C:  MOVLB  0
0F1E:  RCALL  0DC2
....................       } 
0F20:  BRA    0F2C
0F22:  MOVLB  2
....................       else  
....................       { 
....................          //EP_BDxST_I(en) = EP_BDxST_I(en) & 0xC3;   //clear up any BDSTAL confusion 
....................          usb_isr_tok_in_dne(en); 
0F24:  MOVFF  3AD,3AF
0F28:  MOVLB  0
0F2A:  RCALL  0DFE
0F2C:  MOVLB  3
....................       } 
....................    } 
0F2E:  MOVLB  0
0F30:  GOTO   0FC0 (RETURN)
.................... } 
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... #if defined(__PIC24_USB_H__) 
....................  #include <pic24_usb.c> 
.................... #endif 
....................  
.................... #if defined(__USBN960X_H__) 
....................  #include <usbn960x.c> 
.................... #endif 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... #if (defined(USB_USE_FULL_SPEED) && (USB_USE_FULL_SPEED==1)) 
....................    #define USB_ISO_PACKET_MAX_SIZE     1023 
....................    #define USB_NONISO_PACKET_MAX_SIZE  64 
.................... #else 
....................    #define USB_ISO_PACKET_MAX_SIZE     1023 
....................    #define USB_NONISO_PACKET_MAX_SIZE  8 
.................... #endif 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #if USB_EP1_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP1_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP1_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP1_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP1_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #if USB_EP2_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP2_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP2_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP2_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP2_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #if USB_EP3_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP3_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP3_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP3_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP3_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #if USB_EP4_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP4_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP4_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP4_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP4_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #if USB_EP5_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP5_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP5_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP5_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP5_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #if USB_EP6_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP6_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP6_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP6_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP6_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #if USB_EP7_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP7_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP7_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP7_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP7_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #if USB_EP8_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP8_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP8_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP8_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP8_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #if USB_EP9_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP9_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP9_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP9_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP9_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #if USB_EP10_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP10_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP10_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP10_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP10_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #if USB_EP11_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #if USB_EP12_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP12_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP12_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP12_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP12_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #if USB_EP13_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP13_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP13_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP13_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP13_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #if USB_EP14_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP14_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP14_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP14_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP14_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #if USB_EP15_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP15_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP15_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP15_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP15_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... unsigned int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... unsigned int16 usb_getdesc_ptr; unsigned int16 usb_getdesc_len;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... unsigned int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
.................... void usb_finish_set_address(void); 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... // see usb.h for documentation 
.................... int1 usb_enumerated(void) 
.................... { 
....................    return(USB_stack_status.curr_config); 
*
1EAE:  MOVLB  2
1EB0:  MOVFF  2C0,01
1EB4:  MOVLB  0
1EB6:  GOTO   3CF2 (RETURN)
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_wait_for_enumeration(void)  
.................... { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... // see USB.H for documentation 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) { 
....................    unsigned int16 i=0; 
....................    int1 res; 
....................    unsigned int16 this_packet_len; 
....................    unsigned int16 packet_size; 
....................    unsigned int32 timeout_1us; 
....................  
....................    packet_size = usb_ep_tx_size[endpoint]; 
....................     
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size); 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len)  
....................    { 
....................       timeout_1us = (int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;} 
....................       else {this_packet_len = len-i;} 
....................       //putc('*'); 
....................       do  
....................       { 
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets 
....................          //putc('.'); 
....................          if (!res) 
....................          { 
....................             delay_us(1); 
....................             //delay_ms(500); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................       i += packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout) { 
....................    unsigned int16 ret=0; 
....................    unsigned int16 to; 
....................    unsigned int16 len; 
....................    unsigned int16 packet_size; 
....................    unsigned int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (!timeout || (to!=timeout)) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... // see usb.h for documentation 
.................... void usb_token_reset(void)  
.................... { 
....................    unsigned int i; 
....................  
....................    usb_getdesc_len = 0; 
*
0502:  MOVLB  2
0504:  CLRF   xCA
0506:  CLRF   xC9
....................     
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++)  
0508:  MOVLB  3
050A:  CLRF   xAD
050C:  MOVF   xAD,F
050E:  BNZ   0524
....................       USB_Interface[i] = 0;   //reset each interface to default 
0510:  CLRF   03
0512:  MOVF   xAD,W
0514:  ADDLW  CB
0516:  MOVWF  FE9
0518:  MOVLW  02
051A:  ADDWFC 03,W
051C:  MOVWF  FEA
051E:  CLRF   FEF
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) 
....................       hid_protocol[i] = 1; 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
0520:  INCF   xAD,F
0522:  BRA    050C
....................    usb_cdc_init(); 
....................   #endif 
....................  
....................    USB_stack_status.curr_config = 0;      //unconfigured device 
0524:  MOVLB  2
0526:  CLRF   xC0
....................  
....................    USB_stack_status.status_device = 1;    //previous state.  init at none 
0528:  MOVLW  01
052A:  MOVWF  xC1
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none 
052C:  CLRF   xBF
052E:  MOVLB  0
0530:  RETURN 0
.................... } 
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
042E:  MOVLB  3
0430:  BCF    xBA.0
0432:  BTFSC  xB9.7
0434:  BSF    xBA.0
....................     
....................    endpoint &= 0x7F; 
0436:  BCF    xB9.7
....................     
....................    if (endpoint > 16) 
0438:  MOVF   xB9,W
043A:  SUBLW  10
043C:  BC    0444
....................       return(FALSE); 
043E:  MOVLW  00
0440:  MOVWF  01
0442:  BRA    048C
....................     
....................    if (direction) { //IN 
0444:  BTFSS  xBA.0
0446:  BRA    046C
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
0448:  CLRF   03
044A:  MOVF   xB9,W
044C:  MOVFF  FF2,3BB
0450:  BCF    FF2.7
0452:  MOVLB  0
0454:  RCALL  0120
0456:  MOVLB  3
0458:  BTFSC  xBB.7
045A:  BSF    FF2.7
045C:  SUBLW  FF
045E:  BNZ   0464
0460:  MOVLW  00
0462:  BRA    0466
0464:  MOVLW  01
0466:  MOVWF  01
0468:  BRA    048C
....................    } 
046A:  BRA    048C
....................    else {   //OUT 
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
046C:  CLRF   03
046E:  MOVF   xB9,W
0470:  MOVFF  FF2,3BB
0474:  BCF    FF2.7
0476:  MOVLB  0
0478:  RCALL  0120
047A:  MOVLB  3
047C:  BTFSC  xBB.7
047E:  BSF    FF2.7
0480:  SUBLW  FF
0482:  BNZ   0488
0484:  MOVLW  00
0486:  BRA    048A
0488:  MOVLW  01
048A:  MOVWF  01
....................    } 
048C:  MOVLB  0
048E:  RETURN 0
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint) { 
....................    if (endpoint==0) { 
*
0DFE:  MOVLB  3
0E00:  MOVF   xAF,F
0E02:  BNZ   0E22
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
0E04:  MOVLB  2
0E06:  DECFSZ xBF,W
0E08:  BRA    0E14
0E0A:  MOVLB  0
0E0C:  CALL   057E
0E10:  BRA    0E1E
0E12:  MOVLB  2
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
0E14:  MOVF   xBF,W
0E16:  SUBLW  02
0E18:  BNZ   0E20
0E1A:  MOVLB  0
0E1C:  BRA    0DEC
0E1E:  MOVLB  2
0E20:  MOVLB  3
....................    } 
....................   #if USB_CDC_DEVICE 
0E22:  MOVLB  0
0E24:  RETURN 0
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
....................       usb_isr_tok_in_cdc_data_dne(); 
....................   } 
....................   #endif 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint) 
.................... { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
0DC2:  MOVLB  3
0DC4:  MOVF   xAF,F
0DC6:  BNZ   0DC8
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
....................      //#else   //REMOVED JUN/9/2009 
....................      //usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
0DC8:  MOVLB  0
0DCA:  RETURN 0
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
....................       usb_isr_tok_out_cdc_data_dne(); 
....................    } 
....................   #endif 
....................    //else { 
....................    //   bit_set(__usb_kbhit_status,endpoint); 
....................    //} 
.................... } 
....................  
....................  
.................... //---- process setup message stage -----------// 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_setup_dne(void)  
.................... { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
0BA6:  MOVLB  2
0BA8:  CLRF   xBF
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
0BAA:  MOVLB  4
0BAC:  MOVF   x10,W
0BAE:  ANDLW  7F
0BB0:  XORLW  00
0BB2:  MOVLB  0
0BB4:  BZ    0BC0
0BB6:  XORLW  01
0BB8:  BZ    0BC4
0BBA:  XORLW  03
0BBC:  BZ    0BC8
0BBE:  BRA    0BCC
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
0BC0:  BRA    08E0
....................          break; 
0BC2:  BRA    0BCE
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
0BC4:  BRA    09A2
....................          break; 
0BC6:  BRA    0BCE
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
0BC8:  BRA    0B3C
....................          break; 
0BCA:  BRA    0BCE
....................           
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc, " class"); 
....................         #if USB_HID_DEVICE && USB_CDC_DEVICE 
....................          if (usb_ep0_rx_buffer[4] == USB_HID_INTERFACE) 
....................          { 
....................             usb_isr_tkn_setup_ClassInterface(); 
....................          } 
....................          else 
....................          { 
....................             usb_isr_tkn_cdc(); 
....................          } 
....................         #elif USB_HID_DEVICE 
....................          usb_isr_tkn_setup_ClassInterface(); 
....................         #else 
....................          usb_isr_tkn_cdc(); 
....................         #endif 
....................          break; 
.................... #endif 
....................  
....................  
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
0BCC:  RCALL  0576
....................          break; 
....................    } 
0BCE:  GOTO   0E62 (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
08E0:  MOVLB  4
08E2:  MOVF   x11,W
08E4:  XORLW  00
08E6:  MOVLB  0
08E8:  BZ    0904
08EA:  XORLW  01
08EC:  BZ    0918
08EE:  XORLW  02
08F0:  BZ    0936
08F2:  XORLW  06
08F4:  BZ    0952
08F6:  XORLW  03
08F8:  BZ    0966
08FA:  XORLW  0E
08FC:  BZ    096A
08FE:  XORLW  01
0900:  BZ    097A
0902:  BRA    099C
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
0904:  MOVFF  2C1,450
....................             usb_ep0_tx_buffer[1]=0; 
0908:  MOVLB  4
090A:  CLRF   x51
....................             usb_request_send_response(2); 
090C:  MOVLW  02
090E:  MOVLB  3
0910:  MOVWF  xB2
0912:  MOVLB  0
0914:  RCALL  0570
....................             break; 
0916:  BRA    099E
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
0918:  MOVLB  4
091A:  DECFSZ x12,W
091C:  BRA    0930
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
091E:  MOVLW  01
0920:  MOVLB  2
0922:  ANDWF  xC1,F
....................                usb_put_0len_0(); 
0924:  MOVLB  3
0926:  CLRF   xB2
0928:  MOVLB  0
092A:  RCALL  0570
....................             } 
092C:  BRA    0934
092E:  MOVLB  4
....................             else 
....................                usb_request_stall(); 
0930:  MOVLB  0
0932:  RCALL  0576
....................             break; 
0934:  BRA    099E
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
0936:  MOVLB  4
0938:  DECFSZ x12,W
093A:  BRA    094C
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
093C:  MOVLB  2
093E:  BSF    xC1.1
....................                usb_put_0len_0(); 
0940:  MOVLB  3
0942:  CLRF   xB2
0944:  MOVLB  0
0946:  RCALL  0570
....................             } 
0948:  BRA    0950
094A:  MOVLB  4
....................             else 
....................                usb_request_stall(); 
094C:  MOVLB  0
094E:  RCALL  0576
....................             break; 
0950:  BRA    099E
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
0952:  MOVLW  02
0954:  MOVLB  2
0956:  MOVWF  xBF
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
0958:  MOVFF  412,2C6
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
095C:  MOVLB  3
095E:  CLRF   xB2
0960:  MOVLB  0
0962:  RCALL  0570
....................             break; 
0964:  BRA    099E
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
0966:  BRA    0650
....................             break; 
0968:  BRA    099E
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
096A:  MOVFF  2C0,450
....................             usb_request_send_response(1); 
096E:  MOVLW  01
0970:  MOVLB  3
0972:  MOVWF  xB2
0974:  MOVLB  0
0976:  RCALL  0570
....................             break; 
0978:  BRA    099E
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
097A:  MOVLB  4
097C:  MOVF   x12,W
097E:  SUBLW  01
0980:  BNC   0998
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
0982:  MOVFF  412,2C0
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
0986:  MOVFF  412,3AF
098A:  MOVLB  0
098C:  BRA    0704
....................                debug_usb(debug_putc,"SC%U", USB_stack_status.curr_config);                
....................                usb_put_0len_0(); 
098E:  MOVLB  3
0990:  CLRF   xB2
0992:  MOVLB  0
0994:  RCALL  0570
0996:  MOVLB  4
....................             } 
....................             break; 
0998:  MOVLB  0
099A:  BRA    099E
....................  
....................       default: 
....................             usb_request_stall(); 
099C:  RCALL  0576
....................             break; 
....................    } 
099E:  GOTO   0BCE (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    unsigned int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
09A2:  MOVFF  2C0,3AF
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
09A6:  MOVLB  4
09A8:  MOVF   x11,W
09AA:  XORLW  00
09AC:  MOVLB  0
09AE:  BZ    09BA
09B0:  XORLW  0A
09B2:  BZ    09CC
09B4:  XORLW  01
09B6:  BZ    0A1E
09B8:  BRA    0A4A
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
09BA:  MOVLB  4
09BC:  CLRF   x50
....................             usb_ep0_tx_buffer[1]=0; 
09BE:  CLRF   x51
....................             usb_request_send_response(2); 
09C0:  MOVLW  02
09C2:  MOVLB  3
09C4:  MOVWF  xB2
09C6:  MOVLB  0
09C8:  RCALL  0570
....................             break; 
09CA:  BRA    0A4C
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
09CC:  MOVLB  3
09CE:  MOVF   xAF,F
09D0:  BZ    0A18
09D2:  MOVLW  01
09D4:  SUBWF  xAF,W
09D6:  CLRF   03
09D8:  MOVFF  FF2,3B0
09DC:  BCF    FF2.7
09DE:  MOVLB  0
09E0:  CALL   01B2
09E4:  MOVLB  3
09E6:  BTFSC  xB0.7
09E8:  BSF    FF2.7
09EA:  MOVWF  01
09EC:  MOVLB  4
09EE:  SUBWF  x14,W
09F0:  BTFSS  FD8.0
09F2:  BRA    09F8
09F4:  MOVLB  3
09F6:  BRA    0A18
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
09F8:  CLRF   03
09FA:  MOVF   x14,W
09FC:  ADDLW  CB
09FE:  MOVWF  FE9
0A00:  MOVLW  02
0A02:  ADDWFC 03,W
0A04:  MOVWF  FEA
0A06:  MOVFF  FEF,450
....................                usb_request_send_response(1);; //send byte back 
0A0A:  MOVLW  01
0A0C:  MOVLB  3
0A0E:  MOVWF  xB2
0A10:  MOVLB  0
0A12:  RCALL  0570
....................             } 
0A14:  BRA    0A1C
0A16:  MOVLB  3
....................             else 
....................                usb_request_stall(); 
0A18:  MOVLB  0
0A1A:  RCALL  0576
....................             break; 
0A1C:  BRA    0A4C
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
0A1E:  MOVLB  3
0A20:  MOVF   xAF,F
0A22:  BZ    0A44
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
0A24:  CLRF   03
0A26:  MOVLB  4
0A28:  MOVF   x14,W
0A2A:  ADDLW  CB
0A2C:  MOVWF  FE9
0A2E:  MOVLW  02
0A30:  ADDWFC 03,W
0A32:  MOVWF  FEA
0A34:  MOVFF  412,FEF
....................                usb_put_0len_0(); 
0A38:  MOVLB  3
0A3A:  CLRF   xB2
0A3C:  MOVLB  0
0A3E:  RCALL  0570
....................             } 
0A40:  BRA    0A48
0A42:  MOVLB  3
....................             else 
....................                usb_request_stall(); 
0A44:  MOVLB  0
0A46:  RCALL  0576
....................             break; 
0A48:  BRA    0A4C
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GDh"); 
....................             usb_Get_Descriptor(); 
....................             break; 
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
0A4A:  RCALL  0576
....................             break; 
....................    } 
0A4C:  GOTO   0BCE (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
0B3C:  MOVFF  414,3B9
0B40:  RCALL  042E
0B42:  MOVF   01,F
0B44:  BZ    0BA2
....................       switch(usb_ep0_rx_buffer[1]) { 
0B46:  MOVLB  4
0B48:  MOVF   x11,W
0B4A:  XORLW  01
0B4C:  MOVLB  0
0B4E:  BZ    0B5A
0B50:  XORLW  02
0B52:  BZ    0B6A
0B54:  XORLW  03
0B56:  BZ    0B7A
0B58:  BRA    0BA0
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
0B5A:  MOVFF  414,3AF
0B5E:  BRA    0A50
....................                usb_put_0len_0(); 
0B60:  MOVLB  3
0B62:  CLRF   xB2
0B64:  MOVLB  0
0B66:  RCALL  0570
....................                break; 
0B68:  BRA    0BA2
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
0B6A:  MOVFF  414,3AF
0B6E:  BRA    0A98
....................                      usb_put_0len_0(); 
0B70:  MOVLB  3
0B72:  CLRF   xB2
0B74:  MOVLB  0
0B76:  RCALL  0570
....................                      break; 
0B78:  BRA    0BA2
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
0B7A:  MOVLB  4
0B7C:  CLRF   x50
....................                usb_ep0_tx_buffer[1]=0; 
0B7E:  CLRF   x51
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
0B80:  MOVFF  414,3AF
0B84:  MOVLB  0
0B86:  BRA    0AE2
0B88:  MOVF   01,F
0B8A:  BZ    0B94
....................                   usb_ep0_tx_buffer[0]=1; 
0B8C:  MOVLW  01
0B8E:  MOVLB  4
0B90:  MOVWF  x50
0B92:  MOVLB  0
....................                } 
....................                usb_request_send_response(2); 
0B94:  MOVLW  02
0B96:  MOVLB  3
0B98:  MOVWF  xB2
0B9A:  MOVLB  0
0B9C:  RCALL  0570
....................                break; 
0B9E:  BRA    0BA2
....................  
....................          default: 
....................             usb_request_stall(); 
0BA0:  RCALL  0576
....................             break; 
....................       } 
....................    } 
0BA2:  GOTO   0BCE (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
....................             break; 
....................    } 
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
0650:  MOVLB  2
0652:  CLRF   xC8
0654:  CLRF   xC7
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
0656:  CLRF   xC2
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
0658:  MOVLB  4
065A:  MOVF   x13,W
065C:  XORLW  01
065E:  MOVLB  0
0660:  BZ    066C
0662:  XORLW  03
0664:  BZ    067A
0666:  XORLW  01
0668:  BZ    0684
066A:  BRA    06D2
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
066C:  MOVLB  2
066E:  CLRF   xCA
0670:  MOVLW  12
0672:  MOVWF  xC9
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
0674:  MOVLW  03
0676:  MOVWF  xC2
....................             break; 
0678:  BRA    06D8
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
067A:  MOVLB  2
067C:  CLRF   xCA
067E:  MOVLW  20
0680:  MOVWF  xC9
....................             break; 
0682:  BRA    06D8
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
0684:  MOVLW  02
0686:  MOVLB  2
0688:  MOVWF  xC2
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
068A:  CLRF   03
068C:  MOVLB  4
068E:  MOVF   x12,W
0690:  MOVFF  FF2,3AF
0694:  BCF    FF2.7
0696:  MOVLB  0
0698:  RCALL  01E6
069A:  MOVLB  3
069C:  BTFSC  xAF.7
069E:  BSF    FF2.7
06A0:  CLRF   03
06A2:  MOVFF  FE8,2C7
06A6:  MOVLB  2
06A8:  MOVFF  03,2C8
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
06AC:  MOVFF  2C8,03
06B0:  MOVF   xC7,W
06B2:  MOVFF  FF2,3AF
06B6:  BCF    FF2.7
06B8:  MOVLB  0
06BA:  RCALL  01FA
06BC:  MOVLB  3
06BE:  BTFSC  xAF.7
06C0:  BSF    FF2.7
06C2:  CLRF   03
06C4:  MOVFF  FE8,2C9
06C8:  MOVLB  2
06CA:  MOVFF  03,2CA
....................             break; 
06CE:  BRA    06D8
06D0:  MOVLB  0
....................  
....................       //case USB_DESC_DEVICE_QUALIFIER_TYPE:   //0x06 
....................       // this is needed so host can find out about differences about this 
....................       // devices ability to handle full speed verses fast speed. 
....................       // since we don't support fast speed then we ignore this. 
....................       //      break; 
....................  
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             //TODO does this work for multiple interfaces or multiple languages? 
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]]; 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]]; 
....................             if (usb_getdesc_ptr!=0xFF) { 
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
....................             if (usb_getdesc_ptr !=0xFF) { 
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
06D2:  RCALL  0576
....................             return; 
06D4:  BRA    0700
06D6:  MOVLB  2
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
06D8:  MOVLB  4
06DA:  MOVF   x17,F
06DC:  BNZ   06F6
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
06DE:  MOVLB  2
06E0:  MOVF   xCA,F
06E2:  BNZ   06EE
06E4:  MOVF   xC9,W
06E6:  MOVLB  4
06E8:  SUBWF  x16,W
06EA:  BC    06F6
06EC:  MOVLB  2
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
06EE:  CLRF   xCA
06F0:  MOVFF  416,2C9
06F4:  MOVLB  4
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
06F6:  MOVLW  01
06F8:  MOVLB  2
06FA:  MOVWF  xBF
....................    usb_copy_desc_seg_to_ep(); 
06FC:  MOVLB  0
06FE:  RCALL  057E
0700:  GOTO   099E (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0 
*
0DEC:  MOVLB  2
0DEE:  CLRF   xC0
....................  
....................    #ifdef __PIC__ 
....................    USB_stack_status.dev_req=NONE;  // no request pending 
0DF0:  CLRF   xBF
....................    usb_set_address(USB_address_pending); 
0DF2:  MOVFF  2C6,3B0
0DF6:  MOVLB  0
0DF8:  BRA    0DCC
....................    #endif 
0DFA:  GOTO   0E1E (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
*
057E:  MOVLB  3
0580:  CLRF   xB0
....................    unsigned int i=0; 
....................    char c; 
....................     
....................    //debug_usb(debug_putc, "!%LX! ", &usb_ep0_tx_buffer[0]); 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
0582:  MOVLB  2
0584:  MOVF   xC9,W
0586:  IORWF  xCA,W
0588:  BZ    062E
058A:  MOVLB  3
058C:  MOVF   xB0,W
058E:  SUBLW  3F
0590:  BTFSC  FD8.0
0592:  BRA    0598
0594:  MOVLB  2
0596:  BRA    062E
....................    { 
....................       switch(USB_stack_status.getdesc_type) { 
0598:  MOVLB  2
059A:  MOVF   xC2,W
059C:  XORLW  00
059E:  MOVLB  0
05A0:  BZ    05AC
05A2:  XORLW  02
05A4:  BZ    05CA
05A6:  XORLW  01
05A8:  BZ    05E8
05AA:  BRA    0604
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
05AC:  MOVFF  2C8,03
05B0:  MOVLB  2
05B2:  MOVF   xC7,W
05B4:  MOVFF  FF2,3B2
05B8:  BCF    FF2.7
05BA:  MOVLB  0
05BC:  RCALL  0182
05BE:  MOVLB  3
05C0:  BTFSC  xB2.7
05C2:  BSF    FF2.7
05C4:  MOVWF  xB1
....................             break; 
05C6:  MOVLB  0
05C8:  BRA    0604
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
....................             break; 
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
05CA:  MOVFF  2C8,03
05CE:  MOVLB  2
05D0:  MOVF   xC7,W
05D2:  MOVFF  FF2,3B2
05D6:  BCF    FF2.7
05D8:  MOVLB  0
05DA:  RCALL  01FA
05DC:  MOVLB  3
05DE:  BTFSC  xB2.7
05E0:  BSF    FF2.7
05E2:  MOVWF  xB1
....................             break; 
05E4:  MOVLB  0
05E6:  BRA    0604
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
05E8:  MOVFF  2C8,03
05EC:  MOVLB  2
05EE:  MOVF   xC7,W
05F0:  MOVFF  FF2,3B2
05F4:  BCF    FF2.7
05F6:  MOVLB  0
05F8:  RCALL  01C4
05FA:  MOVLB  3
05FC:  BTFSC  xB2.7
05FE:  BSF    FF2.7
0600:  MOVWF  xB1
....................             //debug_usb(debug_putc, "-%X- ", c); 
....................             break; 
0602:  MOVLB  0
....................       } 
....................       usb_getdesc_ptr++; 
0604:  MOVLB  2
0606:  INCF   xC7,F
0608:  BTFSC  FD8.2
060A:  INCF   xC8,F
....................       usb_getdesc_len--; 
060C:  MOVF   xC9,W
060E:  BTFSC  FD8.2
0610:  DECF   xCA,F
0612:  DECF   xC9,F
....................       usb_ep0_tx_buffer[i++]=c; 
0614:  MOVLB  3
0616:  MOVF   xB0,W
0618:  INCF   xB0,F
061A:  CLRF   03
061C:  ADDLW  50
061E:  MOVWF  FE9
0620:  MOVLW  04
0622:  ADDWFC 03,W
0624:  MOVWF  FEA
0626:  MOVFF  3B1,FEF
062A:  BRA    0582
062C:  MOVLB  2
....................    } 
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
062E:  MOVF   xC9,W
0630:  IORWF  xCA,W
0632:  BNZ   0646
0634:  MOVLB  3
0636:  MOVF   xB0,W
0638:  SUBLW  40
063A:  BTFSS  FD8.2
063C:  BRA    0642
063E:  MOVLB  2
0640:  BRA    0646
....................          USB_stack_status.dev_req = NONE; 
0642:  MOVLB  2
0644:  CLRF   xBF
....................    } 
....................  
....................    usb_request_send_response(i); 
0646:  MOVFF  3B0,3B2
064A:  MOVLB  0
064C:  RCALL  0570
064E:  RETURN 0
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #use fast_io(b) 
.................... #use fast_io(c) 
.................... #use fast_io(a) 
.................... #use fast_io(e) 
.................... #define RecCommand   recbuf[0] 
....................  
.................... //#define LED    PIN_B5 
....................  
.................... const int8 Lenbuf = 32; 
.................... unsigned char m0,k1,pass_l; 
....................  
.................... /////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // RAM, RAM, RAM 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... #define RecCommand   recbuf[0] 
....................  
.................... #define SAVE_N          0x01 
.................... #define SAVE_MSG        0x02 
.................... #define SEND_RS232      0x03 
.................... #define READ_N          0x04 
.................... #define READ_MSG        0x05 
.................... #define GET_RS232       0x06 
.................... #define GET_FIRMWARE    0x07 
.................... #define SAVE_FLAG       0x08 
.................... #define SAVE_SM         0x09  
.................... #define SAVE_SN         0x0A  
.................... #define SOLD_FLAG       0x0B  
.................... #define SAVE_PWD        0x0C 
.................... #define MA_FLAG         0x0D  
.................... #define GET_MODULE      0x0E 
....................  
.................... #define READ_N1         0x14 
.................... #define READ_N2         0x15 
.................... #define READ_N3         0x16 
.................... #define READ_N4         0x17 
....................  
.................... #define READ_SPEED      0x18 
.................... #define WRITE_SPEED     0x19 
....................  
.................... char Version[] = "v.1.2"; 
.................... #ifdef ALARME 
.................... #ifdef GPS0 
....................    char Module[] = "AL_548"; 
.................... #else  
....................    char Module[] = "AL_300"; 
.................... #endif 
.................... #else 
.................... #ifdef GPS0 
....................    char Module[] = "TR_548"; 
.................... #else  
....................    char Module[] = "TR_300"; 
.................... #endif 
.................... #endif 
....................  
....................  
.................... char txt[]=" EMNT 2009"; 
.................... char site[]="www.emnt-dz.com"; 
.................... int  i,i2=0,al2; 
.................... int16 count,count0; 
....................  
.................... int8 recbuf[Lenbuf]; 
.................... int8 sndbuf[Lenbuf]; 
.................... char flag0, tel_n2[10],n_tel_[10],al0=0,rs232_l,al1=0; 
.................... unsigned char Rx,Rx0; 
.................... #bit al=flag0.1 
.................... //const int8 txt[64]={"Test de system"}; 
....................  
.................... char c[6],s1[6],d[6],t[6]; 
.................... char n_tel=0,k,n,n0,g,m=0; 
....................  
.................... /**************************************************************************************************/ 
.................... #int_RDA 
.................... void  RDA_isr(void)  
.................... { 
....................    no_ok=0; 
*
104C:  MOVLB  1
104E:  CLRF   xBE
....................    Rx = fgetc(GSM); 
1050:  BTFSS  F9E.5
1052:  BRA    1050
1054:  MOVFF  FAE,356
1058:  MOVLB  3
....................    //fputc(Rx,DEBUG); 
....................    //if (receive_flag ==0) 
....................    //{ 
....................       if ((Rx == 10)&&(Rx0 == 13)&&(SerialBuffer_pos>0))  
105A:  MOVF   x56,W
105C:  SUBLW  0A
105E:  BTFSS  FD8.2
1060:  BRA    120C
1062:  MOVF   x57,W
1064:  SUBLW  0D
1066:  BTFSS  FD8.2
1068:  BRA    120C
106A:  MOVLB  0
106C:  MOVF   x9E,F
106E:  BTFSS  FD8.2
1070:  BRA    1076
1072:  MOVLB  3
1074:  BRA    120C
....................       { 
....................          if(((SerialBuffer[0]=='O')&&(SerialBuffer[1]=='K'))||((SerialBuffer[1]=='O')&&(SerialBuffer[2]=='K'))) 
1076:  MOVF   1C,W
1078:  SUBLW  4F
107A:  BNZ   1082
107C:  MOVF   1D,W
107E:  SUBLW  4B
1080:  BZ    108E
1082:  MOVF   1D,W
1084:  SUBLW  4F
1086:  BNZ   1094
1088:  MOVF   1E,W
108A:  SUBLW  4B
108C:  BNZ   1094
....................          { 
....................             OK=1; 
108E:  BSF    x9F.3
....................             GSMOK=1; 
1090:  BSF    xE2.1
....................          } 
1092:  BRA    1202
....................          else 
....................          { 
....................              if(sms_index==0) 
1094:  MOVF   xDE,F
1096:  BTFSS  FD8.2
1098:  BRA    1194
....................              { 
....................                strcpy(buffer,SerialBuffer); 
109A:  MOVLW  01
109C:  MOVWF  FEA
109E:  MOVLW  C8
10A0:  MOVWF  FE9
10A2:  CLRF   FE2
10A4:  MOVLW  1C
10A6:  MOVWF  FE1
10A8:  MOVF   FE7,F
10AA:  MOVFF  FE6,FEE
10AE:  BNZ   10A8
....................                rs232_l=SerialBuffer_pos; 
10B0:  MOVFF  9E,354
....................                for(pos=0;pos<SerialBuffer_pos;pos++) 
10B4:  MOVLB  2
10B6:  CLRF   xA5
10B8:  MOVLB  0
10BA:  MOVF   x9E,W
10BC:  MOVLB  2
10BE:  SUBWF  xA5,W
10C0:  BC    1190
....................                { 
....................                   if(SerialBuffer[pos]=='+') 
10C2:  CLRF   03
10C4:  MOVF   xA5,W
10C6:  ADDLW  1C
10C8:  MOVWF  FE9
10CA:  MOVLW  00
10CC:  ADDWFC 03,W
10CE:  MOVWF  FEA
10D0:  MOVF   FEF,W
10D2:  SUBLW  2B
10D4:  BNZ   118C
....................                   { 
....................                     if((SerialBuffer[pos+2]=='M')&&(SerialBuffer[pos+3]=='T'))//CMTI 
10D6:  MOVLW  02
10D8:  ADDWF  xA5,W
10DA:  CLRF   03
10DC:  ADDLW  1C
10DE:  MOVWF  FE9
10E0:  MOVLW  00
10E2:  ADDWFC 03,W
10E4:  MOVWF  FEA
10E6:  MOVF   FEF,W
10E8:  SUBLW  4D
10EA:  BNZ   110E
10EC:  MOVLW  03
10EE:  ADDWF  xA5,W
10F0:  CLRF   03
10F2:  ADDLW  1C
10F4:  MOVWF  FE9
10F6:  MOVLW  00
10F8:  ADDWFC 03,W
10FA:  MOVWF  FEA
10FC:  MOVF   FEF,W
10FE:  SUBLW  54
1100:  BNZ   110E
....................                     {   
....................                        sms_index=1; 
1102:  MOVLW  01
1104:  MOVLB  0
1106:  MOVWF  xDE
....................                        sms_ok=1; 
1108:  BSF    x9F.4
....................                        index_l=0; 
110A:  MOVLB  2
110C:  CLRF   x70
....................                     } 
....................                     if((SerialBuffer[pos+2]=='U')&&(SerialBuffer[pos+3]=='S'))//CUSD 
110E:  MOVLW  02
1110:  ADDWF  xA5,W
1112:  CLRF   03
1114:  ADDLW  1C
1116:  MOVWF  FE9
1118:  MOVLW  00
111A:  ADDWFC 03,W
111C:  MOVWF  FEA
111E:  MOVF   FEF,W
1120:  SUBLW  55
1122:  BNZ   1148
1124:  MOVLW  03
1126:  ADDWF  xA5,W
1128:  CLRF   03
112A:  ADDLW  1C
112C:  MOVWF  FE9
112E:  MOVLW  00
1130:  ADDWFC 03,W
1132:  MOVWF  FEA
1134:  MOVF   FEF,W
1136:  SUBLW  53
1138:  BNZ   1148
....................                     { 
....................                         if(sold_ask) 
113A:  MOVLB  0
113C:  BTFSS  xA0.0
113E:  BRA    1146
....................                        { 
....................                            sold=1; 
1140:  BSF    x9F.7
....................                            sold_msg_l=SerialBuffer_pos; 
1142:  MOVFF  9E,2A6
1146:  MOVLB  2
....................                         } 
....................                     } 
....................                     if((SerialBuffer[pos+1]=='C')&&(SerialBuffer[pos+2]=='L'))//CUSD 
1148:  MOVLW  01
114A:  ADDWF  xA5,W
114C:  CLRF   03
114E:  ADDLW  1C
1150:  MOVWF  FE9
1152:  MOVLW  00
1154:  ADDWFC 03,W
1156:  MOVWF  FEA
1158:  MOVF   FEF,W
115A:  SUBLW  43
115C:  BNZ   118C
115E:  MOVLW  02
1160:  ADDWF  xA5,W
1162:  CLRF   03
1164:  ADDLW  1C
1166:  MOVWF  FE9
1168:  MOVLW  00
116A:  ADDWFC 03,W
116C:  MOVWF  FEA
116E:  MOVF   FEF,W
1170:  SUBLW  4C
1172:  BNZ   118C
....................                     { 
....................                         #ifdef DEBUG0 
....................                            fprintf(DEBUG,"RING\r\n"); 
1174:  MOVLW  64
1176:  MOVWF  FF6
1178:  MOVLW  12
117A:  MOVWF  FF7
117C:  MOVLB  0
117E:  RCALL  102C
....................                         #endif 
....................                         if(ring_count>0) 
1180:  MOVF   xE1,F
1182:  BZ    1188
....................                         { 
....................                            RING_FLG=1; 
1184:  BSF    x9F.0
....................                         }else ring_count++; 
1186:  BRA    118A
1188:  INCF   xE1,F
118A:  MOVLB  2
....................                          
....................                     } 
....................                   } 
118C:  INCF   xA5,F
118E:  BRA    10B8
....................                }   
....................              } 
1190:  BRA    11F6
1192:  MOVLB  0
....................              else if(sms_index==1) 
1194:  DECFSZ xDE,W
1196:  BRA    11BA
....................              { 
....................                 sms_buff_l=SerialBuffer_pos; 
1198:  MOVFF  9E,DF
....................                 strcpy(sms_buffer,SerialBuffer); 
119C:  MOVLW  02
119E:  MOVWF  FEA
11A0:  MOVLW  28
11A2:  MOVWF  FE9
11A4:  CLRF   FE2
11A6:  MOVLW  1C
11A8:  MOVWF  FE1
11AA:  MOVF   FE7,F
11AC:  MOVFF  FE6,FEE
11B0:  BNZ   11AA
....................                 sms_index=2; 
11B2:  MOVLW  02
11B4:  MOVWF  xDE
....................                 sms_ok=1; 
11B6:  BSF    x9F.4
....................                  
....................              } 
11B8:  BRA    11F4
....................              else if(sms_index==2)  
11BA:  MOVF   xDE,W
11BC:  SUBLW  02
11BE:  BNZ   11DE
....................              { 
....................                 
....................                 strcpy(sms_buffer0,SerialBuffer); 
11C0:  MOVLW  02
11C2:  MOVWF  FEA
11C4:  MOVLW  08
11C6:  MOVWF  FE9
11C8:  CLRF   FE2
11CA:  MOVLW  1C
11CC:  MOVWF  FE1
11CE:  MOVF   FE7,F
11D0:  MOVFF  FE6,FEE
11D4:  BNZ   11CE
....................                 sms_index=3; 
11D6:  MOVLW  03
11D8:  MOVWF  xDE
....................                 sms_ok=1; 
11DA:  BSF    x9F.4
....................              } 
11DC:  BRA    11F4
....................              else  
....................              { 
....................                if((SerialBuffer[0]=='B')&&(SerialBuffer[1]=='U')) fputc('|',DEBUG); 
11DE:  MOVF   1C,W
11E0:  SUBLW  42
11E2:  BNZ   11F4
11E4:  MOVF   1D,W
11E6:  SUBLW  55
11E8:  BNZ   11F4
11EA:  MOVLW  7C
11EC:  MOVLB  3
11EE:  MOVWF  xAE
11F0:  MOVLB  0
11F2:  RCALL  0FDA
11F4:  MOVLB  2
....................              } 
....................             OK=0; 
11F6:  MOVLB  0
11F8:  BCF    x9F.3
....................             no_ok=1; 
11FA:  MOVLW  01
11FC:  MOVLB  1
11FE:  MOVWF  xBE
1200:  MOVLB  0
....................          } 
....................          SerialBuffer_pos = 0; 
1202:  CLRF   x9E
....................          receive_flag = 1; 
1204:  BSF    x9F.1
....................          end_receive=1; 
1206:  BSF    x9F.2
....................          
....................       } 
1208:  BRA    125A
120A:  MOVLB  3
....................       else 
....................       { 
....................          if (Rx == 13)  
120C:  MOVF   x56,W
120E:  SUBLW  0D
1210:  BNZ   1218
....................          { 
....................             Rx0=13; 
1212:  MOVLW  0D
1214:  MOVWF  x57
....................          } 
1216:  BRA    125C
....................          else 
....................          { 
....................             if(Rx=='>')  
1218:  MOVF   x56,W
121A:  SUBLW  3E
121C:  BNZ   1232
....................             { 
....................                msg_tx=1; 
121E:  MOVLW  01
1220:  MOVLB  0
1222:  MOVWF  xDD
....................                #ifdef DEBUG0  
....................                   fputc('-',DEBUG); 
1224:  MOVLW  2D
1226:  MOVLB  3
1228:  MOVWF  xAE
122A:  MOVLB  0
122C:  RCALL  0FDA
....................                #endif 
....................             } 
122E:  BRA    125A
1230:  MOVLB  3
....................             else 
....................             { 
....................                SerialBuffer[SerialBuffer_pos] = Rx; 
1232:  CLRF   03
1234:  MOVLB  0
1236:  MOVF   x9E,W
1238:  ADDLW  1C
123A:  MOVWF  FE9
123C:  MOVLW  00
123E:  ADDWFC 03,W
1240:  MOVWF  FEA
1242:  MOVFF  356,FEF
....................                SerialBuffer_pos++; 
1246:  INCF   x9E,F
....................                SerialBuffer[SerialBuffer_pos] = 0; 
1248:  CLRF   03
124A:  MOVF   x9E,W
124C:  ADDLW  1C
124E:  MOVWF  FE9
1250:  MOVLW  00
1252:  ADDWFC 03,W
1254:  MOVWF  FEA
1256:  CLRF   FEF
....................                //receive_flag = 1; 
....................                end_receive=0; 
1258:  BCF    x9F.2
125A:  MOVLB  3
....................                 
....................             } 
....................          } 
....................       } 
....................  
125C:  BCF    F9E.5
125E:  MOVLB  0
1260:  GOTO   0060
.................... } 
....................  
....................  
.................... //****************************************************************************** 
.................... void sms() 
.................... { 
....................    #ifdef DEBUG0 
....................       fprintf(DEBUG,"ENVOYER LE MESSAGE au N=%s\r\n",n_tel_); 
*
2DC6:  MOVLW  6C
2DC8:  MOVWF  FF6
2DCA:  MOVLW  12
2DCC:  MOVWF  FF7
2DCE:  MOVLW  19
2DD0:  MOVLB  3
2DD2:  MOVWF  x87
2DD4:  MOVLB  0
2DD6:  CALL   21D4
2DDA:  MOVLW  03
2DDC:  MOVWF  FEA
2DDE:  MOVLW  49
2DE0:  MOVWF  FE9
2DE2:  CALL   20AE
2DE6:  CLRF   16
2DE8:  BTFSC  FF2.7
2DEA:  BSF    16.7
2DEC:  BCF    FF2.7
2DEE:  MOVLW  0D
2DF0:  MOVLB  3
2DF2:  MOVWF  xAE
2DF4:  MOVLB  0
2DF6:  CALL   0FDA
2DFA:  BTFSC  16.7
2DFC:  BSF    FF2.7
2DFE:  CLRF   16
2E00:  BTFSC  FF2.7
2E02:  BSF    16.7
2E04:  BCF    FF2.7
2E06:  MOVLW  0A
2E08:  MOVLB  3
2E0A:  MOVWF  xAE
2E0C:  MOVLB  0
2E0E:  CALL   0FDA
2E12:  BTFSC  16.7
2E14:  BSF    FF2.7
....................    #endif 
....................    #ifdef GPS0 
....................       get_gps_pos0(); 
2E16:  BRA    2790
2E18:  CLRF   16
2E1A:  BTFSC  FF2.7
2E1C:  BSF    16.7
2E1E:  BCF    FF2.7
....................       //get_gps_speed(speed1,direction0); 
....................    #endif 
....................    #ifdef DEBUG0 
....................       fprintf(DEBUG,"x=%s ; y=%s \n\r",x,y); 
2E20:  MOVLW  78
2E22:  MOVLB  3
2E24:  MOVWF  xAE
2E26:  MOVLB  0
2E28:  CALL   0FDA
2E2C:  BTFSC  16.7
2E2E:  BSF    FF2.7
2E30:  CLRF   16
2E32:  BTFSC  FF2.7
2E34:  BSF    16.7
2E36:  BCF    FF2.7
2E38:  MOVLW  3D
2E3A:  MOVLB  3
2E3C:  MOVWF  xAE
2E3E:  MOVLB  0
2E40:  CALL   0FDA
2E44:  BTFSC  16.7
2E46:  BSF    FF2.7
2E48:  CLRF   FEA
2E4A:  MOVLW  A1
2E4C:  MOVWF  FE9
2E4E:  CALL   20AE
2E52:  MOVLW  8E
2E54:  MOVWF  FF6
2E56:  MOVLW  12
2E58:  MOVWF  FF7
2E5A:  MOVLW  05
2E5C:  MOVLB  3
2E5E:  MOVWF  x87
2E60:  MOVLB  0
2E62:  CALL   21D4
2E66:  CLRF   FEA
2E68:  MOVLW  B0
2E6A:  MOVWF  FE9
2E6C:  CALL   20AE
2E70:  MOVLW  95
2E72:  MOVWF  FF6
2E74:  MOVLW  12
2E76:  MOVWF  FF7
2E78:  MOVLW  03
2E7A:  MOVLB  3
2E7C:  MOVWF  x87
2E7E:  MOVLB  0
2E80:  CALL   21D4
....................    #endif 
....................    start: 
....................    msg_tx=0; 
2E84:  CLRF   xDD
....................    //fprintf(GSM,"ATE1\r\n"); 
....................    delay_ms(1000); 
2E86:  MOVLW  04
2E88:  MOVLB  3
2E8A:  MOVWF  x79
2E8C:  MOVLW  FA
2E8E:  MOVWF  x8C
2E90:  MOVLB  0
2E92:  CALL   1750
2E96:  MOVLB  3
2E98:  DECFSZ x79,F
2E9A:  BRA    2E8C
....................    //fprintf(DEBUG,"ENVOYER LE MESSAGE au N=%s\r\n",n_tel_); 
....................    fprintf(GSM,"AT+CMGS=\"%s\"\r\n",n_tel_); 
2E9C:  MOVLW  9A
2E9E:  MOVWF  FF6
2EA0:  MOVLW  12
2EA2:  MOVWF  FF7
2EA4:  MOVLW  09
2EA6:  MOVWF  x87
2EA8:  MOVLB  0
2EAA:  CALL   1B8A
2EAE:  MOVLW  03
2EB0:  MOVWF  FEA
2EB2:  MOVLW  49
2EB4:  MOVWF  FE9
2EB6:  CALL   236C
2EBA:  MOVLW  A5
2EBC:  MOVWF  FF6
2EBE:  MOVLW  12
2EC0:  MOVWF  FF7
2EC2:  MOVLW  03
2EC4:  MOVLB  3
2EC6:  MOVWF  x87
2EC8:  MOVLB  0
2ECA:  CALL   1B8A
....................    //fprintf(DEBUG,"ENVOYER LE MESSAGE au N=%s\r\n",n_tel_); 
....................    //fprintf(GSM,"AT+CMGS=\"%s\"\r\n",n_tel_); 
....................    if(wait_(100)==1) 
2ECE:  MOVLB  3
2ED0:  CLRF   x7A
2ED2:  MOVLW  64
2ED4:  MOVWF  x79
2ED6:  MOVLB  0
2ED8:  RCALL  2D76
2EDA:  DECFSZ 01,W
2EDC:  BRA    30EA
....................    { 
....................        start1: 
....................        //fprintf(GSM,"ATE0\r\n"); 
....................        //fputc('+',DEBUG); 
....................        //fprintf(DEBUG,"AL2=%d\r\n",al2); 
....................        #ifdef ALARME 
....................        switch(al2) 
2EDE:  MOVLB  2
2EE0:  MOVF   xF9,W
2EE2:  XORLW  01
2EE4:  MOVLB  0
2EE6:  BZ    2EFE
2EE8:  XORLW  03
2EEA:  BZ    2F58
2EEC:  XORLW  01
2EEE:  BZ    2FB2
2EF0:  XORLW  06
2EF2:  BTFSC  FD8.2
2EF4:  BRA    300C
2EF6:  XORLW  03
2EF8:  BTFSC  FD8.2
2EFA:  BRA    3066
2EFC:  BRA    3074
....................        { 
....................          #ifdef GPS0 
....................             case 1:fprintf(GSM,"Alerte : Ouverture Des Portes du Vehicule  la Position :\r\n"); 
2EFE:  MOVLW  AA
2F00:  MOVWF  FF6
2F02:  MOVLW  12
2F04:  MOVWF  FF7
2F06:  CALL   1A4E
....................                    //fprintf(GSM,"x=%s ; y=%s ; z=%s\n\r",x,y,z); 
....................                    fprintf(GSM,"Pos=%s %s\r\n",x,y); 
2F0A:  MOVLW  E6
2F0C:  MOVWF  FF6
2F0E:  MOVLW  12
2F10:  MOVWF  FF7
2F12:  MOVLW  04
2F14:  MOVLB  3
2F16:  MOVWF  x87
2F18:  MOVLB  0
2F1A:  CALL   1B8A
2F1E:  CLRF   FEA
2F20:  MOVLW  A1
2F22:  MOVWF  FE9
2F24:  CALL   236C
2F28:  MOVLW  20
2F2A:  BTFSS  F9E.4
2F2C:  BRA    2F2A
2F2E:  MOVWF  FAD
2F30:  CLRF   FEA
2F32:  MOVLW  B0
2F34:  MOVWF  FE9
2F36:  CALL   236C
2F3A:  MOVLW  0D
2F3C:  BTFSS  F9E.4
2F3E:  BRA    2F3C
2F40:  MOVWF  FAD
2F42:  MOVLW  0A
2F44:  BTFSS  F9E.4
2F46:  BRA    2F44
2F48:  MOVWF  FAD
....................                    //fprintf(GSM,"Vit=%s Km/h\r\nDir=%s\r\n",speed1,Direction0); 
....................                    fprintf(GSM,"Vous Pouvez Localiser Votre Vehicule Via http://maps.google.com\r\n"); 
2F4A:  MOVLW  F2
2F4C:  MOVWF  FF6
2F4E:  MOVLW  12
2F50:  MOVWF  FF7
2F52:  CALL   1A4E
....................                    break; 
2F56:  BRA    30CC
....................             case 2:fprintf(GSM,"Alerte : Ouverture Du Capot du Vehicule  la Position :\r\n"); 
2F58:  MOVLW  34
2F5A:  MOVWF  FF6
2F5C:  MOVLW  13
2F5E:  MOVWF  FF7
2F60:  CALL   1A4E
....................                    fprintf(GSM,"Pos=%s %s\r\n",x,y); 
2F64:  MOVLW  6E
2F66:  MOVWF  FF6
2F68:  MOVLW  13
2F6A:  MOVWF  FF7
2F6C:  MOVLW  04
2F6E:  MOVLB  3
2F70:  MOVWF  x87
2F72:  MOVLB  0
2F74:  CALL   1B8A
2F78:  CLRF   FEA
2F7A:  MOVLW  A1
2F7C:  MOVWF  FE9
2F7E:  CALL   236C
2F82:  MOVLW  20
2F84:  BTFSS  F9E.4
2F86:  BRA    2F84
2F88:  MOVWF  FAD
2F8A:  CLRF   FEA
2F8C:  MOVLW  B0
2F8E:  MOVWF  FE9
2F90:  CALL   236C
2F94:  MOVLW  0D
2F96:  BTFSS  F9E.4
2F98:  BRA    2F96
2F9A:  MOVWF  FAD
2F9C:  MOVLW  0A
2F9E:  BTFSS  F9E.4
2FA0:  BRA    2F9E
2FA2:  MOVWF  FAD
....................                    //fprintf(GSM,"Vit=%s Km/h\r\nDir=%s\r\n",speed1,Direction0); 
....................                    fprintf(GSM,"Vous Pouvez Localiser Votre Vehicule Via http://maps.google.com\r\n"); 
2FA4:  MOVLW  7A
2FA6:  MOVWF  FF6
2FA8:  MOVLW  13
2FAA:  MOVWF  FF7
2FAC:  CALL   1A4E
....................                    break; 
2FB0:  BRA    30CC
....................             case 3:fprintf(GSM,"Alerte : Votre Vehicule  t Toucher  la Position :\r\n"); 
2FB2:  MOVLW  BC
2FB4:  MOVWF  FF6
2FB6:  MOVLW  13
2FB8:  MOVWF  FF7
2FBA:  CALL   1A4E
....................                    fprintf(GSM,"Pos=%s %s\r\n",x,y); 
2FBE:  MOVLW  F4
2FC0:  MOVWF  FF6
2FC2:  MOVLW  13
2FC4:  MOVWF  FF7
2FC6:  MOVLW  04
2FC8:  MOVLB  3
2FCA:  MOVWF  x87
2FCC:  MOVLB  0
2FCE:  CALL   1B8A
2FD2:  CLRF   FEA
2FD4:  MOVLW  A1
2FD6:  MOVWF  FE9
2FD8:  CALL   236C
2FDC:  MOVLW  20
2FDE:  BTFSS  F9E.4
2FE0:  BRA    2FDE
2FE2:  MOVWF  FAD
2FE4:  CLRF   FEA
2FE6:  MOVLW  B0
2FE8:  MOVWF  FE9
2FEA:  CALL   236C
2FEE:  MOVLW  0D
2FF0:  BTFSS  F9E.4
2FF2:  BRA    2FF0
2FF4:  MOVWF  FAD
2FF6:  MOVLW  0A
2FF8:  BTFSS  F9E.4
2FFA:  BRA    2FF8
2FFC:  MOVWF  FAD
....................                    //fprintf(GSM,"Vit=%s Km/h\r\nDir=%s\r\n",speed1,Direction0); 
....................                    fprintf(GSM,"Vous Pouvez Localiser Votre Vehicule Via http://maps.google.com\r\n"); 
2FFE:  MOVLW  00
3000:  MOVWF  FF6
3002:  MOVLW  14
3004:  MOVWF  FF7
3006:  CALL   1A4E
....................                    break; 
300A:  BRA    30CC
....................             case 5:fprintf(GSM,"Alerte : Arret du Vehicule commander par sms  la Position :\r\n"); 
300C:  MOVLW  42
300E:  MOVWF  FF6
3010:  MOVLW  14
3012:  MOVWF  FF7
3014:  CALL   1A4E
....................                    fprintf(GSM,"Pos=%s %s\r\n",x,y); 
3018:  MOVLW  82
301A:  MOVWF  FF6
301C:  MOVLW  14
301E:  MOVWF  FF7
3020:  MOVLW  04
3022:  MOVLB  3
3024:  MOVWF  x87
3026:  MOVLB  0
3028:  CALL   1B8A
302C:  CLRF   FEA
302E:  MOVLW  A1
3030:  MOVWF  FE9
3032:  CALL   236C
3036:  MOVLW  20
3038:  BTFSS  F9E.4
303A:  BRA    3038
303C:  MOVWF  FAD
303E:  CLRF   FEA
3040:  MOVLW  B0
3042:  MOVWF  FE9
3044:  CALL   236C
3048:  MOVLW  0D
304A:  BTFSS  F9E.4
304C:  BRA    304A
304E:  MOVWF  FAD
3050:  MOVLW  0A
3052:  BTFSS  F9E.4
3054:  BRA    3052
3056:  MOVWF  FAD
....................                    //fprintf(GSM,"Vit=%s Km/h\r\nDir=%s\r\n",speed1,Direction0); 
....................                    fprintf(GSM,"Vous Pouvez Localiser Votre Vehicule Via http://maps.google.com\r\n"); 
3058:  MOVLW  8E
305A:  MOVWF  FF6
305C:  MOVLW  14
305E:  MOVWF  FF7
3060:  CALL   1A4E
....................                    break; 
3064:  BRA    30CC
....................             case 6:fprintf(GSM,"Alerte : Le Solde de Votre Puce d'Alarme est en dessous du Solde Minimum :"); 
3066:  MOVLW  D0
3068:  MOVWF  FF6
306A:  MOVLW  14
306C:  MOVWF  FF7
306E:  CALL   1A4E
....................                    break; 
3072:  BRA    30CC
....................             default:fprintf(GSM,"Pas D'alerte :Vehicule  la Position :\r\n"); 
3074:  MOVLW  1C
3076:  MOVWF  FF6
3078:  MOVLW  15
307A:  MOVWF  FF7
307C:  CALL   1A4E
....................                    fprintf(GSM,"Pos=%s %s\r\n",x,y); 
3080:  MOVLW  46
3082:  MOVWF  FF6
3084:  MOVLW  15
3086:  MOVWF  FF7
3088:  MOVLW  04
308A:  MOVLB  3
308C:  MOVWF  x87
308E:  MOVLB  0
3090:  CALL   1B8A
3094:  CLRF   FEA
3096:  MOVLW  A1
3098:  MOVWF  FE9
309A:  CALL   236C
309E:  MOVLW  20
30A0:  BTFSS  F9E.4
30A2:  BRA    30A0
30A4:  MOVWF  FAD
30A6:  CLRF   FEA
30A8:  MOVLW  B0
30AA:  MOVWF  FE9
30AC:  CALL   236C
30B0:  MOVLW  0D
30B2:  BTFSS  F9E.4
30B4:  BRA    30B2
30B6:  MOVWF  FAD
30B8:  MOVLW  0A
30BA:  BTFSS  F9E.4
30BC:  BRA    30BA
30BE:  MOVWF  FAD
....................                    //fprintf(GSM,"Vit=%s Km/h\r\nDir=%s\r\n",speed1,Direction0); 
....................                    fprintf(GSM,"Vous Pouvez Localiser Votre Vehicule Via http://maps.google.com\r\n"); 
30C0:  MOVLW  52
30C2:  MOVWF  FF6
30C4:  MOVLW  15
30C6:  MOVWF  FF7
30C8:  CALL   1A4E
....................          #else 
....................             case 1:fprintf(GSM,"Alerte : Ouverture Des Portes du Vehicule."); 
....................                    break; 
....................             case 2:fprintf(GSM,"Alerte : Ouverture Du Capot du Vehicule."); 
....................                    break; 
....................             case 3:fprintf(GSM,"Alerte : Vehicule Touche."); 
....................                    break; 
....................             case 5:fprintf(GSM,"Alerte : Arret du Vehicule commander par sms."); 
....................                    break; 
....................             case 6:fprintf(GSM,"Alerte : Le Solde de Votre Puce d'Alarme est en dessous du Solde Minimum."); 
....................                    break; 
....................             default: fprintf(GSM,"Pas D'alerte."); 
....................                    
....................          #endif 
....................        } 
....................        #else 
....................         #ifdef GPS0 
....................             switch(al0) 
....................             { 
....................             case 1: 
....................                   fprintf(GSM,"Alerte : Alarme Activee  la Position :\r\n"); 
....................                   fprintf(GSM,"Lat=%s\r\nLng=%s\r\nAtd=%s\n\r",x,y,z); 
....................                   //fprintf(GSM,"Vit=%s Km/h\r\nDir=%s\r\n",speed1,Direction0); 
....................                   fprintf(GSM,"Vous Pouvez Localiser Votre Vehicule Via http://maps.google.com\r\n"); 
....................                   break; 
....................             case 5:fprintf(GSM,"Alerte : Arret du Vehicule commander par sms  la Position :\r\n"); 
....................                    fprintf(GSM,"Lat=%s\r\nLng=%s\r\nAtd=%s\n\r",x,y,z); 
....................                    //fprintf(GSM,"Vit=%s Km/h\r\nDir=%s\r\n",speed1,Direction0); 
....................                    fprintf(GSM,"Vous Pouvez Localiser Votre Vehicule Via http://maps.google.com\r\n"); 
....................                    break; 
....................             case 6:fprintf(GSM,"Alerte : Le Solde de Votre Puce d'Alarme est en dessous du Solde Minimum :"); 
....................                    break; 
....................             default:fprintf(GSM,"Pas D'alerte :Vehicule  la Position :\r\n"); 
....................                    fprintf(GSM,"Lat=%s\r\nLng=%s\r\nAtd=%s\n\r",x,y,z); 
....................                    //fprintf(GSM,"Vit=%s Km/h\r\nDir=%s\r\n",speed1,Direction0); 
....................                    fprintf(GSM,"Vous Pouvez Localiser Votre Vehicule Via http://maps.google.com\r\n"); 
....................             } 
....................          #else 
....................          switch(al0) 
....................          { 
....................             case 1: fprintf(GSM,"Alerte : Alarme Activee.");break; 
....................             case 5:fprintf(GSM,"Alerte : Arret du Vehicule commander par sms."); 
....................                    break; 
....................             case 6:fprintf(GSM,"Alerte : Le Solde de Votre Puce d'Alarme est en dessous du Solde Minimum."); 
....................                    break; 
....................             default: fprintf(GSM,"Pas D'alerte."); 
....................          }             
....................          #endif 
....................        #endif 
....................        delay_ms(2000); 
30CC:  MOVLW  08
30CE:  MOVLB  3
30D0:  MOVWF  x79
30D2:  MOVLW  FA
30D4:  MOVWF  x8C
30D6:  MOVLB  0
30D8:  CALL   1750
30DC:  MOVLB  3
30DE:  DECFSZ x79,F
30E0:  BRA    30D2
....................        fputc(0x1a,GSM); 
30E2:  MOVLW  1A
30E4:  MOVLB  0
30E6:  RCALL  2DBE
....................        //output_low(led); 
....................        msg_tx=0; 
30E8:  CLRF   xDD
....................                 // goto start1;*/ 
....................    } 
30EA:  RETURN 0
....................    //else goto start; 
.................... } 
.................... //******************************************************************************/ 
....................  
.................... int tx() 
.................... {        int n0; 
....................          if(arret_flag)  
30EC:  BTFSS  19.0
30EE:  BRA    30FA
....................          { 
....................             #ifdef ALARME 
....................             RL_ARR=1; 
30F0:  BSF    17.5
....................             write_alarm_outputs(out); 
30F2:  MOVFF  17,37A
30F6:  CALL   1950
....................             #else 
....................             output_high(RL_ARR); 
....................             #endif 
....................          } 
....................          for(n0=0;n0<2;n0++) 
30FA:  MOVLB  3
30FC:  CLRF   x78
30FE:  MOVF   x78,W
3100:  SUBLW  01
3102:  BNC   31EA
....................          { 
....................             read_tel_n(n0,tel_n); 
3104:  MOVFF  378,379
3108:  MOVLW  02
310A:  MOVWF  x7B
310C:  MOVLW  8F
310E:  MOVWF  x7A
3110:  MOVLB  0
3112:  CALL   2306
....................             //start: 
....................             #ifdef DEBUG0 
....................                fprintf(DEBUG,"BIP au N=%s\r\n",tel_n); 
3116:  MOVLW  94
3118:  MOVWF  FF6
311A:  MOVLW  15
311C:  MOVWF  FF7
311E:  MOVLW  0A
3120:  MOVLB  3
3122:  MOVWF  x87
3124:  MOVLB  0
3126:  CALL   21D4
312A:  MOVLW  02
312C:  MOVWF  FEA
312E:  MOVLW  8F
3130:  MOVWF  FE9
3132:  CALL   20AE
3136:  CLRF   16
3138:  BTFSC  FF2.7
313A:  BSF    16.7
313C:  BCF    FF2.7
313E:  MOVLW  0D
3140:  MOVLB  3
3142:  MOVWF  xAE
3144:  MOVLB  0
3146:  CALL   0FDA
314A:  BTFSC  16.7
314C:  BSF    FF2.7
314E:  CLRF   16
3150:  BTFSC  FF2.7
3152:  BSF    16.7
3154:  BCF    FF2.7
3156:  MOVLW  0A
3158:  MOVLB  3
315A:  MOVWF  xAE
315C:  MOVLB  0
315E:  CALL   0FDA
3162:  BTFSC  16.7
3164:  BSF    FF2.7
....................             #endif 
....................             if (bip(tel_n)) 
3166:  MOVLW  02
3168:  MOVLB  3
316A:  MOVWF  x7A
316C:  MOVLW  8F
316E:  MOVWF  x79
3170:  MOVLB  0
3172:  GOTO   2392
3176:  MOVF   01,F
3178:  BZ    319C
....................             { 
....................                strcpy(n_tel_,tel_n); 
317A:  MOVLW  03
317C:  MOVWF  FEA
317E:  MOVLW  49
3180:  MOVWF  FE9
3182:  MOVLW  02
3184:  MOVWF  FE2
3186:  MOVLW  8F
3188:  MOVWF  FE1
318A:  MOVF   FE7,F
318C:  MOVFF  FE6,FEE
3190:  BNZ   318A
....................                sms(); 
3192:  RCALL  2DC6
....................                //output_low(led); 
....................                return 1; 
3194:  MOVLW  01
3196:  MOVWF  01
3198:  BRA    31EA
....................             } 
....................             #ifdef DEBUG0 
319A:  BRA    31D0
....................             else   fprintf(DEBUG," le N=%s est hors champ\r\n",tel_n); 
319C:  MOVLW  A4
319E:  MOVWF  FF6
31A0:  MOVLW  15
31A2:  MOVWF  FF7
31A4:  MOVLW  07
31A6:  MOVLB  3
31A8:  MOVWF  x87
31AA:  MOVLB  0
31AC:  CALL   21D4
31B0:  MOVLW  02
31B2:  MOVWF  FEA
31B4:  MOVLW  8F
31B6:  MOVWF  FE9
31B8:  CALL   20AE
31BC:  MOVLW  AD
31BE:  MOVWF  FF6
31C0:  MOVLW  15
31C2:  MOVWF  FF7
31C4:  MOVLW  11
31C6:  MOVLB  3
31C8:  MOVWF  x87
31CA:  MOVLB  0
31CC:  CALL   21D4
....................             #endif 
....................             delay_ms(2000); 
31D0:  MOVLW  08
31D2:  MOVLB  3
31D4:  MOVWF  x79
31D6:  MOVLW  FA
31D8:  MOVWF  x8C
31DA:  MOVLB  0
31DC:  CALL   1750
31E0:  MOVLB  3
31E2:  DECFSZ x79,F
31E4:  BRA    31D6
31E6:  INCF   x78,F
31E8:  BRA    30FE
31EA:  MOVLB  0
....................          }    
31EC:  GOTO   44CC (RETURN)
....................         
.................... } 
....................  
.................... //************************************************************************************************* 
.................... #ifndef ALARME 
.................... #int_EXT2 
.................... void EXT2_isr(void) 
.................... { 
....................    al0=1; 
....................    fprintf(DEBUG,"EXT int\r\n"); 
....................    tx(); 
.................... } 
.................... #endif 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // M A I N 
.................... // 
.................... /////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void main(void)  
*
3AE4:  CLRF   FF8
3AE6:  BCF    FD0.7
3AE8:  BSF    07.7
3AEA:  BCF    F93.0
3AEC:  BCF    F8A.0
3AEE:  BCF    F92.2
3AF0:  BSF    F89.2
3AF2:  BSF    FB8.3
3AF4:  MOVLW  E1
3AF6:  MOVWF  FAF
3AF8:  MOVLW  04
3AFA:  MOVWF  FB0
3AFC:  MOVLW  A6
3AFE:  MOVWF  FAC
3B00:  MOVLW  90
3B02:  MOVWF  FAB
3B04:  BCF    F92.2
3B06:  BSF    F89.2
3B08:  CLRF   x9C
3B0A:  CLRF   x9D
3B0C:  CLRF   x9E
3B0E:  CLRF   xDD
3B10:  CLRF   xDE
3B12:  CLRF   xE1
3B14:  MOVLW  28
3B16:  MOVWF  xE3
3B18:  MOVLB  1
3B1A:  CLRF   xBD
3B1C:  CLRF   xC5
3B1E:  CLRF   xC7
3B20:  MOVLB  2
3B22:  CLRF   x70
3B24:  CLRF   x86
3B26:  CLRF   x85
3B28:  CLRF   x8A
3B2A:  MOVLW  64
3B2C:  MOVWF  x89
3B2E:  CLRF   x8E
3B30:  CLRF   x8D
3B32:  CLRF   x8C
3B34:  CLRF   x8B
3B36:  BSF    FB8.3
3B38:  MOVLW  E1
3B3A:  MOVWF  FAF
3B3C:  MOVLW  04
3B3E:  MOVWF  FB0
3B40:  MOVLW  A6
3B42:  MOVWF  FAC
3B44:  MOVLW  90
3B46:  MOVWF  FAB
3B48:  CLRF   xF8
3B4A:  MOVLB  3
3B4C:  CLRF   x53
3B4E:  CLRF   x55
3B50:  CLRF   x70
3B52:  CLRF   x75
3B54:  MOVF   FC1,W
3B56:  ANDLW  C0
3B58:  IORLW  0F
3B5A:  MOVWF  FC1
3B5C:  MOVLW  07
3B5E:  MOVWF  FB4
3B60:  BRA    3B94
3B62:  DATA 02,00
3B64:  DATA 1A,00
3B66:  DATA 00,28
3B68:  DATA 02,CF
3B6A:  DATA 76,2E
3B6C:  DATA 31,2E
3B6E:  DATA 32,00
3B70:  DATA 41,4C
3B72:  DATA 5F,35
3B74:  DATA 34,38
3B76:  DATA 00,20
3B78:  DATA 45,4D
3B7A:  DATA 4E,54
3B7C:  DATA 20,32
3B7E:  DATA 30,30
3B80:  DATA 39,00
3B82:  DATA 77,77
3B84:  DATA 77,2E
3B86:  DATA 65,6D
3B88:  DATA 6E,74
3B8A:  DATA 2D,64
3B8C:  DATA 7A,2E
3B8E:  DATA 63,6F
3B90:  DATA 6D,00
3B92:  DATA 00,00
3B94:  MOVLW  00
3B96:  MOVWF  FF8
3B98:  MOVLW  3B
3B9A:  MOVWF  FF7
3B9C:  MOVLW  62
3B9E:  MOVWF  FF6
3BA0:  TBLRD*+
3BA2:  MOVF   FF5,W
3BA4:  MOVWF  00
3BA6:  XORLW  00
3BA8:  BZ    3BD0
3BAA:  TBLRD*+
3BAC:  MOVF   FF5,W
3BAE:  MOVWF  01
3BB0:  BTFSC  FE8.7
3BB2:  BRA    3BBE
3BB4:  ANDLW  0F
3BB6:  MOVWF  FEA
3BB8:  TBLRD*+
3BBA:  MOVFF  FF5,FE9
3BBE:  BTFSC  01.6
3BC0:  TBLRD*+
3BC2:  BTFSS  01.6
3BC4:  TBLRD*+
3BC6:  MOVFF  FF5,FEE
3BCA:  DCFSNZ 00,F
3BCC:  BRA    3BA0
3BCE:  BRA    3BC2
3BD0:  CLRF   FF8
.................... { 
....................    char etat,m1; 
....................    #ifdef ALARME 
....................       #ifdef GPS 
....................       set_tris_a(0B11001001); 
....................       #else 
....................       set_tris_a(0B11011011); 
3BD2:  MOVLW  DB
3BD4:  MOVWF  F92
....................       #endif 
....................       set_tris_b(0B11110011); 
3BD6:  MOVLW  F3
3BD8:  MOVWF  F93
....................       set_tris_c(0B10111111); 
3BDA:  MOVLW  BF
3BDC:  MOVWF  F94
....................    #else  
....................       set_tris_b(0B11110011); 
....................       #ifdef GPS 
....................       set_tris_a(0B11101001); 
....................       set_tris_c(0B10111101); 
....................       #else 
....................       set_tris_a(0B11110101); 
....................       set_tris_c(0B10111111); 
....................       #endif 
....................    #endif 
....................    setup_comparator(NC_NC_NC_NC); 
3BDE:  MOVLW  07
3BE0:  MOVWF  FB4
3BE2:  MOVF   F92,W
3BE4:  MOVWF  F92
3BE6:  MOVLW  27
3BE8:  MOVWF  00
3BEA:  DECFSZ 00,F
3BEC:  BRA    3BEA
3BEE:  BRA    3BF0
3BF0:  MOVF   FB4,W
3BF2:  BCF    FA1.6
....................    enable_interrupts(INT_RDA); 
3BF4:  BSF    F9D.5
....................    enable_interrupts(GLOBAL); 
3BF6:  MOVLW  C0
3BF8:  IORWF  FF2,F
....................    fprintf(DEBUG,"EMNT GPS system\r\n"); 
3BFA:  MOVLW  C0
3BFC:  MOVWF  FF6
3BFE:  MOVLW  15
3C00:  MOVWF  FF7
3C02:  CLRF   16
3C04:  BTFSC  FF2.7
3C06:  BSF    16.7
3C08:  BCF    FF2.7
3C0A:  MOVLB  0
3C0C:  CALL   102C
3C10:  BTFSC  16.7
3C12:  BSF    FF2.7
....................    #ifdef GPS0 
....................    init_GPS0(); 
3C14:  GOTO   18DC
....................    #endif 
....................    #ifdef GPSTEST 
....................    //init_GPS0(); 
....................    while(1) 
....................    { 
....................       delay_ms(5000); 
....................       get_gps_pos0(); 
....................       fprintf(DEBUG,"x=%s ; y=%s\n\r",x,y); 
....................    } 
....................    #endif 
....................    #ifdef ALARME 
....................    RL_ARR=1; 
3C18:  BSF    17.5
....................    LED=1; 
3C1A:  BSF    17.0
....................    write_alarm_outputs(out); 
3C1C:  MOVFF  17,37A
3C20:  CALL   1950
....................    delay_ms(1000); 
3C24:  MOVLW  04
3C26:  MOVLB  3
3C28:  MOVWF  x78
3C2A:  MOVLW  FA
3C2C:  MOVWF  x8C
3C2E:  MOVLB  0
3C30:  CALL   1750
3C34:  MOVLB  3
3C36:  DECFSZ x78,F
3C38:  BRA    3C2A
....................    LED=0; 
3C3A:  BCF    17.0
....................    write_alarm_outputs(out); 
3C3C:  MOVFF  17,37A
3C40:  MOVLB  0
3C42:  CALL   1950
....................    delay_ms(1000); 
3C46:  MOVLW  04
3C48:  MOVLB  3
3C4A:  MOVWF  x78
3C4C:  MOVLW  FA
3C4E:  MOVWF  x8C
3C50:  MOVLB  0
3C52:  CALL   1750
3C56:  MOVLB  3
3C58:  DECFSZ x78,F
3C5A:  BRA    3C4C
....................    #else 
....................    output_drive(LED); 
....................    output_high(RL_ARR); 
....................    output_high(LED); 
....................    #endif 
....................     
....................    if(!input(USB_CON_SENSE_PIN)) 
3C5C:  BTFSC  F81.0
3C5E:  BRA    3C68
....................    { 
....................       //delay_ms(1000); 
....................       SIM_PowerOn(); 
3C60:  MOVLB  0
3C62:  GOTO   1A70
3C66:  MOVLB  3
....................       //#ifdef ALARME 
....................       //LED=1; 
....................       //write_alarm_outputs(out); 
....................       //delay_ms(7000); 
....................       //LED=0; 
....................       //write_alarm_outputs(out); 
....................       //#else 
....................       //delay_ms(7000); 
....................       //#endif 
....................    } 
....................     
....................    etat=read_eeprom(255); 
3C68:  MOVFF  FF2,378
3C6C:  BCF    FF2.7
3C6E:  SETF   FA9
3C70:  BCF    FA6.6
3C72:  BCF    FA6.7
3C74:  BSF    FA6.0
3C76:  MOVF   FA8,W
3C78:  BTFSC  x78.7
3C7A:  BSF    FF2.7
3C7C:  MOVWF  x76
....................    if (etat==1)  
3C7E:  DECFSZ x76,W
3C80:  BRA    3CB2
....................    { 
....................       SIM2EEPROM(1); 
3C82:  MOVLW  01
3C84:  MOVWF  x78
3C86:  MOVLB  0
3C88:  CALL   1D0C
....................       SIM2EEPROM(2); 
3C8C:  MOVLW  02
3C8E:  MOVLB  3
3C90:  MOVWF  x78
3C92:  MOVLB  0
3C94:  CALL   1D0C
....................       SIM2EEPROM(3); 
3C98:  MOVLW  03
3C9A:  MOVLB  3
3C9C:  MOVWF  x78
3C9E:  MOVLB  0
3CA0:  CALL   1D0C
....................       SIM2EEPROM(4); 
3CA4:  MOVLW  04
3CA6:  MOVLB  3
3CA8:  MOVWF  x78
3CAA:  MOVLB  0
3CAC:  CALL   1D0C
3CB0:  MOVLB  3
....................    } 
....................    if(input(USB_CON_SENSE_PIN)) 
3CB2:  BTFSS  F81.0
3CB4:  BRA    3CCE
....................    { 
....................       disable_interrupts(global); 
3CB6:  BCF    FF2.6
3CB8:  BCF    FF2.7
3CBA:  BTFSC  FF2.7
3CBC:  BRA    3CB8
....................       usb_init(); 
3CBE:  MOVLB  0
3CC0:  GOTO   1E96
....................       usb_task();  
3CC4:  CALL   1E62
....................       enable_interrupts(global); 
3CC8:  MOVLW  C0
3CCA:  IORWF  FF2,F
3CCC:  MOVLB  3
....................    } 
....................     
....................    #ifndef ALARME 
....................    //ext_int_edge( 2, H_TO_L); 
....................    //enable_interrupts(INT_EXT2); 
....................    #endif 
....................    //************************************************************************** 
....................    msg_ok=1; 
3CCE:  BSF    18.7
....................    fprintf(DEBUG,"While\r\n"); 
3CD0:  MOVLW  D2
3CD2:  MOVWF  FF6
3CD4:  MOVLW  15
3CD6:  MOVWF  FF7
3CD8:  CLRF   16
3CDA:  BTFSC  FF2.7
3CDC:  BSF    16.7
3CDE:  BCF    FF2.7
3CE0:  MOVLB  0
3CE2:  CALL   102C
3CE6:  BTFSC  16.7
3CE8:  BSF    FF2.7
....................    while (TRUE) 
....................    { 
....................       if(input(USB_CON_SENSE_PIN))// Connection USB 
3CEA:  BTFSS  F81.0
3CEC:  BRA    4360
....................       { 
....................          if(usb_enumerated()) 
3CEE:  GOTO   1EAE
3CF2:  MOVF   01,F
3CF4:  BTFSC  FD8.2
3CF6:  BRA    4358
....................          { 
....................           
....................             if (usb_kbhit(1)) 
3CF8:  MOVLW  01
3CFA:  MOVLB  3
3CFC:  MOVWF  x78
3CFE:  MOVLB  0
3D00:  GOTO   1EBA
3D04:  MOVF   01,F
3D06:  BTFSC  FD8.2
3D08:  BRA    4358
....................             {   
....................                for(k=0;k<Lenbuf;k++) recbuf[k]=0; 
3D0A:  MOVLB  3
3D0C:  CLRF   x71
3D0E:  MOVF   x71,W
3D10:  SUBLW  1F
3D12:  BNC   3D28
3D14:  CLRF   03
3D16:  MOVF   x71,W
3D18:  ADDLW  FE
3D1A:  MOVWF  FE9
3D1C:  MOVLW  02
3D1E:  ADDWFC 03,W
3D20:  MOVWF  FEA
3D22:  CLRF   FEF
3D24:  INCF   x71,F
3D26:  BRA    3D0E
....................                usb_get_packet(1, recbuf, Lenbuf); 
3D28:  MOVLW  01
3D2A:  MOVWF  x78
3D2C:  MOVLW  02
3D2E:  MOVWF  x7A
3D30:  MOVLW  FE
3D32:  MOVWF  x79
3D34:  CLRF   x7C
3D36:  MOVLW  20
3D38:  MOVWF  x7B
3D3A:  MOVLB  0
3D3C:  GOTO   1FBC
....................                switch(RecCommand) 
3D40:  MOVLW  01
3D42:  MOVLB  2
3D44:  SUBWF  xFE,W
3D46:  ADDLW  E7
3D48:  BTFSC  FD8.0
3D4A:  BRA    435A
3D4C:  ADDLW  19
3D4E:  MOVLB  0
3D50:  GOTO   4C82
....................                { 
....................                   case SAVE_N:// Sauvgarde des nemuros de telephones 
....................                   { 
....................                      n=recbuf[2]-49; 
3D54:  MOVLW  31
3D56:  MOVLB  3
3D58:  SUBWF  x00,W
3D5A:  MOVWF  x72
....................                      //printf("%d %s\r\n",n,recbuf); 
....................                      n0=n*10; 
3D5C:  MOVF   x72,W
3D5E:  MULLW  0A
3D60:  MOVFF  FF3,373
....................                      for(g=0;g<10;g++)  
3D64:  CLRF   x74
3D66:  MOVF   x74,W
3D68:  SUBLW  09
3D6A:  BNC   3DE4
....................                      { 
....................                         tel_n[g]=recbuf[g+4]; 
3D6C:  CLRF   03
3D6E:  MOVF   x74,W
3D70:  ADDLW  8F
3D72:  MOVWF  01
3D74:  MOVLW  02
3D76:  ADDWFC 03,F
3D78:  MOVFF  03,379
3D7C:  MOVLW  04
3D7E:  ADDWF  x74,W
3D80:  CLRF   03
3D82:  ADDLW  FE
3D84:  MOVWF  FE9
3D86:  MOVLW  02
3D88:  ADDWFC 03,W
3D8A:  MOVWF  FEA
3D8C:  MOVFF  FEF,37A
3D90:  MOVFF  379,FEA
3D94:  MOVFF  01,FE9
3D98:  MOVFF  37A,FEF
....................                         write_eeprom(n0+g,tel_n[g]); 
3D9C:  MOVF   x74,W
3D9E:  ADDWF  x73,W
3DA0:  MOVWF  x78
3DA2:  CLRF   03
3DA4:  MOVF   x74,W
3DA6:  ADDLW  8F
3DA8:  MOVWF  FE9
3DAA:  MOVLW  02
3DAC:  ADDWFC 03,W
3DAE:  MOVWF  FEA
3DB0:  MOVFF  FEF,379
3DB4:  MOVF   FF2,W
3DB6:  MOVWF  00
3DB8:  BCF    FF2.7
3DBA:  MOVFF  378,FA9
3DBE:  MOVFF  379,FA8
3DC2:  BCF    FA6.6
3DC4:  BCF    FA6.7
3DC6:  BSF    FA6.2
3DC8:  MOVLB  F
3DCA:  MOVLW  55
3DCC:  MOVWF  FA7
3DCE:  MOVLW  AA
3DD0:  MOVWF  FA7
3DD2:  BSF    FA6.1
3DD4:  BTFSC  FA6.1
3DD6:  BRA    3DD4
3DD8:  BCF    FA6.2
3DDA:  MOVF   00,W
3DDC:  IORWF  FF2,F
3DDE:  MOVLB  3
3DE0:  INCF   x74,F
3DE2:  BRA    3D66
....................                      } 
....................                      // WritePhoneBook(n,tel_n,' '); 
....................                      break; 
3DE4:  MOVLB  2
3DE6:  BRA    435A
3DE8:  MOVLB  0
....................                   } 
....................                   case SAVE_MSG:// Sauvgarde des messages 
....................                   { 
....................                      n=recbuf[2]-49; 
3DEA:  MOVLW  31
3DEC:  MOVLB  3
3DEE:  SUBWF  x00,W
3DF0:  MOVWF  x72
....................                      //printf("%d %s\r\n",Lenbuf,recbuf); 
....................                      n=n*32+40; 
3DF2:  MOVF   x72,W
3DF4:  MULLW  20
3DF6:  MOVF   FF3,W
3DF8:  ADDLW  28
3DFA:  MOVWF  x72
....................                      for(g=4;g<Lenbuf;g++) write_eeprom(n+(g-4),recbuf[g]); 
3DFC:  MOVLW  04
3DFE:  MOVWF  x74
3E00:  MOVF   x74,W
3E02:  SUBLW  1F
3E04:  BNC   3E50
3E06:  MOVLW  04
3E08:  SUBWF  x74,W
3E0A:  ADDWF  x72,W
3E0C:  MOVWF  x78
3E0E:  CLRF   03
3E10:  MOVF   x74,W
3E12:  ADDLW  FE
3E14:  MOVWF  FE9
3E16:  MOVLW  02
3E18:  ADDWFC 03,W
3E1A:  MOVWF  FEA
3E1C:  MOVFF  FEF,379
3E20:  MOVF   FF2,W
3E22:  MOVWF  00
3E24:  BCF    FF2.7
3E26:  MOVFF  378,FA9
3E2A:  MOVFF  379,FA8
3E2E:  BCF    FA6.6
3E30:  BCF    FA6.7
3E32:  BSF    FA6.2
3E34:  MOVLB  F
3E36:  MOVLW  55
3E38:  MOVWF  FA7
3E3A:  MOVLW  AA
3E3C:  MOVWF  FA7
3E3E:  BSF    FA6.1
3E40:  BTFSC  FA6.1
3E42:  BRA    3E40
3E44:  BCF    FA6.2
3E46:  MOVF   00,W
3E48:  IORWF  FF2,F
3E4A:  MOVLB  3
3E4C:  INCF   x74,F
3E4E:  BRA    3E00
....................                      break; 
3E50:  MOVLB  2
3E52:  BRA    435A
3E54:  MOVLB  0
....................                   } 
....................                   case READ_MSG:// Licture des messages 
....................                   { 
....................                      //n=recbuf[2]-49; 
....................                      //printf("%d %s\r\n",Lenbuf,recbuf); 
....................                      //n=n*32+40; 
....................                      //for(g=4;g<Lenbuf;g++) write_eeprom(n+(g-4),recbuf[g]); 
....................                      break; 
3E56:  MOVLB  2
3E58:  BRA    435A
3E5A:  MOVLB  0
....................                   } 
....................                   //------------------------------------------------------------ 
....................                   case READ_N1:// Licture des n tel 1 
....................                   {   
....................                      for(g=0;g<10;g++)  
3E5C:  MOVLB  3
3E5E:  CLRF   x74
3E60:  MOVF   x74,W
3E62:  SUBLW  09
3E64:  BNC   3E90
....................                      { 
....................                         txt[g]=read_eeprom(g); 
3E66:  CLRF   03
3E68:  MOVF   x74,W
3E6A:  ADDLW  DC
3E6C:  MOVWF  FE9
3E6E:  MOVLW  02
3E70:  ADDWFC 03,W
3E72:  MOVWF  FEA
3E74:  MOVFF  FF2,37A
3E78:  BCF    FF2.7
3E7A:  MOVFF  374,FA9
3E7E:  BCF    FA6.6
3E80:  BCF    FA6.7
3E82:  BSF    FA6.0
3E84:  MOVF   FA8,W
3E86:  BTFSC  x7A.7
3E88:  BSF    FF2.7
3E8A:  MOVWF  FEF
3E8C:  INCF   x74,F
3E8E:  BRA    3E60
....................                      } 
....................                     usb_put_packet(1,txt,10,USB_DTS_TOGGLE); 
3E90:  MOVLW  01
3E92:  MOVWF  x78
3E94:  MOVLW  02
3E96:  MOVWF  x7A
3E98:  MOVLW  DC
3E9A:  MOVWF  x79
3E9C:  CLRF   x7C
3E9E:  MOVLW  0A
3EA0:  MOVWF  x7B
3EA2:  MOVLW  02
3EA4:  MOVWF  x7D
3EA6:  MOVLB  0
3EA8:  CALL   2006
....................                     break; 
3EAC:  MOVLB  2
3EAE:  BRA    435A
3EB0:  MOVLB  0
....................                   } 
....................                   //------------------------------------------------------------ 
....................                   case READ_N2:// Licture des n tel 2 
....................                   {   
....................                      for(g=0;g<10;g++)  
3EB2:  MOVLB  3
3EB4:  CLRF   x74
3EB6:  MOVF   x74,W
3EB8:  SUBLW  09
3EBA:  BNC   3EEC
....................                      { 
....................                         txt[g]=read_eeprom(g+10); 
3EBC:  CLRF   03
3EBE:  MOVF   x74,W
3EC0:  ADDLW  DC
3EC2:  MOVWF  FE9
3EC4:  MOVLW  02
3EC6:  ADDWFC 03,W
3EC8:  MOVWF  FEA
3ECA:  MOVLW  0A
3ECC:  ADDWF  x74,W
3ECE:  MOVWF  x7A
3ED0:  MOVFF  FF2,37B
3ED4:  BCF    FF2.7
3ED6:  MOVFF  37A,FA9
3EDA:  BCF    FA6.6
3EDC:  BCF    FA6.7
3EDE:  BSF    FA6.0
3EE0:  MOVF   FA8,W
3EE2:  BTFSC  x7B.7
3EE4:  BSF    FF2.7
3EE6:  MOVWF  FEF
3EE8:  INCF   x74,F
3EEA:  BRA    3EB6
....................                      } 
....................                     usb_put_packet(1,txt,10,USB_DTS_TOGGLE); 
3EEC:  MOVLW  01
3EEE:  MOVWF  x78
3EF0:  MOVLW  02
3EF2:  MOVWF  x7A
3EF4:  MOVLW  DC
3EF6:  MOVWF  x79
3EF8:  CLRF   x7C
3EFA:  MOVLW  0A
3EFC:  MOVWF  x7B
3EFE:  MOVLW  02
3F00:  MOVWF  x7D
3F02:  MOVLB  0
3F04:  CALL   2006
....................                     break; 
3F08:  MOVLB  2
3F0A:  BRA    435A
3F0C:  MOVLB  0
....................                   } 
....................                   //------------------------------------------------------------ 
....................                   case READ_N3:// Licture des n tel 3 
....................                   {   
....................                      for(g=0;g<10;g++)  
3F0E:  MOVLB  3
3F10:  CLRF   x74
3F12:  MOVF   x74,W
3F14:  SUBLW  09
3F16:  BNC   3F48
....................                      { 
....................                         txt[g]=read_eeprom(g+20); 
3F18:  CLRF   03
3F1A:  MOVF   x74,W
3F1C:  ADDLW  DC
3F1E:  MOVWF  FE9
3F20:  MOVLW  02
3F22:  ADDWFC 03,W
3F24:  MOVWF  FEA
3F26:  MOVLW  14
3F28:  ADDWF  x74,W
3F2A:  MOVWF  x7A
3F2C:  MOVFF  FF2,37B
3F30:  BCF    FF2.7
3F32:  MOVFF  37A,FA9
3F36:  BCF    FA6.6
3F38:  BCF    FA6.7
3F3A:  BSF    FA6.0
3F3C:  MOVF   FA8,W
3F3E:  BTFSC  x7B.7
3F40:  BSF    FF2.7
3F42:  MOVWF  FEF
3F44:  INCF   x74,F
3F46:  BRA    3F12
....................                      } 
....................                     usb_put_packet(1,txt,10,USB_DTS_TOGGLE); 
3F48:  MOVLW  01
3F4A:  MOVWF  x78
3F4C:  MOVLW  02
3F4E:  MOVWF  x7A
3F50:  MOVLW  DC
3F52:  MOVWF  x79
3F54:  CLRF   x7C
3F56:  MOVLW  0A
3F58:  MOVWF  x7B
3F5A:  MOVLW  02
3F5C:  MOVWF  x7D
3F5E:  MOVLB  0
3F60:  CALL   2006
....................                     break; 
3F64:  MOVLB  2
3F66:  BRA    435A
3F68:  MOVLB  0
....................                   } 
....................                   //------------------------------------------------------------ 
....................                   case READ_N4:// Licture des n tel 4 
....................                   {   
....................                      for(g=0;g<10;g++)  
3F6A:  MOVLB  3
3F6C:  CLRF   x74
3F6E:  MOVF   x74,W
3F70:  SUBLW  09
3F72:  BNC   3FA4
....................                      { 
....................                         txt[g]=read_eeprom(g+30); 
3F74:  CLRF   03
3F76:  MOVF   x74,W
3F78:  ADDLW  DC
3F7A:  MOVWF  FE9
3F7C:  MOVLW  02
3F7E:  ADDWFC 03,W
3F80:  MOVWF  FEA
3F82:  MOVLW  1E
3F84:  ADDWF  x74,W
3F86:  MOVWF  x7A
3F88:  MOVFF  FF2,37B
3F8C:  BCF    FF2.7
3F8E:  MOVFF  37A,FA9
3F92:  BCF    FA6.6
3F94:  BCF    FA6.7
3F96:  BSF    FA6.0
3F98:  MOVF   FA8,W
3F9A:  BTFSC  x7B.7
3F9C:  BSF    FF2.7
3F9E:  MOVWF  FEF
3FA0:  INCF   x74,F
3FA2:  BRA    3F6E
....................                      } 
....................                     usb_put_packet(1,txt,10,USB_DTS_TOGGLE); 
3FA4:  MOVLW  01
3FA6:  MOVWF  x78
3FA8:  MOVLW  02
3FAA:  MOVWF  x7A
3FAC:  MOVLW  DC
3FAE:  MOVWF  x79
3FB0:  CLRF   x7C
3FB2:  MOVLW  0A
3FB4:  MOVWF  x7B
3FB6:  MOVLW  02
3FB8:  MOVWF  x7D
3FBA:  MOVLB  0
3FBC:  CALL   2006
....................                     break; 
3FC0:  MOVLB  2
3FC2:  BRA    435A
3FC4:  MOVLB  0
....................                   } 
....................                   //------------------------------------------------------------ 
....................                   case SEND_RS232: //AT Commande ver Module 
....................                   { 
....................                      printf("%s\r\n",recbuf); 
3FC6:  MOVLW  02
3FC8:  MOVWF  FEA
3FCA:  MOVLW  FE
3FCC:  MOVWF  FE9
3FCE:  CALL   20AE
3FD2:  CLRF   16
3FD4:  BTFSC  FF2.7
3FD6:  BSF    16.7
3FD8:  BCF    FF2.7
3FDA:  MOVLW  0D
3FDC:  MOVLB  3
3FDE:  MOVWF  xAE
3FE0:  MOVLB  0
3FE2:  CALL   0FDA
3FE6:  BTFSC  16.7
3FE8:  BSF    FF2.7
3FEA:  CLRF   16
3FEC:  BTFSC  FF2.7
3FEE:  BSF    16.7
3FF0:  BCF    FF2.7
3FF2:  MOVLW  0A
3FF4:  MOVLB  3
3FF6:  MOVWF  xAE
3FF8:  MOVLB  0
3FFA:  CALL   0FDA
3FFE:  BTFSC  16.7
4000:  BSF    FF2.7
....................                      break; 
4002:  MOVLB  2
4004:  BRA    435A
4006:  MOVLB  0
....................                   } 
....................                   //------------------------------------------------------------ 
....................                   case GET_RS232: //AT Commande ver Module 
....................                   { 
....................                      usb_put_packet(1,buffer,rs232_l,USB_DTS_TOGGLE); 
4008:  MOVLW  01
400A:  MOVLB  3
400C:  MOVWF  x78
400E:  MOVWF  x7A
4010:  MOVLW  C8
4012:  MOVWF  x79
4014:  CLRF   x7C
4016:  MOVFF  354,37B
401A:  MOVLW  02
401C:  MOVWF  x7D
401E:  MOVLB  0
4020:  CALL   2006
....................                      break; 
4024:  MOVLB  2
4026:  BRA    435A
4028:  MOVLB  0
....................                   } 
....................                   //------------------------------------------------------------ 
....................                   case GET_FIRMWARE: 
....................                   { 
....................                      usb_put_packet(1,Version,6,USB_DTS_TOGGLE); 
402A:  MOVLW  01
402C:  MOVLB  3
402E:  MOVWF  x78
4030:  MOVLW  02
4032:  MOVWF  x7A
4034:  MOVLW  CF
4036:  MOVWF  x79
4038:  CLRF   x7C
403A:  MOVLW  06
403C:  MOVWF  x7B
403E:  MOVLW  02
4040:  MOVWF  x7D
4042:  MOVLB  0
4044:  CALL   2006
....................                      break; 
4048:  MOVLB  2
404A:  BRA    435A
404C:  MOVLB  0
....................                   } 
....................                   //------------------------------------------------------------ 
....................                   case GET_MODULE: 
....................                   { 
....................                      usb_put_packet(1,Module,6,USB_DTS_TOGGLE); 
404E:  MOVLW  01
4050:  MOVLB  3
4052:  MOVWF  x78
4054:  MOVLW  02
4056:  MOVWF  x7A
4058:  MOVLW  D5
405A:  MOVWF  x79
405C:  CLRF   x7C
405E:  MOVLW  06
4060:  MOVWF  x7B
4062:  MOVLW  02
4064:  MOVWF  x7D
4066:  MOVLB  0
4068:  CALL   2006
....................                      break; 
406C:  MOVLB  2
406E:  BRA    435A
4070:  MOVLB  0
....................                   } 
....................                   //------------------------------------------------------------ 
....................                   case SAVE_FLAG: 
....................                   { 
....................                      if (recbuf[1]=='0') write_eeprom(255,0); 
4072:  MOVLB  2
4074:  MOVF   xFF,W
4076:  SUBLW  30
4078:  BNZ   40A4
407A:  MOVF   FF2,W
407C:  MOVWF  00
407E:  BCF    FF2.7
4080:  SETF   FA9
4082:  CLRF   FA8
4084:  BCF    FA6.6
4086:  BCF    FA6.7
4088:  BSF    FA6.2
408A:  MOVLB  F
408C:  MOVLW  55
408E:  MOVWF  FA7
4090:  MOVLW  AA
4092:  MOVWF  FA7
4094:  BSF    FA6.1
4096:  BTFSC  FA6.1
4098:  BRA    4096
409A:  BCF    FA6.2
409C:  MOVF   00,W
409E:  IORWF  FF2,F
40A0:  BRA    40CC
40A2:  MOVLB  2
....................                      else write_eeprom(255,1); 
40A4:  MOVF   FF2,W
40A6:  MOVWF  00
40A8:  BCF    FF2.7
40AA:  SETF   FA9
40AC:  MOVLW  01
40AE:  MOVWF  FA8
40B0:  BCF    FA6.6
40B2:  BCF    FA6.7
40B4:  BSF    FA6.2
40B6:  MOVLB  F
40B8:  MOVLW  55
40BA:  MOVWF  FA7
40BC:  MOVLW  AA
40BE:  MOVWF  FA7
40C0:  BSF    FA6.1
40C2:  BTFSC  FA6.1
40C4:  BRA    40C2
40C6:  BCF    FA6.2
40C8:  MOVF   00,W
40CA:  IORWF  FF2,F
....................                      break; 
40CC:  MOVLB  2
40CE:  BRA    435A
40D0:  MOVLB  0
....................                   } 
....................                   //------------------------------------------------------------ 
....................                   case SOLD_FLAG: 
....................                   { 
....................                      if (recbuf[1]=='0') write_eeprom(254,0); 
40D2:  MOVLB  2
40D4:  MOVF   xFF,W
40D6:  SUBLW  30
40D8:  BNZ   4106
40DA:  MOVF   FF2,W
40DC:  MOVWF  00
40DE:  BCF    FF2.7
40E0:  MOVLW  FE
40E2:  MOVWF  FA9
40E4:  CLRF   FA8
40E6:  BCF    FA6.6
40E8:  BCF    FA6.7
40EA:  BSF    FA6.2
40EC:  MOVLB  F
40EE:  MOVLW  55
40F0:  MOVWF  FA7
40F2:  MOVLW  AA
40F4:  MOVWF  FA7
40F6:  BSF    FA6.1
40F8:  BTFSC  FA6.1
40FA:  BRA    40F8
40FC:  BCF    FA6.2
40FE:  MOVF   00,W
4100:  IORWF  FF2,F
4102:  BRA    4130
4104:  MOVLB  2
....................                      else write_eeprom(254,1); 
4106:  MOVF   FF2,W
4108:  MOVWF  00
410A:  BCF    FF2.7
410C:  MOVLW  FE
410E:  MOVWF  FA9
4110:  MOVLW  01
4112:  MOVWF  FA8
4114:  BCF    FA6.6
4116:  BCF    FA6.7
4118:  BSF    FA6.2
411A:  MOVLB  F
411C:  MOVLW  55
411E:  MOVWF  FA7
4120:  MOVLW  AA
4122:  MOVWF  FA7
4124:  BSF    FA6.1
4126:  BTFSC  FA6.1
4128:  BRA    4126
412A:  BCF    FA6.2
412C:  MOVF   00,W
412E:  IORWF  FF2,F
....................                      break; 
4130:  MOVLB  2
4132:  BRA    435A
4134:  MOVLB  0
....................                   } 
....................                   //------------------------------------------------------------ 
....................                   case MA_FLAG: 
....................                   { 
....................                      if (recbuf[1]=='0') write_eeprom(253,0); 
4136:  MOVLB  2
4138:  MOVF   xFF,W
413A:  SUBLW  30
413C:  BNZ   416A
413E:  MOVF   FF2,W
4140:  MOVWF  00
4142:  BCF    FF2.7
4144:  MOVLW  FD
4146:  MOVWF  FA9
4148:  CLRF   FA8
414A:  BCF    FA6.6
414C:  BCF    FA6.7
414E:  BSF    FA6.2
4150:  MOVLB  F
4152:  MOVLW  55
4154:  MOVWF  FA7
4156:  MOVLW  AA
4158:  MOVWF  FA7
415A:  BSF    FA6.1
415C:  BTFSC  FA6.1
415E:  BRA    415C
4160:  BCF    FA6.2
4162:  MOVF   00,W
4164:  IORWF  FF2,F
4166:  BRA    4194
4168:  MOVLB  2
....................                      else write_eeprom(253,1); 
416A:  MOVF   FF2,W
416C:  MOVWF  00
416E:  BCF    FF2.7
4170:  MOVLW  FD
4172:  MOVWF  FA9
4174:  MOVLW  01
4176:  MOVWF  FA8
4178:  BCF    FA6.6
417A:  BCF    FA6.7
417C:  BSF    FA6.2
417E:  MOVLB  F
4180:  MOVLW  55
4182:  MOVWF  FA7
4184:  MOVLW  AA
4186:  MOVWF  FA7
4188:  BSF    FA6.1
418A:  BTFSC  FA6.1
418C:  BRA    418A
418E:  BCF    FA6.2
4190:  MOVF   00,W
4192:  IORWF  FF2,F
....................                      break; 
4194:  MOVLB  2
4196:  BRA    435A
4198:  MOVLB  0
....................                   } 
....................                   //------------------------------------------------------------ 
....................                   case SAVE_SN: 
....................                   { 
....................                      nl0=recbuf[1]; 
419A:  MOVFF  2FF,E0
....................                      write_eeprom(sold_add,nl0); 
419E:  MOVF   FF2,W
41A0:  MOVWF  00
41A2:  BCF    FF2.7
41A4:  MOVLW  32
41A6:  MOVWF  FA9
41A8:  MOVFF  E0,FA8
41AC:  BCF    FA6.6
41AE:  BCF    FA6.7
41B0:  BSF    FA6.2
41B2:  MOVLB  F
41B4:  MOVLW  55
41B6:  MOVWF  FA7
41B8:  MOVLW  AA
41BA:  MOVWF  FA7
41BC:  BSF    FA6.1
41BE:  BTFSC  FA6.1
41C0:  BRA    41BE
41C2:  BCF    FA6.2
41C4:  MOVF   00,W
41C6:  IORWF  FF2,F
....................                      for(i0=0;i0<nl0;i0++) 
41C8:  MOVLB  1
41CA:  CLRF   xC7
41CC:  MOVLB  0
41CE:  MOVF   xE0,W
41D0:  MOVLB  1
41D2:  SUBWF  xC7,W
41D4:  BC    4226
....................                      { 
....................                         write_eeprom(sold_add+i0+1,recbuf[i0+2]); 
41D6:  MOVLW  32
41D8:  ADDWF  xC7,W
41DA:  ADDLW  01
41DC:  MOVLB  3
41DE:  MOVWF  x78
41E0:  MOVLW  02
41E2:  MOVLB  1
41E4:  ADDWF  xC7,W
41E6:  CLRF   03
41E8:  ADDLW  FE
41EA:  MOVWF  FE9
41EC:  MOVLW  02
41EE:  ADDWFC 03,W
41F0:  MOVWF  FEA
41F2:  MOVFF  FEF,379
41F6:  MOVF   FF2,W
41F8:  MOVWF  00
41FA:  BCF    FF2.7
41FC:  MOVFF  378,FA9
4200:  MOVFF  379,FA8
4204:  BCF    FA6.6
4206:  BCF    FA6.7
4208:  BSF    FA6.2
420A:  MOVLB  F
420C:  MOVLW  55
420E:  MOVWF  FA7
4210:  MOVLW  AA
4212:  MOVWF  FA7
4214:  BSF    FA6.1
4216:  BTFSC  FA6.1
4218:  BRA    4216
421A:  BCF    FA6.2
421C:  MOVF   00,W
421E:  IORWF  FF2,F
4220:  MOVLB  1
4222:  INCF   xC7,F
4224:  BRA    41CC
....................                      } 
....................                      break; 
4226:  MOVLB  2
4228:  BRA    435A
422A:  MOVLB  0
....................                   } 
....................                   //------------------------------------------------------------ 
....................                   case SAVE_SM: 
....................                   { 
....................                      write_eeprom(252,recbuf[1]); 
422C:  MOVF   FF2,W
422E:  MOVWF  00
4230:  BCF    FF2.7
4232:  MOVLW  FC
4234:  MOVWF  FA9
4236:  MOVFF  2FF,FA8
423A:  BCF    FA6.6
423C:  BCF    FA6.7
423E:  BSF    FA6.2
4240:  MOVLB  F
4242:  MOVLW  55
4244:  MOVWF  FA7
4246:  MOVLW  AA
4248:  MOVWF  FA7
424A:  BSF    FA6.1
424C:  BTFSC  FA6.1
424E:  BRA    424C
4250:  BCF    FA6.2
4252:  MOVF   00,W
4254:  IORWF  FF2,F
....................                      break; 
4256:  MOVLB  2
4258:  BRA    435A
425A:  MOVLB  0
....................                   } 
....................                   //------------------------------------------------------------ 
....................                   case SAVE_PWD: 
....................                   { 
....................                      nl0=recbuf[1]; 
425C:  MOVFF  2FF,E0
....................                      write_eeprom(pass_add,nl0); 
4260:  MOVF   FF2,W
4262:  MOVWF  00
4264:  BCF    FF2.7
4266:  MOVLW  28
4268:  MOVWF  FA9
426A:  MOVFF  E0,FA8
426E:  BCF    FA6.6
4270:  BCF    FA6.7
4272:  BSF    FA6.2
4274:  MOVLB  F
4276:  MOVLW  55
4278:  MOVWF  FA7
427A:  MOVLW  AA
427C:  MOVWF  FA7
427E:  BSF    FA6.1
4280:  BTFSC  FA6.1
4282:  BRA    4280
4284:  BCF    FA6.2
4286:  MOVF   00,W
4288:  IORWF  FF2,F
....................                      for(i0=0;i0<nl0;i0++) 
428A:  MOVLB  1
428C:  CLRF   xC7
428E:  MOVLB  0
4290:  MOVF   xE0,W
4292:  MOVLB  1
4294:  SUBWF  xC7,W
4296:  BC    42E6
....................                      { 
....................                         write_eeprom(pass_add+1+i0,recbuf[i0+2]); 
4298:  MOVLW  29
429A:  ADDWF  xC7,W
429C:  MOVLB  3
429E:  MOVWF  x78
42A0:  MOVLW  02
42A2:  MOVLB  1
42A4:  ADDWF  xC7,W
42A6:  CLRF   03
42A8:  ADDLW  FE
42AA:  MOVWF  FE9
42AC:  MOVLW  02
42AE:  ADDWFC 03,W
42B0:  MOVWF  FEA
42B2:  MOVFF  FEF,379
42B6:  MOVF   FF2,W
42B8:  MOVWF  00
42BA:  BCF    FF2.7
42BC:  MOVFF  378,FA9
42C0:  MOVFF  379,FA8
42C4:  BCF    FA6.6
42C6:  BCF    FA6.7
42C8:  BSF    FA6.2
42CA:  MOVLB  F
42CC:  MOVLW  55
42CE:  MOVWF  FA7
42D0:  MOVLW  AA
42D2:  MOVWF  FA7
42D4:  BSF    FA6.1
42D6:  BTFSC  FA6.1
42D8:  BRA    42D6
42DA:  BCF    FA6.2
42DC:  MOVF   00,W
42DE:  IORWF  FF2,F
42E0:  MOVLB  1
42E2:  INCF   xC7,F
42E4:  BRA    428E
....................                      } 
....................                      break; 
42E6:  MOVLB  2
42E8:  BRA    435A
42EA:  MOVLB  0
....................                   } 
....................                   case  READ_SPEED: 
....................                   { 
....................                      speed_limit=read_eeprom(speed_add); 
42EC:  MOVFF  FF2,378
42F0:  BCF    FF2.7
42F2:  MOVLW  46
42F4:  MOVWF  FA9
42F6:  BCF    FA6.6
42F8:  BCF    FA6.7
42FA:  BSF    FA6.0
42FC:  MOVF   FA8,W
42FE:  MOVLB  3
4300:  BTFSC  x78.7
4302:  BSF    FF2.7
4304:  MOVLB  0
4306:  MOVWF  xE3
....................                      usb_put_packet(1,speed_limit,1,USB_DTS_TOGGLE); 
4308:  MOVLW  01
430A:  MOVLB  3
430C:  MOVWF  x78
430E:  CLRF   x7A
4310:  MOVFF  E3,379
4314:  CLRF   x7C
4316:  MOVWF  x7B
4318:  MOVLW  02
431A:  MOVWF  x7D
431C:  MOVLB  0
431E:  CALL   2006
....................                      break; 
4322:  MOVLB  2
4324:  BRA    435A
4326:  MOVLB  0
....................                   } 
....................                   case  WRITE_SPEED: 
....................                   { 
....................                      write_eeprom(speed_add,recbuf[1]); 
4328:  MOVF   FF2,W
432A:  MOVWF  00
432C:  BCF    FF2.7
432E:  MOVLW  46
4330:  MOVWF  FA9
4332:  MOVFF  2FF,FA8
4336:  BCF    FA6.6
4338:  BCF    FA6.7
433A:  BSF    FA6.2
433C:  MOVLB  F
433E:  MOVLW  55
4340:  MOVWF  FA7
4342:  MOVLW  AA
4344:  MOVWF  FA7
4346:  BSF    FA6.1
4348:  BTFSC  FA6.1
434A:  BRA    4348
434C:  BCF    FA6.2
434E:  MOVF   00,W
4350:  IORWF  FF2,F
....................                      break; 
4352:  MOVLB  2
4354:  BRA    435A
4356:  MOVLB  0
4358:  MOVLB  2
....................                   } 
....................                   //------------------------------------------------------------ 
....................                    
....................                } 
....................             } 
....................           
....................          } 
....................       } 
435A:  GOTO   4C7A
435E:  MOVLB  0
....................       else //**********************  Fonctionnemnt Alarme ******************* 
....................       { 
....................       #ifdef ALARME 
....................          #ifdef TLE_OLD 
....................       //----------------------------------------------------------------------- 
....................          if(input(TELE_LK)) 
4360:  BTFSS  F81.7
4362:  BRA    4390
....................          { 
....................             if(!TELE_LK_OLD) 
4364:  BTFSC  18.1
4366:  BRA    438E
....................             { 
....................                if(ARM==0) 
4368:  BTFSC  18.5
436A:  BRA    438E
....................                { 
....................                   ARM=1; 
436C:  BSF    18.5
....................                   ARM_action(); 
436E:  GOTO   20E0
....................                   TELE_LK_OLD=1; 
4372:  BSF    18.1
....................                   ALARM=0; 
4374:  BCF    18.0
....................                   #ifdef   DEBUG0 
....................                   fprintf(DEBUG,"ARM=1\r\n"); 
4376:  MOVLW  DA
4378:  MOVWF  FF6
437A:  MOVLW  15
437C:  MOVWF  FF7
437E:  CLRF   16
4380:  BTFSC  FF2.7
4382:  BSF    16.7
4384:  BCF    FF2.7
4386:  CALL   102C
438A:  BTFSC  16.7
438C:  BSF    FF2.7
....................                   #endif 
....................                } 
....................             } 
....................  
....................          } 
438E:  BRA    4392
....................          else TELE_LK_OLD=0; 
4390:  BCF    18.1
....................          //------------------------------------------------------------------ 
....................          if(input(TELE_N_LK)) 
4392:  BTFSS  F81.4
4394:  BRA    43CC
....................          { 
....................             if(!TELE_N_LK_OLD) 
4396:  BTFSC  18.3
4398:  BRA    43CA
....................             { 
....................                if(ARM==1) 
439A:  BTFSS  18.5
439C:  BRA    43CA
....................                { 
....................                   if(ALARM==0) 
439E:  BTFSC  18.0
43A0:  BRA    43C8
....................                   { 
....................                      ARM=0; 
43A2:  BCF    18.5
....................                      ALARM=0; 
43A4:  BCF    18.0
....................                      msg_ok=1; 
43A6:  BSF    18.7
....................                      D_ARM_action(); 
43A8:  GOTO   212A
....................                      TELE_N_LK_OLD=1; 
43AC:  BSF    18.3
....................                      #ifdef   DEBUG0 
....................                      fprintf(DEBUG,"ARM=0\r\n"); 
43AE:  MOVLW  E2
43B0:  MOVWF  FF6
43B2:  MOVLW  15
43B4:  MOVWF  FF7
43B6:  CLRF   16
43B8:  BTFSC  FF2.7
43BA:  BSF    16.7
43BC:  BCF    FF2.7
43BE:  CALL   102C
43C2:  BTFSC  16.7
43C4:  BSF    FF2.7
....................                      #endif 
....................                   } 
43C6:  BRA    43CA
....................                   else ALARM=0; 
43C8:  BCF    18.0
....................                } 
....................             } 
....................          } 
43CA:  BRA    43CE
....................          else TELE_N_LK_OLD=0; 
43CC:  BCF    18.3
....................          //-------------------------------------------------------------------- 
....................          if(input(TELE_SN)) 
43CE:  BTFSS  F81.6
43D0:  BRA    43DA
....................          { 
....................             if(!TELE_SN_OLD) 
43D2:  BTFSC  18.2
43D4:  BRA    43DA
....................             { 
....................                SRN_EN=1; 
43D6:  BSF    18.6
....................                //ARM_action(); 
....................                TELE_SN_OLD=1; 
43D8:  BSF    18.2
....................             } 
....................              
....................          } 
....................          TELE_SN_OLD=0; 
43DA:  BCF    18.2
....................          if(input(TELE_N_SN)) 
43DC:  BTFSS  F81.5
43DE:  BRA    43EA
....................          { 
....................             if(!TELE_N_SN_OLD) 
43E0:  BTFSC  18.4
43E2:  BRA    43EA
....................             { 
....................                SRN_EN=0; 
43E4:  BCF    18.6
....................                ALARM=0; 
43E6:  BCF    18.0
....................                //D_ARM_action(); 
....................                TELE_N_SN_OLD=1; 
43E8:  BSF    18.4
....................             } 
....................          } 
....................          TELE_N_SN_OLD=0; 
43EA:  BCF    18.4
....................          //********************************************************************* 
....................          #else 
....................          if(input(TELE_SN)) 
....................          { 
....................             if(!TELE_SN_OLD) 
....................             { 
....................                if(ARM==0) 
....................                { 
....................                   ARM=1; 
....................                   ARM_action(); 
....................                   TELE_SN_OLD=1; 
....................                   ALARM=0; 
....................                   #ifdef   DEBUG0 
....................                   fprintf(DEBUG,"ARM=1\r\n"); 
....................                   #endif 
....................                } 
....................             } 
....................  
....................          } 
....................          else TELE_SN_OLD=0; 
....................          if(input(TELE_N_SN)) 
....................          { 
....................             if(!TELE_N_SN_OLD) 
....................             { 
....................                if(ARM==1) 
....................                { 
....................                   if(ALARM==0) 
....................                   { 
....................                      ARM=0; 
....................                      ALARM=0; 
....................                      msg_ok=1; 
....................                      D_ARM_action(); 
....................                      TELE_N_SN_OLD=1; 
....................                      #ifdef   DEBUG0 
....................                      fprintf(DEBUG,"ARM=0\r\n"); 
....................                      #endif 
....................                   } 
....................                   else ALARM=0; 
....................                } 
....................             } 
....................          } 
....................          else TELE_N_SN_OLD=0; 
....................          if(input(TELE_N_LK)) 
....................          { 
....................             if(!TELE_N_LK_OLD) 
....................             { 
....................                 
....................                CAR_find(); 
....................                TELE_N_LK_OLD=1; 
....................             } 
....................              
....................          } 
....................          TELE_N_LK_OLD=0; 
....................           
....................          #endif 
....................          al1=read_alarm_input(); 
43EC:  GOTO   21A8
43F0:  MOVFF  01,355
....................          if((al1>0)&&(al1<4)&&(ALARM==0)) 
43F4:  MOVLB  3
43F6:  MOVF   x55,F
43F8:  BZ    447A
43FA:  MOVF   x55,W
43FC:  SUBLW  03
43FE:  BNC   447A
4400:  BTFSC  18.0
4402:  BRA    447A
....................          { 
....................             al2=al1; 
4404:  MOVFF  355,2F9
....................             al0=al1; 
4408:  MOVFF  355,353
....................             #ifdef DEBUG0 
....................                fprintf(DEBUG,"-al0=%d\r\n",al0); 
440C:  MOVLW  EA
440E:  MOVWF  FF6
4410:  MOVLW  15
4412:  MOVWF  FF7
4414:  MOVLW  05
4416:  MOVWF  x87
4418:  MOVLB  0
441A:  CALL   21D4
441E:  MOVFF  353,378
4422:  MOVLW  18
4424:  MOVLB  3
4426:  MOVWF  x79
4428:  MOVLB  0
442A:  GOTO   220A
442E:  CLRF   16
4430:  BTFSC  FF2.7
4432:  BSF    16.7
4434:  BCF    FF2.7
4436:  MOVLW  0D
4438:  MOVLB  3
443A:  MOVWF  xAE
443C:  MOVLB  0
443E:  CALL   0FDA
4442:  BTFSC  16.7
4444:  BSF    FF2.7
4446:  CLRF   16
4448:  BTFSC  FF2.7
444A:  BSF    16.7
444C:  BCF    FF2.7
444E:  MOVLW  0A
4450:  MOVLB  3
4452:  MOVWF  xAE
4454:  MOVLB  0
4456:  CALL   0FDA
445A:  BTFSC  16.7
445C:  BSF    FF2.7
....................             #endif 
....................             if(ARM) 
445E:  BTFSS  18.5
4460:  BRA    446E
....................             { 
....................                ALARM=1; 
4462:  BSF    18.0
....................                count0=0; 
4464:  MOVLB  2
4466:  CLRF   xFD
4468:  CLRF   xFC
....................                 
....................             } 
446A:  BRA    4478
446C:  MOVLB  0
....................             else  
....................             { 
....................                ALARM=0; 
446E:  BCF    18.0
....................                msg_ok=1; 
4470:  BSF    18.7
....................                SRN=0; 
4472:  BCF    17.4
....................                LMR=0; 
4474:  BCF    17.3
4476:  MOVLB  2
4478:  MOVLB  3
....................             } 
....................          } 
....................         // else  
....................          if(ARM) 
447A:  BTFSS  18.5
447C:  BRA    4528
....................          { 
....................             count++; 
447E:  MOVLB  2
4480:  INCF   xFA,F
4482:  BTFSC  FD8.2
4484:  INCF   xFB,F
....................             if(count>60000) 
4486:  MOVF   xFB,W
4488:  SUBLW  E9
448A:  BC    4526
448C:  XORLW  FF
448E:  BNZ   4496
4490:  MOVF   xFA,W
4492:  SUBLW  60
4494:  BC    4526
....................             {   
....................                //fprintf(DEBUG,"Al0=%d\r\n",al0); 
....................                if((msg_ok)&&(ARM)&&(ALARM))  
4496:  BTFSS  18.7
4498:  BRA    44D0
449A:  BTFSS  18.5
449C:  BRA    44D0
449E:  BTFSS  18.0
44A0:  BRA    44D0
....................                { 
....................                  fprintf(DEBUG,"Alarme message \r\n"); 
44A2:  MOVLW  F4
44A4:  MOVWF  FF6
44A6:  MOVLW  15
44A8:  MOVWF  FF7
44AA:  CLRF   16
44AC:  BTFSC  FF2.7
44AE:  BSF    16.7
44B0:  BCF    FF2.7
44B2:  MOVLB  0
44B4:  CALL   102C
44B8:  BTFSC  16.7
44BA:  BSF    FF2.7
....................                  SRN=1; 
44BC:  BSF    17.4
....................                  LMR=1; 
44BE:  BSF    17.3
....................                  write_alarm_outputs(out); 
44C0:  MOVFF  17,37A
44C4:  CALL   1950
....................                  tx(); 
44C8:  GOTO   30EC
....................                  msg_ok=0; 
44CC:  BCF    18.7
44CE:  MOVLB  2
....................                } 
....................                //else fprintf(DEBUG,"Alarme message non autorise\r\n"); 
....................                count=0; 
44D0:  CLRF   xFB
44D2:  CLRF   xFA
....................                if(LED) LED=0; 
44D4:  BTFSS  17.0
44D6:  BRA    44DC
44D8:  BCF    17.0
44DA:  BRA    44DE
....................                else LED=1; 
44DC:  BSF    17.0
....................                count0++; 
44DE:  INCF   xFC,F
44E0:  BTFSC  FD8.2
44E2:  INCF   xFD,F
....................                if(ALARM) 
44E4:  BTFSS  18.0
44E6:  BRA    4516
....................                {   
....................                   count0++; 
44E8:  INCF   xFC,F
44EA:  BTFSC  FD8.2
44EC:  INCF   xFD,F
....................                   if(count0>800) 
44EE:  MOVF   xFD,W
44F0:  SUBLW  02
44F2:  BC    4500
44F4:  XORLW  FF
44F6:  BNZ   44FE
44F8:  MOVF   xFC,W
44FA:  SUBLW  20
44FC:  BC    4500
....................                   { 
....................                      ALARM=0; 
44FE:  BCF    18.0
....................                       
....................                   } 
....................                   //fprintf(DEBUG,"count0=%ld\n\r",count0); 
....................                   if(SRN_EN) SRN=1; 
4500:  BTFSS  18.6
4502:  BRA    4508
4504:  BSF    17.4
4506:  BRA    450A
....................                   else SRN=0; 
4508:  BCF    17.4
....................                   if(LMR) LMR=0; 
450A:  BTFSS  17.3
450C:  BRA    4512
450E:  BCF    17.3
4510:  BRA    4514
....................                   else LMR=1; 
4512:  BSF    17.3
....................                } 
4514:  BRA    451A
....................                else  
....................                { 
....................                   
....................                   SRN=0; 
4516:  BCF    17.4
....................                   LMR=0; 
4518:  BCF    17.3
....................                } 
....................                write_alarm_outputs(out); 
451A:  MOVFF  17,37A
451E:  MOVLB  0
4520:  CALL   1950
4524:  MOVLB  2
4526:  MOVLB  3
....................             } 
....................          } 
....................       #endif 
....................       if(sold) 
4528:  MOVLB  0
452A:  BTFSS  x9F.7
452C:  BRA    46A2
....................       { 
....................          if(sms_sold_ask) 
452E:  BTFSS  xA0.5
4530:  BRA    4634
....................          { 
....................             #ifdef DEBUG0 
....................             fprintf(DEBUG,"New Sold\n\r"); 
4532:  MOVLW  06
4534:  MOVWF  FF6
4536:  MOVLW  16
4538:  MOVWF  FF7
453A:  CLRF   16
453C:  BTFSC  FF2.7
453E:  BSF    16.7
4540:  BCF    FF2.7
4542:  CALL   102C
4546:  BTFSC  16.7
4548:  BSF    FF2.7
....................             #endif 
....................             fprintf(GSM,"AT+CMGS=\""); 
454A:  MOVLW  12
454C:  MOVWF  FF6
454E:  MOVLW  16
4550:  MOVWF  FF7
4552:  CALL   1A4E
....................             for(m1=0;m1<10;m1++) fputc(tel_n1[m1],GSM); 
4556:  MOVLB  3
4558:  CLRF   x77
455A:  MOVF   x77,W
455C:  SUBLW  09
455E:  BNC   4580
4560:  CLRF   03
4562:  MOVF   x77,W
4564:  ADDLW  9A
4566:  MOVWF  FE9
4568:  MOVLW  02
456A:  ADDWFC 03,W
456C:  MOVWF  FEA
456E:  MOVFF  FEF,378
4572:  MOVF   x78,W
4574:  MOVLB  0
4576:  CALL   2DBE
457A:  MOVLB  3
457C:  INCF   x77,F
457E:  BRA    455A
....................             fprintf(GSM,"\"\r"); 
4580:  MOVLW  22
4582:  BTFSS  F9E.4
4584:  BRA    4582
4586:  MOVWF  FAD
4588:  MOVLW  0D
458A:  BTFSS  F9E.4
458C:  BRA    458A
458E:  MOVWF  FAD
....................             if(wait_(1000)==1) 
4590:  MOVLW  03
4592:  MOVWF  x7A
4594:  MOVLW  E8
4596:  MOVWF  x79
4598:  MOVLB  0
459A:  CALL   2D76
459E:  DECFSZ 01,W
45A0:  BRA    45FA
....................             { 
....................                start1: 
....................                for(m1=12;m1<sold_msg_l;m1++) fputc(buffer[m1],GSM); 
45A2:  MOVLW  0C
45A4:  MOVLB  3
45A6:  MOVWF  x77
45A8:  MOVLB  2
45AA:  MOVF   xA6,W
45AC:  MOVLB  3
45AE:  SUBWF  x77,W
45B0:  BC    45D2
45B2:  CLRF   03
45B4:  MOVF   x77,W
45B6:  ADDLW  C8
45B8:  MOVWF  FE9
45BA:  MOVLW  01
45BC:  ADDWFC 03,W
45BE:  MOVWF  FEA
45C0:  MOVFF  FEF,378
45C4:  MOVF   x78,W
45C6:  MOVLB  0
45C8:  CALL   2DBE
45CC:  MOVLB  3
45CE:  INCF   x77,F
45D0:  BRA    45A8
....................                fputc(13,GSM); 
45D2:  MOVLW  0D
45D4:  MOVLB  0
45D6:  CALL   2DBE
....................                fputc(10,GSM); 
45DA:  MOVLW  0A
45DC:  CALL   2DBE
....................                #ifdef DEBUG0 
....................                fprintf(DEBUG,"wait ok\n\r"); 
45E0:  MOVLW  1C
45E2:  MOVWF  FF6
45E4:  MOVLW  16
45E6:  MOVWF  FF7
45E8:  CLRF   16
45EA:  BTFSC  FF2.7
45EC:  BSF    16.7
45EE:  BCF    FF2.7
45F0:  CALL   102C
45F4:  BTFSC  16.7
45F6:  BSF    FF2.7
....................                #endif 
....................             } 
45F8:  BRA    4612
....................             else 
....................             { 
....................                #ifdef DEBUG0 
....................                fprintf(DEBUG,"wait no\n\r"); 
45FA:  MOVLW  26
45FC:  MOVWF  FF6
45FE:  MOVLW  16
4600:  MOVWF  FF7
4602:  CLRF   16
4604:  BTFSC  FF2.7
4606:  BSF    16.7
4608:  BCF    FF2.7
460A:  CALL   102C
460E:  BTFSC  16.7
4610:  BSF    FF2.7
....................                #endif 
....................             } 
....................             delay_ms(2000); 
4612:  MOVLW  08
4614:  MOVLB  3
4616:  MOVWF  x78
4618:  MOVLW  FA
461A:  MOVWF  x8C
461C:  MOVLB  0
461E:  CALL   1750
4622:  MOVLB  3
4624:  DECFSZ x78,F
4626:  BRA    4618
....................             fputc(0x1a,GSM); 
4628:  MOVLW  1A
462A:  MOVLB  0
462C:  CALL   2DBE
....................             sms_sold_ask=0; 
4630:  BCF    xA0.5
....................          } 
4632:  BRA    469E
....................          else 
....................          { 
....................             sold_val=get_sold_val(); 
4634:  GOTO   32F4
4638:  MOVFF  02,288
463C:  MOVFF  01,287
....................             if(sold_val<sold_min) 
4640:  MOVLB  2
4642:  MOVF   x88,W
4644:  SUBWF  x8A,W
4646:  BNC   4696
4648:  BNZ   4650
464A:  MOVF   x89,W
464C:  SUBWF  x87,W
464E:  BC    4696
....................             { 
....................                //envoi du message d'alerte du min du solde 
....................                if((c_sold)||(rep_sold)) 
4650:  MOVLB  0
4652:  BTFSC  xA0.7
4654:  BRA    465E
4656:  MOVLB  1
4658:  MOVF   xC5,F
465A:  BZ    4694
465C:  MOVLB  0
....................                { 
....................                   al0=6; 
465E:  MOVLW  06
4660:  MOVLB  3
4662:  MOVWF  x53
....................                   read_tel_n(0,tel_n2); 
4664:  CLRF   x79
4666:  MOVLW  03
4668:  MOVWF  x7B
466A:  MOVLW  3F
466C:  MOVWF  x7A
466E:  MOVLB  0
4670:  CALL   2306
....................                   strcpy(n_tel_,tel_n2); 
4674:  MOVLW  03
4676:  MOVWF  FEA
4678:  MOVLW  49
467A:  MOVWF  FE9
467C:  MOVLW  03
467E:  MOVWF  FE2
4680:  MOVLW  3F
4682:  MOVWF  FE1
4684:  MOVF   FE7,F
4686:  MOVFF  FE6,FEE
468A:  BNZ   4684
....................                   sms(); 
468C:  CALL   2DC6
....................                   c_sold=0; 
4690:  BCF    xA0.7
4692:  MOVLB  1
....................                } 
....................             } 
4694:  BRA    469C
....................             else c_sold=1; 
4696:  MOVLB  0
4698:  BSF    xA0.7
469A:  MOVLB  1
469C:  MOVLB  0
....................          } 
....................          sold_ask=0; 
469E:  BCF    xA0.0
....................          sold=0; 
46A0:  BCF    x9F.7
....................       } 
....................       //----------------------------------------------------------------------- 
....................       if((sms_index==1)&&(sms_ok)) 
46A2:  DECFSZ xDE,W
46A4:  BRA    470E
46A6:  BTFSS  x9F.4
46A8:  BRA    470E
....................       { 
....................          index_ok=0; 
46AA:  BCF    xA0.2
....................          #ifdef ALARME 
....................          LED=1; 
46AC:  BSF    17.0
....................          write_alarm_outputs(out); 
46AE:  MOVFF  17,37A
46B2:  CALL   1950
....................          #endif 
....................          strcpy(index_val0,index_val); 
46B6:  MOVLW  02
46B8:  MOVWF  FEA
46BA:  MOVLW  6C
46BC:  MOVWF  FE9
46BE:  MOVLW  02
46C0:  MOVWF  FE2
46C2:  MOVLW  68
46C4:  MOVWF  FE1
46C6:  MOVF   FE7,F
46C8:  MOVFF  FE6,FEE
46CC:  BNZ   46C6
....................          fprintf(GSM,"AT+CMGR=1\r\n"); 
46CE:  MOVLW  30
46D0:  MOVWF  FF6
46D2:  MOVLW  16
46D4:  MOVWF  FF7
46D6:  CALL   1A4E
....................          #ifdef DEBUG0 
....................          fprintf(DEBUG,"New Sms\n\r"); 
46DA:  MOVLW  3C
46DC:  MOVWF  FF6
46DE:  MOVLW  16
46E0:  MOVWF  FF7
46E2:  CLRF   16
46E4:  BTFSC  FF2.7
46E6:  BSF    16.7
46E8:  BCF    FF2.7
46EA:  CALL   102C
46EE:  BTFSC  16.7
46F0:  BSF    FF2.7
....................          #endif 
....................          delay_ms(1000); 
46F2:  MOVLW  04
46F4:  MOVLB  3
46F6:  MOVWF  x78
46F8:  MOVLW  FA
46FA:  MOVWF  x8C
46FC:  MOVLB  0
46FE:  CALL   1750
4702:  MOVLB  3
4704:  DECFSZ x78,F
4706:  BRA    46F8
....................          sms_ok=0; 
4708:  MOVLB  0
470A:  BCF    x9F.4
....................          sms_ok2=0; 
470C:  BCF    xA0.3
....................          
....................       } 
....................       if((sms_index==2)&&(sms_ok))  
470E:  MOVF   xDE,W
4710:  SUBLW  02
4712:  BNZ   47CA
4714:  BTFSS  x9F.4
4716:  BRA    47CA
....................       { 
....................          etape2: 
....................          //fprintf(DEBUG,"index= %d\n\r",sms_index); 
....................          get_sms_n(tel_n1); 
4718:  MOVLW  02
471A:  MOVLB  3
471C:  MOVWF  x79
471E:  MOVLW  9A
4720:  MOVWF  x78
4722:  MOVLB  0
4724:  GOTO   345C
....................          for(i2=0;i2<4;i2++) 
4728:  MOVLB  2
472A:  CLRF   xF8
472C:  MOVF   xF8,W
472E:  SUBLW  03
4730:  BNC   4776
....................          { 
....................             read_tel_n(i2,tel_n2); 
4732:  MOVFF  2F8,379
4736:  MOVLW  03
4738:  MOVLB  3
473A:  MOVWF  x7B
473C:  MOVLW  3F
473E:  MOVWF  x7A
4740:  MOVLB  0
4742:  CALL   2306
....................             if(strncmp(tel_n2,tel_n1,10)==0)  
4746:  MOVLW  03
4748:  MOVLB  3
474A:  MOVWF  x93
474C:  MOVLW  3F
474E:  MOVWF  x92
4750:  MOVLW  02
4752:  MOVWF  x95
4754:  MOVLW  9A
4756:  MOVWF  x94
4758:  CLRF   x97
475A:  MOVLW  0A
475C:  MOVWF  x96
475E:  MOVLB  0
4760:  CALL   2692
4764:  MOVF   01,F
4766:  BNZ   4770
....................             { 
....................                n_ok=1; 
4768:  BSF    x9F.5
....................                break; 
476A:  MOVLB  2
476C:  BRA    4776
476E:  MOVLB  0
....................             } 
4770:  MOVLB  2
4772:  INCF   xF8,F
4774:  BRA    472C
....................          } 
....................          #ifdef DEBUG0 
....................            fprintf(DEBUG,"SMS Tel N=%s\n\r",tel_n1); 
4776:  MOVLW  46
4778:  MOVWF  FF6
477A:  MOVLW  16
477C:  MOVWF  FF7
477E:  MOVLW  0A
4780:  MOVLB  3
4782:  MOVWF  x87
4784:  MOVLB  0
4786:  CALL   21D4
478A:  MOVLW  02
478C:  MOVWF  FEA
478E:  MOVLW  9A
4790:  MOVWF  FE9
4792:  CALL   20AE
4796:  CLRF   16
4798:  BTFSC  FF2.7
479A:  BSF    16.7
479C:  BCF    FF2.7
479E:  MOVLW  0A
47A0:  MOVLB  3
47A2:  MOVWF  xAE
47A4:  MOVLB  0
47A6:  CALL   0FDA
47AA:  BTFSC  16.7
47AC:  BSF    FF2.7
47AE:  CLRF   16
47B0:  BTFSC  FF2.7
47B2:  BSF    16.7
47B4:  BCF    FF2.7
47B6:  MOVLW  0D
47B8:  MOVLB  3
47BA:  MOVWF  xAE
47BC:  MOVLB  0
47BE:  CALL   0FDA
47C2:  BTFSC  16.7
47C4:  BSF    FF2.7
....................           //fprintf(DEBUG,"SIM Tel N=%s\n\r",tel_n2); 
....................          #endif  
....................           sms_ok=0; 
47C6:  BCF    x9F.4
....................           sms_ok2=1; 
47C8:  BSF    xA0.3
....................       } 
....................        
....................       if((sms_index==3)&&(sms_buffer0[1]=='*')) 
47CA:  MOVF   xDE,W
47CC:  SUBLW  03
47CE:  BTFSS  FD8.2
47D0:  BRA    4AF0
47D2:  MOVLB  2
47D4:  MOVF   x09,W
47D6:  SUBLW  2A
47D8:  BTFSC  FD8.2
47DA:  BRA    47E0
47DC:  MOVLB  0
47DE:  BRA    4AF0
....................       { 
....................          if(sms_ok2==0) goto etape2; 
47E0:  MOVLB  0
47E2:  BTFSC  xA0.3
47E4:  BRA    47E8
47E6:  BRA    4718
....................          #ifdef DEBUG0 
....................         // fprintf(DEBUG,"index= %d\n\r",sms_index);    
....................          fprintf(DEBUG,"SMS msg=%s\n\r",sms_buffer0); 
47E8:  MOVLW  56
47EA:  MOVWF  FF6
47EC:  MOVLW  16
47EE:  MOVWF  FF7
47F0:  MOVLW  08
47F2:  MOVLB  3
47F4:  MOVWF  x87
47F6:  MOVLB  0
47F8:  CALL   21D4
47FC:  MOVLW  02
47FE:  MOVWF  FEA
4800:  MOVLW  08
4802:  MOVWF  FE9
4804:  CALL   20AE
4808:  CLRF   16
480A:  BTFSC  FF2.7
480C:  BSF    16.7
480E:  BCF    FF2.7
4810:  MOVLW  0A
4812:  MOVLB  3
4814:  MOVWF  xAE
4816:  MOVLB  0
4818:  CALL   0FDA
481C:  BTFSC  16.7
481E:  BSF    FF2.7
4820:  CLRF   16
4822:  BTFSC  FF2.7
4824:  BSF    16.7
4826:  BCF    FF2.7
4828:  MOVLW  0D
482A:  MOVLB  3
482C:  MOVWF  xAE
482E:  MOVLB  0
4830:  CALL   0FDA
4834:  BTFSC  16.7
4836:  BSF    FF2.7
....................          #endif 
....................          if(n_ok) 
4838:  BTFSS  x9F.5
483A:  BRA    4AD4
....................          {            
....................             get_pass_word(pass_word); 
483C:  MOVLW  01
483E:  MOVLB  3
4840:  MOVWF  x79
4842:  MOVLW  49
4844:  MOVWF  x78
4846:  MOVLB  0
4848:  GOTO   35B2
....................             pass_ok=pass_word_ok(); 
484C:  GOTO   3616
4850:  BCF    xA0.4
4852:  BTFSC  01.0
4854:  BSF    xA0.4
....................             #ifdef DEBUG0 
....................             if(pass_ok) fprintf(DEBUG,"Good pass word\r\n"); 
4856:  BTFSS  xA0.4
4858:  BRA    4872
485A:  MOVLW  64
485C:  MOVWF  FF6
485E:  MOVLW  16
4860:  MOVWF  FF7
4862:  CLRF   16
4864:  BTFSC  FF2.7
4866:  BSF    16.7
4868:  BCF    FF2.7
486A:  CALL   102C
486E:  BTFSC  16.7
4870:  BSF    FF2.7
....................             #endif 
....................             if(pass_ok) 
4872:  BTFSS  xA0.4
4874:  BRA    4AD4
....................             { 
....................                switch(sms_buffer0[0]) 
4876:  MOVLB  2
4878:  MOVF   x08,W
487A:  XORLW  41
487C:  MOVLB  0
487E:  BZ    48AA
4880:  XORLW  20
4882:  BZ    48AA
4884:  XORLW  22
4886:  BTFSC  FD8.2
4888:  BRA    49E2
488A:  XORLW  20
488C:  BTFSC  FD8.2
488E:  BRA    49E2
4890:  XORLW  2E
4892:  BTFSC  FD8.2
4894:  BRA    4A00
4896:  XORLW  20
4898:  BTFSC  FD8.2
489A:  BRA    4A00
489C:  XORLW  3E
489E:  BTFSC  FD8.2
48A0:  BRA    4A24
48A2:  XORLW  20
48A4:  BTFSC  FD8.2
48A6:  BRA    4A24
48A8:  BRA    4AD4
....................                { 
....................                   case 'A': 
....................                   case 'a': 
....................                   { 
....................                      #ifdef GPS0 
....................                      speed_limit=read_eeprom(speed_add); 
48AA:  MOVFF  FF2,378
48AE:  BCF    FF2.7
48B0:  MOVLW  46
48B2:  MOVWF  FA9
48B4:  BCF    FA6.6
48B6:  BCF    FA6.7
48B8:  BSF    FA6.0
48BA:  MOVF   FA8,W
48BC:  MOVLB  3
48BE:  BTFSC  x78.7
48C0:  BSF    FF2.7
48C2:  MOVLB  0
48C4:  MOVWF  xE3
....................                      if(speed_limit<100) 
48C6:  MOVF   xE3,W
48C8:  SUBLW  63
48CA:  BNC   49A2
....................                      { 
....................                         get_gps_speed(speed1,direction0); 
48CC:  MOVLW  02
48CE:  MOVLB  3
48D0:  MOVWF  x79
48D2:  MOVLW  A7
48D4:  MOVWF  x78
48D6:  MOVLW  02
48D8:  MOVWF  x7B
48DA:  MOVLW  AC
48DC:  MOVWF  x7A
48DE:  MOVLB  0
48E0:  CALL   36F2
....................                         speed=speed_cal(speed1); 
48E4:  MOVLW  02
48E6:  MOVLB  3
48E8:  MOVWF  x79
48EA:  MOVLW  A7
48EC:  MOVWF  x78
48EE:  MOVLB  0
48F0:  CALL   38B4
48F4:  MOVFF  01,1BF
....................                         if(speed<speed_limit) 
48F8:  MOVF   xE3,W
48FA:  MOVLB  1
48FC:  SUBWF  xBF,W
48FE:  BC    4934
....................                         { 
....................                            #ifdef ALARME 
....................                            RL_ARR=0; 
4900:  BCF    17.5
....................                            write_alarm_outputs(out); 
4902:  MOVFF  17,37A
4906:  MOVLB  0
4908:  CALL   1950
....................                            #else 
....................                            output_low(RL_ARR); 
....................                            #endif 
....................                            al0=5; 
490C:  MOVLW  05
490E:  MOVLB  3
4910:  MOVWF  x53
....................                            strcpy(n_tel_,tel_n1); 
4912:  MOVLW  03
4914:  MOVWF  FEA
4916:  MOVLW  49
4918:  MOVWF  FE9
491A:  MOVLW  02
491C:  MOVWF  FE2
491E:  MOVLW  9A
4920:  MOVWF  FE1
4922:  MOVF   FE7,F
4924:  MOVFF  FE6,FEE
4928:  BNZ   4922
....................                            sms(); 
492A:  MOVLB  0
492C:  CALL   2DC6
....................                         } 
4930:  BRA    4938
4932:  MOVLB  1
....................                         else  
....................                         { 
....................                            halt_flag=1; 
4934:  MOVLB  0
4936:  BSF    x9F.6
....................                         } 
....................                         #ifdef DEBUG0 
....................                         fprintf(DEBUG,"Arret de moteur avec limitation de vitesse\r\n"); 
4938:  MOVLW  76
493A:  MOVWF  FF6
493C:  MOVLW  16
493E:  MOVWF  FF7
4940:  CLRF   16
4942:  BTFSC  FF2.7
4944:  BSF    16.7
4946:  BCF    FF2.7
4948:  CALL   102C
494C:  BTFSC  16.7
494E:  BSF    FF2.7
....................                         fprintf(DEBUG,"speed=%s\r\n",speed1); 
4950:  MOVLW  A4
4952:  MOVWF  FF6
4954:  MOVLW  16
4956:  MOVWF  FF7
4958:  MOVLW  06
495A:  MOVLB  3
495C:  MOVWF  x87
495E:  MOVLB  0
4960:  CALL   21D4
4964:  MOVLW  02
4966:  MOVWF  FEA
4968:  MOVLW  A7
496A:  MOVWF  FE9
496C:  CALL   20AE
4970:  CLRF   16
4972:  BTFSC  FF2.7
4974:  BSF    16.7
4976:  BCF    FF2.7
4978:  MOVLW  0D
497A:  MOVLB  3
497C:  MOVWF  xAE
497E:  MOVLB  0
4980:  CALL   0FDA
4984:  BTFSC  16.7
4986:  BSF    FF2.7
4988:  CLRF   16
498A:  BTFSC  FF2.7
498C:  BSF    16.7
498E:  BCF    FF2.7
4990:  MOVLW  0A
4992:  MOVLB  3
4994:  MOVWF  xAE
4996:  MOVLB  0
4998:  CALL   0FDA
499C:  BTFSC  16.7
499E:  BSF    FF2.7
....................                         #endif 
....................                    
....................                      } 
49A0:  BRA    49E0
....................                      else  
....................                      { 
....................                      #endif 
....................                         #ifdef DEBUG0 
....................                          fprintf(DEBUG,"Arret de moteur sans limitation de vitesse\r\n"); 
49A2:  MOVLW  B0
49A4:  MOVWF  FF6
49A6:  MOVLW  16
49A8:  MOVWF  FF7
49AA:  CLRF   16
49AC:  BTFSC  FF2.7
49AE:  BSF    16.7
49B0:  BCF    FF2.7
49B2:  CALL   102C
49B6:  BTFSC  16.7
49B8:  BSF    FF2.7
....................                         #endif  
....................                         #ifdef ALARME 
....................                          RL_ARR=0; 
49BA:  BCF    17.5
....................                          write_alarm_outputs(out); 
49BC:  MOVFF  17,37A
49C0:  CALL   1950
....................                         #else 
....................                         output_low(RL_ARR); 
....................                         #endif 
....................                         strcpy(n_tel_,tel_n2); 
49C4:  MOVLW  03
49C6:  MOVWF  FEA
49C8:  MOVLW  49
49CA:  MOVWF  FE9
49CC:  MOVLW  03
49CE:  MOVWF  FE2
49D0:  MOVLW  3F
49D2:  MOVWF  FE1
49D4:  MOVF   FE7,F
49D6:  MOVFF  FE6,FEE
49DA:  BNZ   49D4
....................                          sms(); 
49DC:  CALL   2DC6
....................                     #ifdef GPS0 
....................                      } 
....................                     #endif 
....................                         break; 
49E0:  BRA    4AD4
....................                   } 
....................                   case 'C': 
....................                   case 'c': 
....................                   { 
....................                      #ifdef DEBUG0 
....................                      fprintf(DEBUG,"Changer le motde pass\r\n"); 
49E2:  MOVLW  DE
49E4:  MOVWF  FF6
49E6:  MOVLW  16
49E8:  MOVWF  FF7
49EA:  CLRF   16
49EC:  BTFSC  FF2.7
49EE:  BSF    16.7
49F0:  BCF    FF2.7
49F2:  CALL   102C
49F6:  BTFSC  16.7
49F8:  BSF    FF2.7
....................                      #endif 
....................                      save_pass_word(); 
49FA:  GOTO   3918
....................                      break; 
49FE:  BRA    4AD4
....................                   } 
....................                   case 'M': 
....................                   case 'm': 
....................                   { 
....................                      #ifdef   DEBUG0 
....................                      fprintf(DEBUG,"Marche de moteur\r\n"); 
4A00:  MOVLW  F6
4A02:  MOVWF  FF6
4A04:  MOVLW  16
4A06:  MOVWF  FF7
4A08:  CLRF   16
4A0A:  BTFSC  FF2.7
4A0C:  BSF    16.7
4A0E:  BCF    FF2.7
4A10:  CALL   102C
4A14:  BTFSC  16.7
4A16:  BSF    FF2.7
....................                      #endif 
....................                      #ifdef ALARME 
....................                      RL_ARR=1; 
4A18:  BSF    17.5
....................                      write_alarm_outputs(out); 
4A1A:  MOVFF  17,37A
4A1E:  CALL   1950
....................                      #else 
....................                      output_high(RL_ARR); 
....................                      #endif 
....................                   
....................                      break; 
4A22:  BRA    4AD4
....................                   } 
....................                   case 'S': 
....................                   case 's': 
....................                   { 
....................                      #ifdef DEBUG0 
....................                      fprintf(DEBUG,"Sold de puce\r\n"); 
4A24:  MOVLW  0A
4A26:  MOVWF  FF6
4A28:  MOVLW  17
4A2A:  MOVWF  FF7
4A2C:  CLRF   16
4A2E:  BTFSC  FF2.7
4A30:  BSF    16.7
4A32:  BCF    FF2.7
4A34:  CALL   102C
4A38:  BTFSC  16.7
4A3A:  BSF    FF2.7
....................                      #endif 
....................                      read_sold_msg(sold_msg); 
4A3C:  MOVLW  01
4A3E:  MOVLB  3
4A40:  MOVWF  x79
4A42:  MOVLW  C0
4A44:  MOVWF  x78
4A46:  MOVLB  0
4A48:  GOTO   39D4
....................                      fprintf(DEBUG,"mes_sold=%s\r\n",sold_msg); 
4A4C:  MOVLW  1A
4A4E:  MOVWF  FF6
4A50:  MOVLW  17
4A52:  MOVWF  FF7
4A54:  MOVLW  09
4A56:  MOVLB  3
4A58:  MOVWF  x87
4A5A:  MOVLB  0
4A5C:  CALL   21D4
4A60:  MOVLW  01
4A62:  MOVWF  FEA
4A64:  MOVLW  C0
4A66:  MOVWF  FE9
4A68:  CALL   20AE
4A6C:  CLRF   16
4A6E:  BTFSC  FF2.7
4A70:  BSF    16.7
4A72:  BCF    FF2.7
4A74:  MOVLW  0D
4A76:  MOVLB  3
4A78:  MOVWF  xAE
4A7A:  MOVLB  0
4A7C:  CALL   0FDA
4A80:  BTFSC  16.7
4A82:  BSF    FF2.7
4A84:  CLRF   16
4A86:  BTFSC  FF2.7
4A88:  BSF    16.7
4A8A:  BCF    FF2.7
4A8C:  MOVLW  0A
4A8E:  MOVLB  3
4A90:  MOVWF  xAE
4A92:  MOVLB  0
4A94:  CALL   0FDA
4A98:  BTFSC  16.7
4A9A:  BSF    FF2.7
....................                      fprintf(GSM,"ATD%s;\r\n",sold_msg); 
4A9C:  MOVLW  28
4A9E:  MOVWF  FF6
4AA0:  MOVLW  17
4AA2:  MOVWF  FF7
4AA4:  MOVLW  03
4AA6:  MOVLB  3
4AA8:  MOVWF  x87
4AAA:  MOVLB  0
4AAC:  CALL   1B8A
4AB0:  MOVLW  01
4AB2:  MOVWF  FEA
4AB4:  MOVLW  C0
4AB6:  MOVWF  FE9
4AB8:  CALL   236C
4ABC:  MOVLW  2D
4ABE:  MOVWF  FF6
4AC0:  MOVLW  17
4AC2:  MOVWF  FF7
4AC4:  MOVLW  03
4AC6:  MOVLB  3
4AC8:  MOVWF  x87
4ACA:  MOVLB  0
4ACC:  CALL   1B8A
....................                      sold_ask=1; 
4AD0:  BSF    xA0.0
....................                      sms_sold_ask=1; 
4AD2:  BSF    xA0.5
....................                      break; 
....................                   } 
....................                } 
....................             } 
....................          } 
....................          fprintf(GSM,"AT+CMGD=1\r\n"); 
4AD4:  MOVLW  32
4AD6:  MOVWF  FF6
4AD8:  MOVLW  17
4ADA:  MOVWF  FF7
4ADC:  CALL   1A4E
....................          #ifdef ALARME 
....................          LED=0; 
4AE0:  BCF    17.0
....................          write_alarm_outputs(out); 
4AE2:  MOVFF  17,37A
4AE6:  CALL   1950
....................          #endif 
....................          sms_index=0; 
4AEA:  CLRF   xDE
....................          sms_ok=0; 
4AEC:  BCF    x9F.4
....................          n_ok=0; 
4AEE:  BCF    x9F.5
....................              
....................       } 
....................       //------------------------------------------------------------------------ 
....................       if(halt_flag) 
4AF0:  BTFSS  x9F.6
4AF2:  BRA    4B7E
....................       { 
....................          #ifdef GPS0 
....................          get_gps_speed(speed1,direction0); 
4AF4:  MOVLW  02
4AF6:  MOVLB  3
4AF8:  MOVWF  x79
4AFA:  MOVLW  A7
4AFC:  MOVWF  x78
4AFE:  MOVLW  02
4B00:  MOVWF  x7B
4B02:  MOVLW  AC
4B04:  MOVWF  x7A
4B06:  MOVLB  0
4B08:  CALL   36F2
....................          speed=speed_cal(speed1); 
4B0C:  MOVLW  02
4B0E:  MOVLB  3
4B10:  MOVWF  x79
4B12:  MOVLW  A7
4B14:  MOVWF  x78
4B16:  MOVLB  0
4B18:  CALL   38B4
4B1C:  MOVFF  01,1BF
....................          if(speed<speed_limit) 
4B20:  MOVF   xE3,W
4B22:  MOVLB  1
4B24:  SUBWF  xBF,W
4B26:  BC    4B80
....................          { 
....................             #ifdef ALARME 
....................              RL_ARR=0; 
4B28:  BCF    17.5
....................              write_alarm_outputs(out); 
4B2A:  MOVFF  17,37A
4B2E:  MOVLB  0
4B30:  CALL   1950
....................              #else 
....................              output_low(RL_ARR); 
....................              #endif 
....................              al0=5; 
4B34:  MOVLW  05
4B36:  MOVLB  3
4B38:  MOVWF  x53
....................              for(i2=0;i2<4;i2++) 
4B3A:  MOVLB  2
4B3C:  CLRF   xF8
4B3E:  MOVF   xF8,W
4B40:  SUBLW  03
4B42:  BNC   4B7A
....................             { 
....................                read_tel_n(i2,tel_n2); 
4B44:  MOVFF  2F8,379
4B48:  MOVLW  03
4B4A:  MOVLB  3
4B4C:  MOVWF  x7B
4B4E:  MOVLW  3F
4B50:  MOVWF  x7A
4B52:  MOVLB  0
4B54:  CALL   2306
....................                strcpy(n_tel_,tel_n2); 
4B58:  MOVLW  03
4B5A:  MOVWF  FEA
4B5C:  MOVLW  49
4B5E:  MOVWF  FE9
4B60:  MOVLW  03
4B62:  MOVWF  FE2
4B64:  MOVLW  3F
4B66:  MOVWF  FE1
4B68:  MOVF   FE7,F
4B6A:  MOVFF  FE6,FEE
4B6E:  BNZ   4B68
....................                sms(); 
4B70:  CALL   2DC6
4B74:  MOVLB  2
4B76:  INCF   xF8,F
4B78:  BRA    4B3E
....................                 
....................             } 
....................             halt_flag=0; 
4B7A:  MOVLB  0
4B7C:  BCF    x9F.6
4B7E:  MOVLB  1
....................          } 
....................          #endif 
....................       } 
....................       //------------------------------------------------------------------------ 
....................       #ifdef GPS0 
....................       if(input(SIM_RING)) 
4B80:  BTFSS  F81.1
4B82:  BRA    4C7A
....................       { 
....................       #else  
....................       if(RING_FLG) 
....................       { 
....................          RING_FLG=0; 
....................       #endif 
....................             ring_count=0; 
4B84:  MOVLB  0
4B86:  CLRF   xE1
....................             fprintf(GSM,"ATH\r\n"); 
4B88:  MOVLW  3E
4B8A:  MOVWF  FF6
4B8C:  MOVLW  17
4B8E:  MOVWF  FF7
4B90:  CALL   1A4E
....................             #ifdef ALARME 
....................             LED=1; 
4B94:  BSF    17.0
....................             write_alarm_outputs(out); 
4B96:  MOVFF  17,37A
4B9A:  CALL   1950
....................             #endif 
....................             for(i2=0;i2<4;i2++) 
4B9E:  MOVLB  2
4BA0:  CLRF   xF8
4BA2:  MOVF   xF8,W
4BA4:  SUBLW  03
4BA6:  BNC   4C6C
....................             { 
....................                read_tel_n(i2,tel_n2); 
4BA8:  MOVFF  2F8,379
4BAC:  MOVLW  03
4BAE:  MOVLB  3
4BB0:  MOVWF  x7B
4BB2:  MOVLW  3F
4BB4:  MOVWF  x7A
4BB6:  MOVLB  0
4BB8:  CALL   2306
....................                get_ring_n(tel_n1); 
4BBC:  MOVLW  02
4BBE:  MOVLB  3
4BC0:  MOVWF  x79
4BC2:  MOVLW  9A
4BC4:  MOVWF  x78
4BC6:  MOVLB  0
4BC8:  GOTO   3A28
....................                #ifdef   DEBUG0 
....................                fprintf(DEBUG,"TEL N=%s\r\n",tel_n1); 
4BCC:  MOVLW  44
4BCE:  MOVWF  FF6
4BD0:  MOVLW  17
4BD2:  MOVWF  FF7
4BD4:  MOVLW  06
4BD6:  MOVLB  3
4BD8:  MOVWF  x87
4BDA:  MOVLB  0
4BDC:  CALL   21D4
4BE0:  MOVLW  02
4BE2:  MOVWF  FEA
4BE4:  MOVLW  9A
4BE6:  MOVWF  FE9
4BE8:  CALL   20AE
4BEC:  CLRF   16
4BEE:  BTFSC  FF2.7
4BF0:  BSF    16.7
4BF2:  BCF    FF2.7
4BF4:  MOVLW  0D
4BF6:  MOVLB  3
4BF8:  MOVWF  xAE
4BFA:  MOVLB  0
4BFC:  CALL   0FDA
4C00:  BTFSC  16.7
4C02:  BSF    FF2.7
4C04:  CLRF   16
4C06:  BTFSC  FF2.7
4C08:  BSF    16.7
4C0A:  BCF    FF2.7
4C0C:  MOVLW  0A
4C0E:  MOVLB  3
4C10:  MOVWF  xAE
4C12:  MOVLB  0
4C14:  CALL   0FDA
4C18:  BTFSC  16.7
4C1A:  BSF    FF2.7
....................                #endif 
....................                if(strncmp(tel_n2,tel_n1,10)==0)  
4C1C:  MOVLW  03
4C1E:  MOVLB  3
4C20:  MOVWF  x93
4C22:  MOVLW  3F
4C24:  MOVWF  x92
4C26:  MOVLW  02
4C28:  MOVWF  x95
4C2A:  MOVLW  9A
4C2C:  MOVWF  x94
4C2E:  CLRF   x97
4C30:  MOVLW  0A
4C32:  MOVWF  x96
4C34:  MOVLB  0
4C36:  CALL   2692
4C3A:  MOVF   01,F
4C3C:  BNZ   4C66
....................                { 
....................                  //fprintf(DEBUG,"Get Postion\n\r"); 
....................                  //fprintf(DEBUG,"x=%s ; y=%s ; z=%s\n\r",x,y,z); 
....................                  
....................                  strcpy(n_tel_,tel_n1); 
4C3E:  MOVLW  03
4C40:  MOVWF  FEA
4C42:  MOVLW  49
4C44:  MOVWF  FE9
4C46:  MOVLW  02
4C48:  MOVWF  FE2
4C4A:  MOVLW  9A
4C4C:  MOVWF  FE1
4C4E:  MOVF   FE7,F
4C50:  MOVFF  FE6,FEE
4C54:  BNZ   4C4E
....................                  al2=0; 
4C56:  MOVLB  2
4C58:  CLRF   xF9
....................                  sms(); 
4C5A:  MOVLB  0
4C5C:  CALL   2DC6
....................                  break; 
4C60:  MOVLB  2
4C62:  BRA    4C6C
4C64:  MOVLB  0
....................                } 
4C66:  MOVLB  2
4C68:  INCF   xF8,F
4C6A:  BRA    4BA2
....................               // else  
....................                //fprintf(DEBUG,"N tel= %s N Tel0=%s\n\r",tel_n2,tel_n1); 
....................                //delay_ms(1000); 
....................             } 
....................                #ifdef ALARME 
....................                LED=0; 
4C6C:  BCF    17.0
....................                write_alarm_outputs(out); 
4C6E:  MOVFF  17,37A
4C72:  MOVLB  0
4C74:  CALL   1950
4C78:  MOVLB  1
....................                #endif 
....................              
....................          } 
....................          //------------------------------------------------------------------ 
....................       } 
4C7A:  MOVLB  0
4C7C:  GOTO   3CEA
....................        
....................        
....................    } 
.................... } 
4C80:  SLEEP 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 0700   CCP2C1 PBADEN LPT1OSC NOMCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB

ROM data:
F00000: 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 
F00010: 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 30 
F00020: 30 30 30 30 30 30 30 30 04 30 30 30 30 

F00032: 05 2A 30 30 30 23 
